---
title: "Benchmarks"
output:
  rmarkdown::html_vignette:
    toc: true
    number_sections: true
vignette: >
  %\VignetteIndexEntry{Benchmarks}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(tinycodet)
loadNamespace("bench")
loadNamespace("ggplot2")
```

&nbsp;

# Introduction

Although the functions in this R package were written mostly in 'R' (and a little bit in 'C' and 'C++'), the functions - especially the string related ones - have been well optimized. The string related functions, for example, are about in the same order of magnitude in terms of speed as the `stringi` functions they call.


Here some speed comparisons are given, using the 'bench' package.

&nbsp;


# stri_locate_ith

```{r eval = FALSE}
n <- 1e5
x <- rep(paste0(1:50, collapse = ""), n)
p <- "\\d"
i <- sample(c(-50:-1, 1:50), replace=TRUE, size = n)
locate_stringi <- function(...) {
  stringi::stri_locate_all(...)
  stringi::stri_count(...)
}
bm.stri_locate_ith <- bench::mark(
  "stri_locate_ith" = { stri_locate_ith_regex(x, p, i) },
  "stringi::(stri_locate_all + stri_count)" = { locate_stringi(str=x, regex = p) },
  min_iterations = 500,
  check = FALSE,
  filter_gc = FALSE
)
ggplot2::autoplot(bm.stri_locate_ith)
```

```{r echo = FALSE, fig.width = 8}
load("bm.stri_locate_ith.RData")
ggplot2::autoplot(bm.stri_locate_ith)
```


&nbsp;

# strcut

```{r eval = FALSE}
n <- 1e5
x <- rep("hello", n)
i <- sample(1:3, n, replace = TRUE)
loc <- stri_locate_ith(x, i=i, regex="a|e|i|o|u")
bm.strcut <- bench::mark(
  "strcut_loc" = { strcut_loc(x, loc) },
  "strcut_brk" = { strcut_brk(x, type = "", tolist = TRUE) },
  "stringi::stri_split_boundaries" = {
    stringi::stri_split_boundaries(x, type="character")
  },
  min_iterations = 500,
  check = FALSE,
  filter_gc = FALSE
)
ggplot2::autoplot(bm.strcut)
```

```{r echo = FALSE, fig.width=8}
load("bm.strcut.RData")
ggplot2::autoplot(bm.strcut)
```


&nbsp;

# Row/columns-wise re-ordering

```{r}
tempfun <- function(x, margin) {
  if(margin == 1) {
    for(i in 1:nrow(x)) x[i,] <- sort(x[i,])
    return(x)
  }
  if(margin == 2) {
    for(i in 1:ncol(x)) x[,i] <- sort(x[,i])
    return(x)
  }
}
```



```{r eval = FALSE}
mat <- matrix(sample(seq_len(n^2)), ncol = n)
bm.roworder <- bench::mark(
  tinycodet = mat %row~% mat,
  "base R" = tempfun(mat, 1),
  min_iterations = 250
)
ggplot2::autoplot(bm.roworder)
```

```{r echo = FALSE, fig.width=8}
load("bm.roworder.RData")
ggplot2::autoplot(bm.roworder)
```


```{r eval = FALSE}
bm.colorder <- bench::mark(
  tinycodet = mat %col~% mat,
  "base R" = tempfun(mat, 2),
  min_iterations = 250
)
ggplot2::autoplot(bm.colorder)
```

```{r echo = FALSE, fig.width=8}
load("bm.colorder.RData")
ggplot2::autoplot(bm.colorder)
```

&nbsp;

# form() memory leak

```{r eval=TRUE}
library(pryr)
loopfun <- function() {
  for (i in 1:8) {
    cat(i, ": ", sep = "")
    print(mem_used())
    
    fun_name <- paste0("fun_", i)
    obj_name <- paste0("obj_", i)
    
    assign(
      fun_name,
      f2,
      envir = parent.frame(n = 1)
    )
    assign(
      obj_name,
      eval(parse(text = paste0(fun_name, "()"))),
      envir = parent.frame(n = 1)
    )
    rm(list = fun_name, envir = parent.frame(n = 1))
  }
}
```


When creating a formula with the tilde (` ⁠~` ⁠) operator, and storing a formula in a variable to be used later, the environment is captured by the formula.
Therefore, any object in the captured environment might not be freed from the memory, potentially creating some memory leak.

The `form()` function by default has no environment attached to it, thus has no memory leak.

First a demonstration of the absence of memory leak with the `form()` function
(code inspired by https://r-lib.github.io/fastmap/#memory-leak-examples):

```{r eval=TRUE}
f2 <- function() {
  x <- rnorm(1e6)
  out <- form(a ~ b)
  return(out)
}
gc()
start_mem <- mem_used()
start_time <- as.numeric(Sys.time())
loopfun()
end_time <- as.numeric(Sys.time())
gc()
end_mem <- mem_used()
cat("Elapsed time:", round(end_time - start_time, 1), "seconds\n")
cat("Memory leaked: \n"); print(end_mem - start_mem)
rm(list = "f2")
```


Second, a demonstration of using a regular formula (code inspired by https://r-lib.github.io/fastmap/#memory-leak-examples):

```{r eval=TRUE}
f2 <- function() {
  x <- rnorm(1e6)
  out <- a ~ b
  return(out)
}
gc()
start_mem <- mem_used()
start_time <- as.numeric(Sys.time())
loopfun()
end_time <- as.numeric(Sys.time())
gc()
end_mem <- mem_used()
cat("Elapsed time:", round(end_time - start_time, 1), "seconds\n")
cat("Memory leaked: \n"); print(end_mem - start_mem)
rm(list = "f2")
```

&nbsp;

Thus, clearly using a regular formula (the last chunk) has memory leakage, whereas the `form()` function does not have leakage.

