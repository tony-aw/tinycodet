#'
#' @returns
#' The subsetted object.
#'
#' @seealso \link{tinyoperations_dry}
#'
#' @examples
#'
#'
#'
#' @rdname sub_repl
#' @export
sub_repl.default <- function(x, elements, repl) {
elements <- .sub_repl_make_element_indx(elements, x,  abortcall = sys.call())
if(length(repl) != length(elements)) {
stop("`repl` has incorrect length")
}
return(x[elements])
}
#' @rdname sub_repl
#' @export
sub_repl.list <- function(x, elements) {
elements <- .sub_repl_make_element_indx(elements, x,  abortcall = sys.call())
if(length(repl) != length(elements)) {
stop("`repl` has incorrect length")
}
x[elements] <- repl
return(x)
}
#' @rdname sub_repl
#' @export
sub_repl.environment <- function(x, names) {
if(!is.character(names)) {
stop("only names allowed for environments")
}
names <- .sub_repl_make_element_indx(names, x,  abortcall = sys.call())
if(length(repl) != length(names)) {
stop("`length(repl) != length(names)`")
}
x[names] <- repl
return(x)
}
#' @rdname sub_repl
#' @export
sub_repl.matrix <- function(x, rows, cols, elements, repl) {
if(!missing(rows) & !missing(elements)) {
stop("cannot specify both `rows` and `elements`")
}
if(!missing(cols) & !missing(elements)) {
stop("cannot specify both `cols` and `elements`")
}
if(!missing(elements)) {
if(length(repl) != length(elements)) {
elements <- .sub_repl_make_element_indx(elements, x, abortcall = sys.call())
stop("`repl` has incorrect length")
}
x[elements] <- repl
return(x)
}
if(!missing(rows)) { rows <- .sub_repl_make_dim_indx(rows, x,  1, "rows", abortcall = sys.call()) }
if(missing(rows)) { rows <- 1:nrow(x) }
if(!missing(cols)) { cols <- .sub_repl_make_dim_indx(cols, x,  2, "cols", abortcall = sys.call()) }
if(missing(cols)) { cols <- 1:ncol(x) }
if(any(dim(repl) != c(length(rows), length(cols)))) {
stop("`repl` has incorrect dimensions")
}
x[rows, cols] <- repl
return(x)
}
#' @rdname sub_repl
#' @export
sub_repl.array <- function(x, rows, cols, layers, elements) {
present_dims <- !missing(rows) | !missing(cols) | !missing(layers)
if(present_dims & !missing(elements)) {
stop("cannot specify both `rows`/`cols`/`layers` and `elements`")
}
if(!missing(elements)) {
if(length(repl) != length(elements)) {
elements <- .sub_repl_make_element_indx(elements, x, abortcall = sys.call())
stop("`repl` has incorrect length")
}
x[elements] <- repl
return(x)
}
if(!missing(rows)) { rows <- .sub_get_make_dim_indx(rows, x, 1, "rows", abortcall = sys.call()) }
if(missing(rows)) { rows <- 1:nrow(x) }
if(!missing(cols)) { cols <- .sub_get_make_dim_indx(cols, x, 2, "cols", abortcall = sys.call()) }
if(missing(cols)) { cols <- 1:ncol(x) }
if(!missing(cols)) { layers <- .sub_get_make_dim_indx(layers, x, 3, "layers", abortcall = sys.call()) }
if(missing(layers)) { layers <- 1:(dim(x)[3]) }
if(dim(repl) != c(length(rows), length(cols), length(layers))) {
stop("`repl` has incorrect dimensions")
}
x[rows, cols, layers] <- repl
return(x)
}
#' @rdname sub_repl
#' @export
sub_repl.data.frame <- function(x, repl_lst) {
if(length(names(x))!=ncol(x)) {
stop("`x` does not have unique variable names for all columns; ",
"\n",
"fix this before subsetting")
}
if(!is.list(repl_lst)) {
stop("`repl_lst` must be a list")
}
if(any(!names(repl_lst) %in% colnames(x))) {
stop("not all `names(repl_lst)` appear in `names(x)`")
}
if(any(lengths(repl_lst) != nrow(x))) {
stop("all vectors in `repl_lst` must have the same length as `nrow(x)`")
}
x[names(repl_lst)] <- repl_lst
return(x)
}
#' @rdname sub_repl
#' @export
sub_repl.data.table <- function(x, repl_lst) {
if(length(names(x))!=ncol(x)) {
stop("`x` does not have unique variable names for all columns; ",
"\n",
"fix this before subsetting")
}
if(!is.list(repl_lst)) {
stop("`repl_lst` must be a list")
}
if(any(!names(repl_lst) %in% colnames(x))) {
stop("not all `names(repl_lst)` appear in `names(x)`")
}
if(any(lengths(repl_lst) != nrow(x))) {
stop("all vectors in `repl_lst` must have the same length as `nrow(x)`")
}
for(i in names(repl_lst)) {
x[[i]] <- repl_lst[[i]]
}
return(x)
}
.sub_repl_make_dim_indx <- function(indx, x, dim.L=1, txt="rows", abortcall) {
dnames <- dimnames(x)[[dim.L]]
dlength <-dim(x)[[dim.L]]
.indx_check_general(indx, abortcall)
if(is.character(indx)) {
.indx_check_dimnames(indx, dnames, dlength, abortcall)
if(any(duplicated(indx))) {
error.txt <- "duplicated indices not allowed"
stop(simpleError(error.txt, call = abortcall))
}
return(which(dnames(x) %in% indx))
}
if(is.logical(indx)) {
.indx_check_logical(indx, dlength, abortcall)
indx <- which(indx)
return(indx)
}
if(is.double(indx) | is.integer(indx)) {
.indx_check_int(indx, dlength)
if(any(indx < 1)) {
error.txt <- "negative integers not allowed"
stop(simpleError(error.txt, call = abortcall))
}
if(any(duplicated(indx))) {
error.txt <- "duplicated indices not allowed"
stop(simpleError(error.txt, call = abortcall))
}
return(indx)
}
.indx_stop(abortcall)
}
.sub_repl_make_element_indx <- function(indx, x, abortcall) {
n <- length(x)
.indx_check_general(indx, abortcall)
if(is.character(indx)) {
.indx_check_elnames(x, abortcall)
if(any(duplicated(indx))) {
error.txt <- "duplicated indices not allowed"
stop(simpleError(error.txt, call = abortcall))
}
return(which(names(x) %in% indx))
}
if(is.logical(indx)) {
.indx_check_logical(indx, n, abortcall)
indx <- which(indx)
return(indx)
}
if(is.double(indx) | is.integer(indx)) {
.indx_check_int(indx, n)
if(any(duplicated(indx))) {
error.txt <- "duplicated indices not allowed"
stop(simpleError(error.txt, call = abortcall))
}
return(indx)
}
.indx_stop(abortcall)
}
sub_repl <- function(x, ...) {
UseMethod("sub_repl", x)
}
x <- cbind(1:(1e6), 1:(1e6))
rbenchmark::benchmark(
x[1, 1] <- 10,
sub_repl(x, rows=1, cols=1, repl = 10),
replications = 500
)
x <- cbind(1:(1e7), 1:(1e7))
rbenchmark::benchmark(
x[1, 1] <- 10,
data.table::set(x, 1, 1, 10),
sub_repl(x, rows=1, cols=1, repl = 10),
replications = 500
)
x <- cbind(1:(1e7), 1:(1e7))
x <- cbind(1:(1e7), 1:(1e7))
rbenchmark::benchmark(
x[1, 1] <- 10,
sub_repl(x, rows=1, cols=1, repl = 10),
replications = 500
)
x <- matrix(1:10, ncol=2)
x[integer()]
x[integer(),]
x[,integer()]
foo <- x[,integer()]
foo <- x[,-integer()]
foo
x <- matrix(1:10, ncol=2)
x[NULL]
x[NULL, ]
, ]
missing
setwd("D:/D Desktop/Publications/R package tinyoperations")
sessionInfo()
if(!require(devtools))install.packages("devtools")
if(!require(roxygen2))install.packages("roxygen2")
if(!require(usethis)){install.packages("usethis")}
if(!require(rcmdcheck)){install.packages("rcmdcheck")}
if(!require(spelling)){install.packages("spelling")}
if(!require(tinytex)){install.packages("tinytex")}
if(!require(Rcpp)){install.packages("Rcpp")}
if(!require(pkgdown)){install.packages("pkgdown")}
if(!require(goodpractice)){install.packages("goodpractice")}
if(!require(tinytest)){install.packages("tinytest")}
# documenting the R package:
# setwd()
document("./tinyoperations")
devtools::build_manual(
"./tinyoperations", "./tinyoperations"
) # if this fails...:
spell_check_package("./tinyoperations")
# check package in general:
# Note: edit .Rbuildignore to make it ignore things R CMD CHECK should not check
rcmdcheck::rcmdcheck("./tinyoperations")
# subset_if error checks ====
expect_error(
x %[if]% \(x)x*10,
pattern = "`cond` must return a logical vector containing only TRUE or FALSE"
)
# subset_if ops work ====
x <- matrix(-10:9, ncol=2)
expect_equal(x %[if]% \(x)x %in% 1:10,
1:9)
expect_equal(x %[!if]% \(x)x %in% 1:10,
-10:0)
# subset_if error checks ====
expect_error(
x %[if]% \(x)x*10,
pattern = "`cond` must return a logical vector containing only TRUE or FALSE"
)
expect_error(
x %[!if]% \(x)x*10,
pattern = "`cond` must return a logical vector containing only TRUE or FALSE"
)
# check package in general:
# Note: edit .Rbuildignore to make it ignore things R CMD CHECK should not check
rcmdcheck::rcmdcheck("./tinyoperations")
setwd("D:/D Desktop/Publications/R package tinyoperations")
sessionInfo()
if(!require(devtools))install.packages("devtools")
if(!require(roxygen2))install.packages("roxygen2")
if(!require(usethis)){install.packages("usethis")}
if(!require(rcmdcheck)){install.packages("rcmdcheck")}
if(!require(spelling)){install.packages("spelling")}
if(!require(tinytex)){install.packages("tinytex")}
if(!require(Rcpp)){install.packages("Rcpp")}
if(!require(pkgdown)){install.packages("pkgdown")}
if(!require(goodpractice)){install.packages("goodpractice")}
if(!require(tinytest)){install.packages("tinytest")}
# documenting the R package:
# setwd()
document("./tinyoperations")
# check package in general:
# Note: edit .Rbuildignore to make it ignore things R CMD CHECK should not check
rcmdcheck::rcmdcheck("./tinyoperations")
?is.numeric
# documenting the R package:
# setwd()
document("./tinyoperations")
devtools::build_manual(
"./tinyoperations", "./tinyoperations"
) # if this fails...:
spell_check_package("./tinyoperations")
# check package in general:
# Note: edit .Rbuildignore to make it ignore things R CMD CHECK should not check
rcmdcheck::rcmdcheck("./tinyoperations")
# documenting the R package:
# setwd()
document("./tinyoperations")
devtools::build_manual(
"./tinyoperations", "./tinyoperations"
) # if this fails...:
spell_check_package("./tinyoperations")
# check package in general:
# Note: edit .Rbuildignore to make it ignore things R CMD CHECK should not check
rcmdcheck::rcmdcheck("./tinyoperations")
install("tinyoperations")
# count how many tests I have done (I think I should have at least 100):
testfiles_regular <- list.files("./tinyoperations/inst/tinytest/", pattern = "*.R")
temp.fun <- function(x) {
foo <- readLines(paste0("./tinyoperations/inst/tinytest/", x))
sum(stringi::stri_count(foo, regex="expect_"))
}
testcount_regular <- sapply(
testfiles_regular,
FUN = temp.fun
) |> sum()
iterations <- c(64, 64, 16, 7, 7, 25, 25)
testcount_loops <- sum(iterations) - length(iterations)
testcount_total <- c(
testcount_regular, testcount_loops
) |> sum()
print(testcount_total) # over 600! good! <- I think I need 600 tests in total.
# run the following first before re-loading/-re-documenting the package:
remove.packages("tinyoperations")
setwd("D:/D Desktop/Publications/R package tinyoperations")
sessionInfo()
if(!require(devtools))install.packages("devtools")
if(!require(roxygen2))install.packages("roxygen2")
if(!require(usethis)){install.packages("usethis")}
if(!require(rcmdcheck)){install.packages("rcmdcheck")}
if(!require(spelling)){install.packages("spelling")}
if(!require(tinytex)){install.packages("tinytex")}
if(!require(Rcpp)){install.packages("Rcpp")}
if(!require(pkgdown)){install.packages("pkgdown")}
if(!require(goodpractice)){install.packages("goodpractice")}
if(!require(tinytest)){install.packages("tinytest")}
# documenting the R package:
# setwd()
document("./tinyoperations")
devtools::build_manual(
"./tinyoperations", "./tinyoperations"
) # if this fails...:
spell_check_package("./tinyoperations")
# check package in general:
# Note: edit .Rbuildignore to make it ignore things R CMD CHECK should not check
rcmdcheck::rcmdcheck("./tinyoperations")
install("tinyoperations")
?tinyoperations::`%:=%`
library(tinyoperations)
library(rbenchmark)
n <- 1e5
x <- rep("hello", n)
i <- sample(1:3, n, replace = TRUE)
loc <- stri_locate_ith(x, i=i, regex="a|e|i|o|u")
benchmark.strcut <- benchmark(
"strcut_loc" = { strcut_loc(x, loc) },
"strcut_brk" = { strcut_brk(x, brk="chr") },
"stringi::stri_split_boundaries" = {
stringi::stri_split_boundaries(x, type="character")
},
replications = 50,
order = NULL,
columns = c("test", "replications", "elapsed",
"relative", "user.self", "sys.self")
)
benchmark.strcut
n <- 1e5
x <- rep("hello", n)
i <- sample(1:3, n, replace = TRUE)
loc <- stri_locate_ith(x, i=i, regex="a|e|i|o|u")
benchmark.strcut <- benchmark(
"strcut_loc" = { strcut_loc(x, loc) },
"strcut_brk" = { strcut_brk(x, brk="chr") },
"stringi::stri_split_boundaries" = {
stringi::stri_split_boundaries(x, type="character")
},
replications = 1000,
order = NULL,
columns = c("test", "replications", "elapsed",
"relative", "user.self", "sys.self")
)
n <- 1e5
x <- rep("hello", n)
i <- sample(1:3, n, replace = TRUE)
loc <- stri_locate_ith(x, i=i, regex="a|e|i|o|u")
benchmark.strcut <- benchmark(
"strcut_loc" = { strcut_loc(x, loc) },
"strcut_brk" = { strcut_brk(x, brk="chr") },
"stringi::stri_split_boundaries" = {
stringi::stri_split_boundaries(x, type="character")
},
replications = 500,
order = NULL,
columns = c("test", "replications", "elapsed",
"relative", "user.self", "sys.self")
)
benchmark.strcut
n <- 1e5
x <- rep(paste0(1:100, collapse=""), n)
p <- "\\d"
i <- sample(c(-50:-1, 1:50), replace=TRUE, size = n)
locate_stringi <- function(...) {
stringi::stri_locate_all(...)
stringi::stri_count(...)
}
benchmark.stri_locate_ith <- benchmark(
"stri_locate_ith" = { stri_locate_ith(x, i, regex=p) },
"locate_stringi" = { locate_stringi(str=x, regex=p) },
replications = 500,
order = NULL,
columns = c("test", "replications", "elapsed",
"relative", "user.self", "sys.self")
)
benchmark.stri_locate_ith
save(benchmark.strcut, benchmark.stri_locate_ith, file = "speedtest.RData")
save(benchmark.strcut, benchmark.stri_locate_ith, file = "speedtest.RData")
setwd("D:/D Desktop/Publications/R package tinyoperations/tinyoperations/vignettes")
setwd("D:/D Desktop/Publications/R package tinyoperations/tinyoperations/vignettes")
save(benchmark.strcut, benchmark.stri_locate_ith, file = "speedtest.RData")
library(lubridate)
install.packages("lubridate")
library(lubridate)
library(MASS)
library(mgcv)
rm(list=ls()) # clearing environment again
library(data.table)
library(lubridate) # <- notice library overwrites base R and `data.table`
# detaching lubridate and data.table again:
detach("package:lubridate")
detach("data.table:lubridate")
?tinyoperations::import_as
library(lubridate)
library(data.table)
# detaching lubridate again:
detach("package:lubridate")
library(data.table)
library(lubridate) # <- notice lubridate overwrites base R AND data.table
# detaching lubridate again:
detach("package:lubridate")
lub <- loadNamespace("lubridate")
View(lub)
library(ggplot2)
model.matrix
model.matrix.default()
model.matrix.default
?model.frame()
model.frame
model.frame.default()
model.frame.default
d <- data.frame(a=1:10, b = letters[1:10])
model.matrix(~a>5 & b!="a", data = d)
model.frame(~a>5 & b!="a", data = d)
foo <- model.frame(~a>5 & b!="a", data = d)
foo2 <- model.matrix(~a>5 & b!="a", data = d)
.indx_make_filter <- function(x, filter) {
check_is_formula <- inherits(filter, "formula") & is.call(filter)
if(!check_is_formula) {
stop("`filter` must be a formula")
}
mm <- model.frame(as.formula(filter), data = x)
if(ncol(mm) != 1) {
stop("invalid formula given")
}
if(!all(mm[, 1] %in% c(0, 1, TRUE, FALSE))) {
stop("invalid formula given")
}
cond <- as.logical(mm)
return(cond)
}
.indx_make_get_vars <- function(x, get_vars) {
if(!is.function(get_vars)) {
stop("`get_vars` must be a function")
}
col <- collapse::get_vars(x, get_vars, return = "indices")
}
?collapse::fndistinct()
.indx_check_df <- function(x, row, col, filter, get_vars, abortcall) {
if(!is.null(filter) && !is.null(row)) {
error.txt <- simpleError(
"cannot specify both `filter` and `row`",
call = abortcall
)
stop(error.txt)
}
if(!is.null(get_vars) && !is.null(col)) {
error.txt <- simpleError(
"cannot specify both `get_vars` and `col`",
call = abortcall
)
stop(error.txt)
}
if(collapse::fndistinct(names(x)) != collapse::fncol(x)) {
error.txt <- simpleError(paste0(
"`x` does not have unique variable names for all columns; ",
"\n",
"fix this before subsetting"
), call = abortcall)
stop(error.txt)
}
}
?tinycodet::s_regex
library(tinycodet)
?tinycodet_import
