neg <- which(i < 0)
pos <- which(i > 0)
check <- length(i) == (length(neg) + length(pos))
}
i <- c(-1e5:-1, 1:1e5, 0)
bench::mark(
tempfun1(i),
tempfun2(i)
)
# any vs notwhich ====
tempfun1 <- function(i) {
check <- any(i==0) || anyNA(i)
neg <- which(i < 0)
pos <- which(i > 0)
return(check)
}
tempfun2 <- function(i) {
neg <- which(i < 0)
pos <- which(i > 0)
check <- length(i) != (length(neg) + length(pos))
return(check)
}
i <- c(-1e5:-1, 1:1e5, 0)
bench::mark(
tempfun1(i),
tempfun2(i)
)
i <- c(0, -1e5:-1, 1:1e5)
bench::mark(
tempfun1(i),
tempfun2(i)
)
i <- c(-1e5:-1, 1:1e5, 0)
bench::mark(
tempfun1(i),
tempfun2(i),
min_iterations = 1000
)
i <- c(0, -1e5:-1, 1:1e5)
bench::mark(
tempfun1(i),
tempfun2(i),
min_iterations = 1000
)
?stringi::stri_startswith
#' String-Search Functions To Complement the String-Related Infix Operators
#'
#' @description
#' These functions operate on string searches (regex, fixed, coll, charclass),
#' and support 2 types of workflows:
#'
#'  1) Either, operate on ALL found patterns.
#'  2) Or, locate  \eqn{i^{th}} pattern, operate on the located sub-string, and then return it.
#'
#' These functions use the \link{s_pattern} API rather than the 'stringi' API,
#' as they are meant to compliment the string-related infix operators from 'tinycodet'
#' (they are not meant to replace those operators). \cr
#' These functions call 'stringi' functions. \cr
#' \cr
#' The following functions are present: \cr
#'
#'  - \code{strloc_ith}: see \link{stri_locate_ith};
#'  forms the basis of the second workflow.
#'  - \code{strs_loc}: calls \link[stringi]{stri_locate_all}.
#'  - \code{strs_x}: calls \link[stringi]{stri_extract_all}.
#'  - \code{strs_vrp}: calls \link[stringi]{stri_replace_all}\code{(..., vectorize_all = TRUE)}.
#'  - \code{strs_dictrp}: calls \link[stringi]{stri_replace_all}\code{(..., vectorize_all = FALSE)}.
#'
#'
#' @param x a string or character vector.
#' @param p either a list with 'stringi' arguments (see \link{s_pattern}),
#' or else a character vector of the same length as \code{x} or a length of 1 with regular expressions. \cr
#' `r .mybadge_string("regex", "darkred")` \cr
#' `r .mybadge_string("fixed", "darkgreen")` \cr
#' `r .mybadge_string("coll", "pink")` \cr
#' `r .mybadge_string("charclass", "lightyellow")` \cr
#' @param rp a character vector giving the replacement values. \cr
#' Only relevant if argument `p` is a character vector. \cr
#' If argument `p` is a list, provide `rp` as part of that list.
#' @param ... additional arguments to be passed to the 'stringi' functions. \cr
#' Only relevant if argument `p` is a character vector. \cr
#' If argument `p` is a list, provide the additional arguments as part of that list.
#'
#'
#'
#' @returns
#' See the corresponding 'stringi'-functions
#'
#'
#' @seealso [tinycodet_strings()]
#'
#'
#' @examples
#'
#' # Workflow 1 Example ====
#'
#' x <- rep('The quick brown fox jumped over the lazy dog.', 3)
#' print(x)
#' p <- c('quick', 'brown', 'fox')
#' rp <- c('slow',  'black', 'bear')
#' strs_vrp(x, p, rp)
#' strs_dictrp(x, p, rp)
#'
#' print(x)
#' p <- s_fixed(
#'   c('QUICK', 'BROWN', 'FOX'),
#'   replacement = c('slow',  'black', 'bear'),
#'   case_insensitive = TRUE
#' )
#' strs_vrp(x, p)
#' strs_dictrp(x, p)
#'
#' #############################################################################
#'
#'
#' # Workflow 2 Example ====
#'
#' x <- c(paste0(letters[1:13], collapse=""), paste0(letters[14:26], collapse=""))
#' print(x)
#'
#' # report ith (second and second-last) vowel locations:
#' p <- s_regex( # vowels
#'   rep("A|E|I|O|U", 2),
#'   case_insensitive=TRUE
#' )
#' loc <- strloc_ith(x, c(2, -2), p)
#' print(loc)
#'
#' # extract ith vowels:
#' extr <- stringi::stri_sub(x, from=loc)
#' print(extr)
#'
#' # replace ith vowels with numbers:
#' repl <- chartr("aeiou", "12345", extr)
#' x <- stringi::stri_sub_replace(x, loc, replacement=repl)
#' print(x)
#'
#' @name stringsearch
#' @rdname stringsearch
#' @export
strloc_ith <- function(x, i, p, ...) {
if(is.list(p)){
args <- list(str = x, i = i)
return(do.call(stri_locate_ith, c(args, p)))
} else if(is.character(p)) {
return(stri_locate_ith(
x, i = i, regex = p, ...
))
} else {
stop("`p` must be a character vector or list")
}
}
#' @rdname stringsearch
#' @export
strs_loc <- function(x, p, ...) {
if(is.list(p)){
return(do.call(stringi::stri_locate_all, c(list(str = x), p)))
} else if(is.character(p)) {
return(stringi::stri_locate_all(
x, regex = p, ...
))
} else {
stop("`p` must be a character vector or list")
}
}
#' @rdname stringsearch
#' @export
strs_x <- function(x, p, ...) {
if(is.list(p)){
return(do.call(stringi::stri_extract_all, c(list(str = x), p)))
} else if(is.character(p)) {
return(stringi::stri_extract_all(
x, regex = p, ...
))
} else {
stop("`p` must be a character vector or list")
}
}
#' @rdname stringsearch
#' @export
strs_vrp <- function(x, p, rp, ...) {
if(is.list(p)){
args <- list(str = x, vectorize_all = TRUE)
return(do.call(stringi::stri_replace_all, c(args, p)))
} else if(is.character(p)) {
return(stringi::stri_replace_all(
x, replacement = rp, regex = p, vectorize_all = TRUE, ...
))
} else {
stop("`p` must be a character vector or list")
}
}
#' @rdname stringsearch
#' @export
strs_dictrp <- function(x, p, rp, ...) {
if(is.list(p)){
args <- list(str = x, vectorize_all = FALSE)
return(do.call(stringi::stri_replace_all, c(args, p)))
} else if(is.character(p)) {
return(stringi::stri_replace_all(
x, replacement = rp, regex = p, vectorize_all = FALSE, ...
))
} else {
stop("`p` must be a character vector or list")
}
}
library(tinycodet)
loadNamespace("stringr")
x <- sapply(1:1e5, \(x)paste(sample(letters), collapse = ""))
p <- sample(c("A", "E", 'I', "O", "U"), 1e5, TRUE)
rp <- sample(c("!", "@", "#", "$", "%", "^", "&", "*", "()"), 1e5, TRUE)
foo <- bench::mark(
stringi = stringi::stri_replace_all(x, rp, fixed = p, case_insensitive = TRUE),
stringr = stringr::str_replace_all(x, stringr::fixed(p, ignore_case = TRUE), replacement = rp),
tinycodet_docall = strs_vrp(x, s_fixed(p, case_insensitive = TRUE, replacement = rp)),
min_iterations = 500
)
ggplot2::autoplot(foo)
foo
x <- paste0(letters, collapse = "")
stringi::stri_locate_all(x, fixed = c("a", "e", "i", "o", "u"))
stringi::stri_locate_all(x, fixed = c("a", "e", "i", "o", "u"))
tinycodet::stri_locate_ith()
tinycodet::stri_locate_ith
?stringi::stri_locate_all_boundaries
stringi::stri_locate_all_boundaries("hello world", type = "word")
stringi::stri_locate_all("hello world", regex = "word")
stringi::stri_locate_all("hello world", regex = "world")
?collapse::rowbind()
?tinycodet::stri_locate_ith()
# rbind vs apply ====
x <- rep(c(paste0(letters[1:13], collapse=""), paste0(letters[14:26], collapse="")), 1e5)
locall <- stringi::stri_locate_all_regex(x, "a|e|i|o|u")
# rbind vs apply ====
x <- rep(c(paste0(letters[1:13], collapse=""), paste0(letters[14:26], collapse="")), 1e5)
pattern <- "a|e|i|o|u"
p1 <- stringi::stri_locate_all_regex(str = str, pattern = pattern,
omit_no_match = FALSE, get_length = FALSE, ...)
p1 <- stringi::stri_locate_all_regex(str = str, pattern = pattern,
omit_no_match = FALSE, get_length = FALSE)
p1 <- stringi::stri_locate_all_regex(str = x, pattern = pattern,
omit_no_match = FALSE, get_length = FALSE)
n.matches <- lengths(p1)/2
n.matches <- pmax(n.matches, 1)
neg <- which(i < 0)
pos <- which(i > 0)
i <- sample(1:5, length(x). TRUE)
i <- sample(1:5, length(x), TRUE)
n.matches <- lengths(p1)/2
n.matches <- pmax(n.matches, 1)
neg <- which(i < 0)
pos <- which(i > 0)
bad_i <- length(i) != (length(neg) + length(pos))
i[neg] <- pmax(n.matches[neg] - abs(i[neg] + 1), 1)
i[pos] <- pmin(i[pos], n.matches[pos])
rowind <- i + c(0, cumsum(n.matches))[seq_len(n)]
n <- length(x)
rowind <- i + c(0, cumsum(n.matches))[seq_len(n)]
bench::mark(
do.call(rbind, p1)
simplify2array(p1) |> apply(2, c)
bench::mark(
do.call(rbind, p1),
simplify2array(p1) |> apply(2, c)
)
simplify2array(p1)
?simplify2array
simplify2array(p1)
simplify2array(p1) |> apply(2, c)
x2 <- simplify2array(p1)
View(p1)
#' String-Search Functions To Complement the String-Related Infix Operators
#'
#' @description
#' These functions operate on string searches (regex, fixed, coll, charclass),
#' and support 2 types of workflows:
#'
#'  1) Either, operate on ALL found patterns.
#'  2) Or, locate \eqn{i^{th}} occurrence(s) of a pattern,
#'  operate on the located occurrence(s), and then return it.
#'
#' These functions use the \link{s_pattern} API rather than the 'stringi' API,
#' as they are meant to compliment the string-related infix operators from 'tinycodet'. \cr
#' These functions call 'stringi' functions. \cr
#' \cr
#' The following functions are present: \cr
#'
#'  - \code{strloc_ith}: see \link{stri_locate_ith};
#'  forms the basis of the second workflow.
#'  - \code{strloc_all}: see \link{stri_locate_all}.
#'  - \code{strs_x}: calls \link[stringi]{stri_extract_all}.
#'  - \code{strs_vrp}: calls \link[stringi]{stri_replace_all}\code{(..., vectorize_all = TRUE)}.
#'  - \code{strs_dictrp}: calls \link[stringi]{stri_replace_all}\code{(..., vectorize_all = FALSE)}.
#'
#'
#' @param x a string or character vector.
#' @param p either a list with 'stringi' arguments (see \link{s_pattern}),
#' or else a character vector of the same length as \code{x} or a length of 1 with regular expressions. \cr
#' `r .mybadge_string("regex", "darkred")` \cr
#' `r .mybadge_string("fixed", "darkgreen")` \cr
#' `r .mybadge_string("coll", "pink")` \cr
#' `r .mybadge_string("charclass", "lightyellow")` \cr
#' @param rp a character vector giving the replacement values. \cr
#' Only relevant if argument `p` is a character vector. \cr
#' If argument `p` is a list, provide `rp` as part of that list.
#' @param ... additional arguments to be passed to the 'stringi' functions. \cr
#' Only relevant if argument `p` is a character vector. \cr
#' If argument `p` is a list, provide the additional arguments as part of that list.
#'
#'
#'
#' @returns
#' See the corresponding 'stringi'-functions
#'
#'
#' @seealso [tinycodet_strings()]
#'
#'
#' @examples
#'
#'
#'
#'
#'
#'
stringi_create_shorter_functions <- function(pattern) {
lst <- list()
funnms_old <- c("locate", "extract", "replace", "count", "split")
funnms_new <- c("loc", "x", "rp", "count", "split")
locnms_old <- c("first", "last", "all", NULL)
locnms_new <- c("1", "n", "all", NULL)
pnms_old <- c("regex", "fixed", "coll", "charclass", "boundaries")
pnms_new <- c("regex", "fixed", "coll", "chrcls", "brk")
if(length(funnms_old) != length(funnms_new)) stop("wrong functions")
if(length(locnms_old) != length(locnms_new)) stop("wrong flocations")
if(length(pnms_old) != length(pnms_new)) stop("wrong patterns")
strinames <- getNamespaceExports(loadNamespace("stringi"))
for(iF in 1:length(funnms_old)) {
for(iL in 1:length(locnms_old)) {
for(iP in 1:length(pnms_old)) {
oldfun <- paste("stri", funnms_old[iF], locnms_old[iL], pnms_old[iP], collapse = "_", sep =  "_")
check <- oldfun %in% strinames
if(check) {
newfun <- paste(pnms_new[iP], funnms_new[iF], locnms_new[iL], collapse = "_", sep =  "_")
lst[[newfun]] <- eval(parse(text = paste0("stringi::", oldfun)))
}
}
}
}
lst$opts_regex <- stringi::stri_opts_regex
lst$opts_fixed <- stringi::stri_opts_fixed
lst$opts_coll <- stringi::stri_opts_collator
lst$opts_brk <- stringi::stri_opts_brkiter
lst <- as.environment(lst)
lockEnvironment(lst, bindings = TRUE)
return(lst)
}
stringi2 <- stringi_create_shorter_functions()
attach(stringi2)
opts <- opts_regex(case_insensitive = TRUE)
regex_loc_1("hello", "lo", opts_regex = opts)
View(stringi2)
View(stringi2)
strinames <- getNamespaceExports(loadNamespace("stringi"))
strinames
library(tinycodet)
strinames_nonsearch <- strinames[strinames %s!{}% "regex|fixed|coll|charclass|boundaries"]
strinames_nonsearch
strinames_nonsearch <- strinames[strinames %s!{}% "regex|fixed|coll|charclass|boundaries|%"]
strinames_nonsearch
strinames_nonsearch <- strinames[strinames %s!{}% "regex|fixed|coll|charclass|boundaries|locate|extract|replace|count|split|%"]
strinames_nonsearch
?stringfish::sf_match
nms <- rep(letters, 2)
idx <- c("a", "a")
sf <- loadNamespace("stringfish")
sf$sf_match(idx, nms)
sf$sf_match(nms, idx)
nms <- sample(letters, 1e5, TRUE)
idx <- rep(letters, 2)
sf$sf_match(nms, idx) |> which()
sf$sf_match(nms, idx)
nms <- rep(letters, 2)
idx <- c("a", "a")
sf$sf_match(nms, idx)
sf$sf_match(idx, nms)
sf$sf_match(nms, "b")
sf$sf_match(nms, "b") |> as.logical()
sf$sf_match(nms, "b") |> as.logical() |> which()
sf$sf_match(nms, c("b", "b")) |> as.logical() |> which()
lapply(idx, \(i) stringi::stri_subset_fixed(nms, i)) |> unlist()
library(tinycodet)
help.import(i = sf$string_identical)
import_as(~ sf, "stringfish")
help.import(i = sf$string_identical)
setwd("D:/D Desktop/Publications/R package tinycodet/tinycodet/vignettes/articles")
library(tinycodet)
library(ggplot2)
mat <- matrix(1:(5e3)^2, ncol = 5e3)
bm.matorder <- bench::mark(
tinycodet = {mat %row~% mat; mat %col~% mat},
Rfast = {Rfast::rowSort(mat); Rfast::colSort(mat)},
min_iterations = 500
)
bm.matorder
autoplot(bm.matorder)
# [seq_len(n)] vs [-1]
n <- 1e6
i <- sample(c(-10:-1, 1:10), n, TRUE)
# [seq_len(n)] vs [-1]
n <- 1e6
i <- sample(c(-10:-1, 1:10), n, TRUE)
bench::mark(
i + c(0, collapse::fcumsum.default(n.matches))[seq_len(n)],
i + c(0, collapse::fcumsum.default(n.matches)[-1]),
min_iterations = 100
)
n.matches <- sample(1:10, n, TRUE)
bench::mark(
i + c(0, collapse::fcumsum.default(n.matches))[seq_len(n)],
i + c(0, collapse::fcumsum.default(n.matches)[-1]),
min_iterations = 100
)
i + c(0, collapse::fcumsum.default(n.matches)[-1])
all(
c(0, collapse::fcumsum.default(n.matches))[seq_len(n)]) ==
c(0, collapse::fcumsum.default(n.matches)[-1])
c(0, collapse::fcumsum.default(n.matches))[seq_len(n)])
all(
c(0, collapse::fcumsum.default(n.matches))[seq_len(n)] ==
c(0, collapse::fcumsum.default(n.matches)[-1])
)
# [seq_len(n)] vs [-1]
n <- 2
i <- sample(c(-10:-1, 1:10), n, TRUE)
n.matches <- sample(1:10, n, TRUE)
all(
c(0, collapse::fcumsum.default(n.matches))[seq_len(n)] ==
c(0, collapse::fcumsum.default(n.matches)[-1])
)
c(0, collapse::fcumsum.default(n.matches))[seq_len(n)]
seq_len(n)
collapse::fcumsum.default(n.matches)
c(0, collapse::fcumsum.default(n.matches)[-1])
collapse::fcumsum.default(n.matches)[-1]
collapse::fcumsum.default(n.matches)
collapse::fcumsum.default(n.matches)[-1]
collapse::fcumsum.default(n.matches)[1]
1:10[-1]
(1:10)[-1]
all(
c(0, collapse::fcumsum.default(n.matches))[seq_len(n)] ==
c(0, collapse::fcumsum.default(n.matches)[-n])
)
# [seq_len(n)] vs [-1]
n <- 1e6
i <- sample(c(-10:-1, 1:10), n, TRUE)
n.matches <- sample(1:10, n, TRUE)
all(
c(0, collapse::fcumsum.default(n.matches))[seq_len(n)] ==
c(0, collapse::fcumsum.default(n.matches)[-n])
)
bench::mark(
i + c(0, collapse::fcumsum.default(n.matches))[seq_len(n)],
i + c(0, collapse::fcumsum.default(n.matches)[-1]),
min_iterations = 100
)
bench::mark(
i + c(0, collapse::fcumsum.default(n.matches))[seq_len(n)],
i + c(0, collapse::fcumsum.default(n.matches)[-n]),
min_iterations = 100
)
# [seq_len(n)] vs [-1]
n <- 1e6
i <- sample(c(-10:-1, 1:10), n, TRUE)
n.matches <- sample(1:10, n, TRUE)
all(
c(0, collapse::fcumsum.default(n.matches))[seq_len(n)] ==
c(0, collapse::fcumsum.default(n.matches)[-n])
)
bench::mark(
i + c(0, collapse::fcumsum.default(n.matches))[seq_len(n)],
i + c(0, collapse::fcumsum.default(n.matches)[-n]),
min_iterations = 100
)
all(
(i + c(0, collapse::fcumsum.default(n.matches))[seq_len(n)]) ==
(i + c(0, collapse::fcumsum.default(n.matches)[-n]))
)
bench::mark(
c(0, collapse::fcumsum.default(n.matches))[seq_len(n)],
c(0, collapse::fcumsum.default(n.matches)[-n]),
min_iterations = 100
)
setwd("D:/D Desktop/Publications/R package tinycodet/tinycodet/vignettes/articles")
library(tinycodet)
library(ggplot2)
n <- 1e5
x <- rep(paste0(1:50, collapse = ""), n)
p <- "\\d"
i <- sample(c(-50:-1, 1:50), replace=TRUE, size = n)
locate_stringi <- function(...) {
stringi::stri_locate_all(...)
stringi::stri_count(...)
}
bm.stri_locate_ith <- bench::mark(
"stri_locate_ith" = { stri_locate_ith_regex(x, p, i) },
"stringi::(stri_locate_all + stri_count)" = { locate_stringi(str=x, regex = p) },
min_iterations = 500,
check = FALSE,
filter_gc = FALSE
)
