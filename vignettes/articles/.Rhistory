# error handling:
check_dims <- dim(x)[-margin] == dim(y)[-margin]
if(!all(check_dims)) {
stop(simpleError("incompatible dimensions", call = abortcall))
}
# creating list to be filled ( "filler" )
new_dims <- dim(x)
new_dims[margin] <- dim(x)[margin] + dim(y)[margin]
new_len <- prod(new_dims)
new_ndim <- length(new_dims)
filler <- array(seq_len(new_len), dim = new_dims)
# fill filler with x:
dim_args1 <- squarebrackets:::.rcpp_seq_mlen(dim(x))
elements <- sub2ind(dim_args1, new_dims, checks = FALSE)
collapse::setv(filler, elements, x, vind1 = TRUE, xlist = FALSE)
# fill filler with y:
dim_args2 <- squarebrackets:::.rcpp_seq_mlen(new_dims)
rem_margin <- seq_len(dim(x)[margin])
dim_args2[[margin]] <- dim_args2[[margin]][-rem_margin]
elements <- sub2ind(dim_args2, new_dims, checks = FALSE)
collapse::setv(filler, elements, y, vind1 = TRUE, xlist = FALSE)
# return filler:
return(filler)
}
# perform abind2 tests ====
enumerate <- 0
for(margin in 1:3) {
dims <- c(4,4,4)
dims[margin] <- 1
ya <- array(1:64, c(4,4,4))
yl <- array(as.list(1:64), c(4,4,4))
newa <- array(1:16, dim = dims)
newl <- array(as.list(1:16), dim = dims)
out <- abind2(list(yl, newl, yl), margin)
expected <- array(as.list(abind(ya, newa, ya, along = margin)), dim = dim(out))
expect_equivalent(
out, expected
) |> errorfun()
enumerate <- enumerate + 1
}
# perform sb2_before/after tests ====
enumerate <- 0
for(margin in 1:3) {
dims <- c(4,4,4)
dims[margin] <- 1
ya <- array(1:64, c(4,4,4))
yl <- array(as.list(1:64), c(4,4,4))
newa <- array(1:16, dim = dims)
newl <- array(as.list(1:16), dim = dims)
out <- sb2_after.array(yl, newl, margin)
expected <- array(as.list(abind(ya, newa, along = margin)), dim = dim(out))
expect_equivalent(
out, expected
) |> errorfun()
out <- sb2_before(yl, newl, margin)
expected <- array(as.list(abind(newa, ya, along = margin)), dim = dim(out))
expect_equivalent(
out, expected
) |> errorfun()
out <- sb2_before(yl, newl, margin, 4)
expected <- abind(
asub(ya, 1:3, dims = margin),
newa,
asub(ya, 4:dim(ya)[margin], dims = margin), along = margin
)
expected <- array(as.list(expected), dim = dim(out))
expect_equivalent(
out, expected
) |> errorfun()
out <- sb2_after(yl, newl, margin, 2)
expected <- abind(
asub(ya, 1:2, dims = margin),
newa,
asub(ya, 3:dim(ya)[margin], dims = margin), along = margin
)
expected <- array(as.list(expected), dim = dim(out))
expect_equivalent(
out, expected
) |> errorfun()
enumerate <- enumerate + 4
}
x <- array(as.list(sample(letters, 50e3, TRUE)), dim = c(100, 50, 100))
y <- array(as.list(-40:-1), dim = c(100, 50, 75))
out <- abind.recursive(asub(x, 1:2, 3), y, 3, method = 2)
abind.recursive(out, asub(x, 3:4, 3), 3, method = 2)
out <- abind2(list(x, y, x), along = 3)
# foo <- bench::mark(
#   method1 = abind.recursive(x, y, 3, method = 1), # method 1 is faster, and uses less gc calls
#   method2 = abind.recursive(x, y, 3, method = 2), # method 2 uses very slightly less memory, but the difference is negligible
#   abind2 = abind2(list(x, y), along = 3),
#   check = FALSE,
#   min_iterations = 250
# )
# foo
# ggplot2::autoplot(foo)
#
x <- array(1:1e5, dim = c(100,10, 100))
y <- array(-1e5:-1, dim =c(100,10, 100))
# foo <- bench::mark(
#   method1 = abind.recursive(x, y, 3, method = 1), # method 1 is faster, and uses less gc calls
#   method2 = abind.recursive(x, y, 3, method = 2), # method 2 uses very slightly less memory, but the difference is negligible
#   abind2 = abind2(list(x, y), along = 3),
#   check = FALSE,
#   min_iterations = 250
# )
# foo
# ggplot2::autoplot(foo)
#
x <- array(1:1e5, dim = c(100,10, 100))
y <- array(-1e5:-1, dim =c(100,10, 100))
# NOTE: squarebrackets needs to be properly installed,
# otherwise speed comparisons will WILDLY off
foo <- bench::mark(
abind::abind(x, y, x, along = 3),
abind.recursive(x, y, 3),
check = FALSE,
min_iterations = 250
)
# NOTE: squarebrackets needs to be properly installed,
# otherwise speed comparisons will WILDLY off
foo <- bench::mark(
abind::abind(x, y, x, along = 3),
abind.recursive(list(x, y), 3),
check = FALSE,
min_iterations = 250
)
foo
ggplot2::autoplot(foo)
# foo <- bench::mark(
#   method1 = abind.recursive(x, y, 3, method = 1), # method 1 is faster, and uses less gc calls
#   method2 = abind.recursive(x, y, 3, method = 2), # method 2 uses very slightly less memory, but the difference is negligible
#   abind2 = abind2(list(x, y), along = 3),
#   check = FALSE,
#   min_iterations = 250
# )
# foo
# ggplot2::autoplot(foo)
#
x <- array(1:1e5, dim = c(100,10, 100))
y <- array(-1e5:-1, dim =c(100,10, 100))
# NOTE: squarebrackets needs to be properly installed,
# otherwise speed comparisons will WILDLY off
foo <- bench::mark(
abind::abind(x, y, x, along = 3),
abind.recursive(list(x, y, x), 3),
check = FALSE,
min_iterations = 250
)
foo
ggplot2::autoplot(foo)
# NOTE: squarebrackets needs to be properly installed,
# otherwise speed comparisons will WILDLY off
foo <- bench::mark(
abind::abind(x, y, x, along = 3),
abind.recursive(list(x, y, x), 3), # about as fast as abind::abind
check = FALSE,
min_iterations = 250
)
foo
library(squarebrackets)
# abind vs abind.recursive ====
.abind.recursive <- squarebrackets:::.abind.recursive
x <- array(as.list(1:10), dim = c(5,2))
y <- array(as.list(letters[1:20]), dim = c(5,4))
colnames(x) <- c("a", "b")
colnames(y) <- c("a", "b", "c", "d")
.abind.recursive(list(x,y))
abind::abind(list(x,y))
x <- array(1:1e5, dim = c(100,10, 100))
y <- array(-1e5:-1, dim =c(100,10, 100))
# NOTE: squarebrackets needs to be properly installed,
# otherwise speed comparisons will WILDLY off
foo <- bench::mark(
abind::abind(x, y, x, along = 3),
.abind.recursive(list(x, y, x), 3), # about as fast as abind::abind (slightly faster even)
min_iterations = 250
)
foo
ggplot2::autoplot(foo)
x <- array(1:1e6, dim = c(100, 100, 100))
y <- array(-1e6:-1, dim =c(100, 100, 100))
# NOTE: squarebrackets needs to be properly installed,
# otherwise speed comparisons will WILDLY off
foo <- bench::mark(
abind::abind(x, y, x, along = 3),
.abind.recursive(list(x, y, x), 3), # about as fast as abind::abind (slightly faster even)
min_iterations = 250
)
foo
ggplot2::autoplot(foo)
x <- array(1:1e5, dim = c(100, 10, 100))
y <- array(-1e5:-1, dim =c(100, 10, 100))
# NOTE: squarebrackets needs to be properly installed,
# otherwise speed comparisons will WILDLY off
foo <- bench::mark(
abind::abind(x, y, x, along = 3),
.abind.recursive(list(x, y, x), 3), # about as fast as abind::abind (slightly faster even)
min_iterations = 250
)
foo
ggplot2::autoplot(foo)
# NOTE: squarebrackets needs to be properly installed,
# otherwise speed comparisons will WILDLY off
foo <- bench::mark(
abind::abind(x, y, x, along = 3),
.abind.recursive(list(x, y, x), 3), # about as fast as abind::abind (slightly faster even)
min_iterations = 250
)
foo
ggplot2::autoplot(foo)
?getOption
?magrittr::extract
magrittr::inset
?data.table::setDT
data.table::setDF
library(tibble)
`[[.tibble`
methods("[[")
methods(class = "tbl_df")
?tbl_df
`[[.list`
`[[`
`[[.data.frame`
`[[<-.data.frame`
methods("[[<-")
`[[<-.data.frame`
`[[<-.tbl_df`
methods()
?methods()
?getS3method
getS3method("[[<-", "tbl_df")
?data.table
getS3method("[[<-", "tbl_df")
library(tibble)
getS3method("[[<-", "tbl_df")
tibble:::tbl_subassign
tibble:::vectbl_restore
tibble:::vectbl_as_col_subscript
tibble:::vectbl_assign
tibble:::vectbl_assign
vctrs::vec_assign
?vctrs::vec_assign
?vctrs::`vec_slice<-`
vctrs::`vec_slice<-`
?delayedAssign
x <- 1:10
vctrs::vec_assign(x, 1:2, -1:-2)
x
library(vctrs)
x
vec_slice(x, 1:2) <- -1:-2
x
library(collections)
?collections::dict
d <- dict(list(apple = 5, orange = 10))
d
d$set <- NULL
d$set
d <- dict(list(apple = 5, orange = 10))
lockEnvironment(d, bindings = TRUE)
d
d$set <- NULL
d$set("banana", 3)
rm(d)
d <- dict(list(apple = 5, orange = 10))
lockBinding("set", d)
d$set <- NULL
d$set("banana", 3)
d
d <- dict(list(apple = 5, orange = 10))
d$set <- NULL
> d$set
d <- dict(list(apple = 5, orange = 10))
d$set <- NULL
d$set
d <- dict(list(apple = 5, orange = 10))
lockBinding("set", d)
d$set <- NULL
d$set("banana", 3)
d$set
125/3
40/8*3
40*8
125/0.4
library(tinycodet)
loadNamespace("bench")
loadNamespace("ggplot2")
n <- 1e5
x <- rep(paste0(1:50, collapse = ""), n)
p <- "\\d"
i <- sample(c(-50:-1, 1:50), replace=TRUE, size = n)
locate_stringi <- function(...) {
stringi::stri_locate_all(...)
stringi::stri_count(...)
}
bm.stri_locate_ith <- bench::mark(
"stri_locate_ith" = { stri_locate_ith_regex(x, p, i) },
"stringi::(stri_locate_all + stri_count)" = { locate_stringi(str=x, regex = p) },
min_iterations = 500,
check = FALSE
)
ggplot2::autoplot(bm.stri_locate_ith)
bm.stri_locate_ith
Rcpp::cppFunction(
"
IntegerVector rcpp_convert_i(IntegerVector n_matches, IntegerVector i) {
int n = i.length();
IntegerVector out(n);
int res = 0;
for(int j = 0; j < n; ++j) {
if(IntegerVector::is_na(i[j])) {
stop(\"i is not allowed to be 0 or NA\");
}
else if(i[j] < 0) {
res = n_matches[j] - abs(i[j] + 1);
if(res < 1) {
out[j] = 1;
} else {
out[j] = res;
}
}
else if(i[j] > 0) {
if(i[j] < n_matches[j]) {
out[j] = i[j];
} else {
out[j] = n_matches[j];
}
}
else {
stop(\"i is not allowed to be 0 or NA\");
}
}
return out;
}
"
)
Rcpp::cppFunction(
"
IntegerVector rcpp_convert_neg_i(IntegerVector n_matches, IntegerVector i) {
int n = i.length();
IntegerVector out(n);
int res = 0;
for(int j = 0; j < n; ++j) {
res = n_matches[j] - abs(i[j] + 1);
if(res < 1) {
out[j] = 1;
} else {
out[j] = res;
}
}
return out;
}
"
)
Rcpp::cppFunction(
"
IntegerVector rcpp_convert_pos_i(IntegerVector n_matches, IntegerVector i) {
int n = i.length();
IntegerVector out(n);
for(int j = 0; j < n; ++j) {
if(i[j] < n_matches[j]) {
out[j] = i[j];
} else {
out[j] = n_matches[j];
}
}
return out;
}
"
)
rcpp_old <- function(n.matches, i) {
i <- as.integer(i)
neg <- which(i < 0)
pos <- which(i > 0)
bad_i <- length(i) != (length(neg) + length(pos))
if(bad_i){
stop("`i` is not allowed to be zero or NA")
}
i[neg] <- rcpp_convert_neg_i(n.matches[neg], i[neg])
i[pos] <- rcpp_convert_pos_i(n.matches[pos], i[pos])
return(i)
}
rcpp_convert_i(n.matches, rep(0, length(n.matches)))
i <- sample(c(-50:-1, 1:50), 5e5, TRUE)
n.matches <- sample(0:50, 5e5, TRUE)
rcpp_convert_i(n.matches, rep(0, length(n.matches)))
rcpp_convert_i(n.matches, rep(NA, length(n.matches)))
rcpp_convert_i(n.matches, rep(NaN, length(n.matches)))
rcpp_convert_i(n.matches, rep(Inf, length(n.matches)))
rcpp_convert_i(n.matches, rep(-Inf, length(n.matches)))
foo <- bench::mark(
rcpp_old = rcpp_old(n.matches, i),
rcpp_new = rcpp_convert_i(n.matches, i),
min_iterations = 500
)
foo
ggplot2::autoplot(foo)
i <- sample(c(-50:-1, 1:50))
i <- sample(c(-50:-1, 1:50))
n.matches <- sample(0:50, length(i), TRUE)
foo <- bench::mark(
rcpp_old = for(j in 1:10000) rcpp_old(n.matches, i),
rcpp_new = for(j in 1:10000) rcpp_convert_i(n.matches, i),
min_iterations = 500
)
foo
ggplot2::autoplot(foo)
?transform_if
x <- c(-1e5:1e5, NA, NA)
x <- c(-1e6:1e6, NA, NA)
object <- matrix(x, ncol = 2)
x <- c(-1e6:1e6, NA, NaN, 0)
object <- matrix(x, ncol = 2)
attr(object, "helloworld") <- "helloworld"
print(object)
y <- 0
z <- 1000
x <- c(-1e6:1e6, NA, NaN, 0)
object <- matrix(x, ncol = 2)
attr(object, "helloworld") <- "helloworld"
y <- 0
z <- 1000
bm.transform_if <- bench::mark(
transform_if = object |> transform_if(object > y, log, \(x) x^2, -z),
ifelse = ifelse(is.na(object), z, ifelse(object > y, log(object), object^2)),
min_iterations = 250
)
x <- c(-10:10, NA, NaN, 0)
object <- matrix(x, ncol = 2)
attr(object, "helloworld") <- "helloworld"
y <- 0
z <- 1000
object |> transform_if(object > y, log, \(x) x^2, -z)
ifelse(is.na(object), z, ifelse(object > y, log(object), object^2))
bm.transform_if <- bench::mark(
transform_if = object |> transform_if(object > y, log, \(x) x^2, -z),
ifelse = ifelse(is.na(object), -z, ifelse(object > y, log(object), object^2)),
min_iterations = 250
)
object |> transform_if(object > y, log, \(x) x^2, -z)
ifelse(is.na(object), -z, ifelse(object > y, log(object), object^2))
bm.transform_if <- bench::mark(
transform_if = object |> transform_if(object > y, log, \(x) x^2, -z),
ifelse = ifelse(is.na(object), -z, ifelse(object > y, log(object), object^2)),
min_iterations = 250,
check = FALSE
)
x <- c(-1e5:1e5, NA, NaN, 0)
object <- matrix(x, ncol = 2)
attr(object, "helloworld") <- "helloworld"
y <- 0
z <- 1000
bm.transform_if <- bench::mark(
transform_if = object |> transform_if(object > y, log, \(x) x^2, -z),
ifelse = ifelse(is.na(object), -z, ifelse(object > y, log(object), object^2)),
min_iterations = 250,
check = FALSE
)
summary(bm.transform_if)
ggplot2::autoplot(bm.transform_if)
x <- sapply(1:1e6, paste(sample(letters), collapse = ""))
x <- sapply(1:1e6, \(x) paste(sample(letters), collapse = ""))
x <- sapply(1:1e5, \(x) paste(sample(letters), collapse = ""))
library(tinycodet)
x <- sapply(1:10, \(x) paste(sample(letters), collapse = ""))
p = "a|e|i|o|u"
x <- sapply(1:10, \(x) paste(sample(letters), collapse = ""))
p = "a|e|i|o|u"
foo <- bench::mark(
tinycodet = for(i in 1:1000) strfind(x, p, i = "last"),
stringi = stringi::stri_locate(x, regex = p, mode = "last"),
min_iterations = 500
)
strfind(x, p, i = "last")
stringi::stri_locate(x, regex = p, mode = "last")
foo <- bench::mark(
tinycodet = for(i in 1:1000) strfind(x, p, i = "last"),
stringi = for(i in 1:1000) stringi::stri_locate(x, regex = p, mode = "last"),
min_iterations = 500
)
foo
ggplot2::autoplot(foo)
x <- sapply(1:10, \(x) paste(sample(letters), collapse = ""))
p = s_fixed("a", case_insensitive = TRUE)
x <- sapply(1:10, \(x) paste(sample(letters), collapse = ""))
p = s_fixed("a", case_insensitive = TRUE)
foo <- bench::mark(
tinycodet = for(i in 1:1000) strfind(x, p, i = "last"),
stringi = for(i in 1:1000) stringi::stri_locate(
x, fixed = p, mode = "last", case_insensitive = TRUE
),
min_iterations = 500
)
foo
ggplot2::autoplot(foo)
setwd("D:/D Desktop/Publications/R package tinycodet/tinycodet/vignettes/articles")
library(tinycodet)
library(ggplot2)
loadNamespace("bench")
n <- 1e4
x <- rep(paste0(1:50, collapse = ""), n)
p <- "\\d"
bm.stri_locate_last <- bench::mark(
"stri_locate_ith" = stri_locate_ith_regex(x, p, -1),
"stringi::stri_locate_last" = stringi::stri_locate_last(x, regex = p),
min_iterations = 500,
check = FALSE,
filter_gc = FALSE
)
summary(bm.stri_locate_ith)
summary(bm.stri_locate_last)
autoplot(bm.stri_locate_last)
