tinycodet::stri_locate_ith()
tinycodet::stri_locate_ith
?stringi::stri_locate_all_boundaries
stringi::stri_locate_all_boundaries("hello world", type = "word")
stringi::stri_locate_all("hello world", regex = "word")
stringi::stri_locate_all("hello world", regex = "world")
?collapse::rowbind()
?tinycodet::stri_locate_ith()
# rbind vs apply ====
x <- rep(c(paste0(letters[1:13], collapse=""), paste0(letters[14:26], collapse="")), 1e5)
locall <- stringi::stri_locate_all_regex(x, "a|e|i|o|u")
# rbind vs apply ====
x <- rep(c(paste0(letters[1:13], collapse=""), paste0(letters[14:26], collapse="")), 1e5)
pattern <- "a|e|i|o|u"
p1 <- stringi::stri_locate_all_regex(str = str, pattern = pattern,
omit_no_match = FALSE, get_length = FALSE, ...)
p1 <- stringi::stri_locate_all_regex(str = str, pattern = pattern,
omit_no_match = FALSE, get_length = FALSE)
p1 <- stringi::stri_locate_all_regex(str = x, pattern = pattern,
omit_no_match = FALSE, get_length = FALSE)
n.matches <- lengths(p1)/2
n.matches <- pmax(n.matches, 1)
neg <- which(i < 0)
pos <- which(i > 0)
i <- sample(1:5, length(x). TRUE)
i <- sample(1:5, length(x), TRUE)
n.matches <- lengths(p1)/2
n.matches <- pmax(n.matches, 1)
neg <- which(i < 0)
pos <- which(i > 0)
bad_i <- length(i) != (length(neg) + length(pos))
i[neg] <- pmax(n.matches[neg] - abs(i[neg] + 1), 1)
i[pos] <- pmin(i[pos], n.matches[pos])
rowind <- i + c(0, cumsum(n.matches))[seq_len(n)]
n <- length(x)
rowind <- i + c(0, cumsum(n.matches))[seq_len(n)]
bench::mark(
do.call(rbind, p1)
simplify2array(p1) |> apply(2, c)
bench::mark(
do.call(rbind, p1),
simplify2array(p1) |> apply(2, c)
)
simplify2array(p1)
?simplify2array
simplify2array(p1)
simplify2array(p1) |> apply(2, c)
x2 <- simplify2array(p1)
View(p1)
#' String-Search Functions To Complement the String-Related Infix Operators
#'
#' @description
#' These functions operate on string searches (regex, fixed, coll, charclass),
#' and support 2 types of workflows:
#'
#'  1) Either, operate on ALL found patterns.
#'  2) Or, locate \eqn{i^{th}} occurrence(s) of a pattern,
#'  operate on the located occurrence(s), and then return it.
#'
#' These functions use the \link{s_pattern} API rather than the 'stringi' API,
#' as they are meant to compliment the string-related infix operators from 'tinycodet'. \cr
#' These functions call 'stringi' functions. \cr
#' \cr
#' The following functions are present: \cr
#'
#'  - \code{strloc_ith}: see \link{stri_locate_ith};
#'  forms the basis of the second workflow.
#'  - \code{strloc_all}: see \link{stri_locate_all}.
#'  - \code{strs_x}: calls \link[stringi]{stri_extract_all}.
#'  - \code{strs_vrp}: calls \link[stringi]{stri_replace_all}\code{(..., vectorize_all = TRUE)}.
#'  - \code{strs_dictrp}: calls \link[stringi]{stri_replace_all}\code{(..., vectorize_all = FALSE)}.
#'
#'
#' @param x a string or character vector.
#' @param p either a list with 'stringi' arguments (see \link{s_pattern}),
#' or else a character vector of the same length as \code{x} or a length of 1 with regular expressions. \cr
#' `r .mybadge_string("regex", "darkred")` \cr
#' `r .mybadge_string("fixed", "darkgreen")` \cr
#' `r .mybadge_string("coll", "pink")` \cr
#' `r .mybadge_string("charclass", "lightyellow")` \cr
#' @param rp a character vector giving the replacement values. \cr
#' Only relevant if argument `p` is a character vector. \cr
#' If argument `p` is a list, provide `rp` as part of that list.
#' @param ... additional arguments to be passed to the 'stringi' functions. \cr
#' Only relevant if argument `p` is a character vector. \cr
#' If argument `p` is a list, provide the additional arguments as part of that list.
#'
#'
#'
#' @returns
#' See the corresponding 'stringi'-functions
#'
#'
#' @seealso [tinycodet_strings()]
#'
#'
#' @examples
#'
#'
#'
#'
#'
#'
stringi_create_shorter_functions <- function(pattern) {
lst <- list()
funnms_old <- c("locate", "extract", "replace", "count", "split")
funnms_new <- c("loc", "x", "rp", "count", "split")
locnms_old <- c("first", "last", "all", NULL)
locnms_new <- c("1", "n", "all", NULL)
pnms_old <- c("regex", "fixed", "coll", "charclass", "boundaries")
pnms_new <- c("regex", "fixed", "coll", "chrcls", "brk")
if(length(funnms_old) != length(funnms_new)) stop("wrong functions")
if(length(locnms_old) != length(locnms_new)) stop("wrong flocations")
if(length(pnms_old) != length(pnms_new)) stop("wrong patterns")
strinames <- getNamespaceExports(loadNamespace("stringi"))
for(iF in 1:length(funnms_old)) {
for(iL in 1:length(locnms_old)) {
for(iP in 1:length(pnms_old)) {
oldfun <- paste("stri", funnms_old[iF], locnms_old[iL], pnms_old[iP], collapse = "_", sep =  "_")
check <- oldfun %in% strinames
if(check) {
newfun <- paste(pnms_new[iP], funnms_new[iF], locnms_new[iL], collapse = "_", sep =  "_")
lst[[newfun]] <- eval(parse(text = paste0("stringi::", oldfun)))
}
}
}
}
lst$opts_regex <- stringi::stri_opts_regex
lst$opts_fixed <- stringi::stri_opts_fixed
lst$opts_coll <- stringi::stri_opts_collator
lst$opts_brk <- stringi::stri_opts_brkiter
lst <- as.environment(lst)
lockEnvironment(lst, bindings = TRUE)
return(lst)
}
stringi2 <- stringi_create_shorter_functions()
attach(stringi2)
opts <- opts_regex(case_insensitive = TRUE)
regex_loc_1("hello", "lo", opts_regex = opts)
View(stringi2)
View(stringi2)
strinames <- getNamespaceExports(loadNamespace("stringi"))
strinames
library(tinycodet)
strinames_nonsearch <- strinames[strinames %s!{}% "regex|fixed|coll|charclass|boundaries"]
strinames_nonsearch
strinames_nonsearch <- strinames[strinames %s!{}% "regex|fixed|coll|charclass|boundaries|%"]
strinames_nonsearch
strinames_nonsearch <- strinames[strinames %s!{}% "regex|fixed|coll|charclass|boundaries|locate|extract|replace|count|split|%"]
strinames_nonsearch
?stringfish::sf_match
nms <- rep(letters, 2)
idx <- c("a", "a")
sf <- loadNamespace("stringfish")
sf$sf_match(idx, nms)
sf$sf_match(nms, idx)
nms <- sample(letters, 1e5, TRUE)
idx <- rep(letters, 2)
sf$sf_match(nms, idx) |> which()
sf$sf_match(nms, idx)
nms <- rep(letters, 2)
idx <- c("a", "a")
sf$sf_match(nms, idx)
sf$sf_match(idx, nms)
sf$sf_match(nms, "b")
sf$sf_match(nms, "b") |> as.logical()
sf$sf_match(nms, "b") |> as.logical() |> which()
sf$sf_match(nms, c("b", "b")) |> as.logical() |> which()
lapply(idx, \(i) stringi::stri_subset_fixed(nms, i)) |> unlist()
library(tinycodet)
help.import(i = sf$string_identical)
import_as(~ sf, "stringfish")
help.import(i = sf$string_identical)
x <- c(paste0(letters[1:13], collapse=""), paste0(letters[14:26], collapse=""))
print(x)
strfind(x, "abc", i=1)
#' 'stringi' Pattern Search Operators
#'
#' @description
#'
#' The \code{x %s{}% p} operator
#' checks for every string in character vector \code{x} if
#' the pattern defined in \code{p} is present. \cr
#' \cr
#' The \code{x %s!{}% p} operator
#' checks for every string in character vector \code{x} if
#' the pattern defined in \code{p} is NOT present. \cr
#' \cr
#' For string (in)equality operators, see \link[stringi]{%s==%} from the 'stringi' package. \cr
#' \cr
#' The \code{strfind()<-} method,
#' although technically not an operator,
#' is meant to complement the string-related infix operators,
#' and therefore uses the same \link{s_pattern} API as (for example)
#' the \code{%s{}% and %s!{}%} operators. \cr
#' It functions as follows:
#'  * \code{strfind()} attempts to find all pattern matches,
#' and returns the extractions of the findings in a list,
#' just like \link[stringi]{stri_extract_all}.
#'  * \code{strfind(..., i = "all")} attempts to find all pattern matches,
#' and reports the locations of the findings in a list,
#' just like \link[stringi]{stri_locate_all}.
#'  * \code{strfind(..., i = i)}, where \code{i} is a non-zero integer,
#' locates the \eqn{i^{th}} occurrence of a pattern,
#' and reports the locations in a matrix,
#' just like \link{stri_locate_ith}.
#'  * \code{strfind(...) <- value} attempts to find all pattern matches,
#' and replaces them with the character vector specified in \code{value}. \cr
#' This is similar to \link[stringi]{stri_replace_all},
#' except the replacement is done in-place
#' (though not by reference, technically speaking). \cr \cr
#'
#'
#'
#' @param x a string or character vector.
#' @param p either a list with 'stringi' arguments (see \link{s_pattern}),
#' or else a character vector of the same length as \code{x} or length 1
#' with regular expressions. \cr
#' `r .mybadge_string("regex", "darkred")` \cr
#' `r .mybadge_string("fixed", "darkgreen")` \cr
#' `r .mybadge_string("coll", "pink")` \cr
#' `r .mybadge_string("charclass", "lightyellow")` \cr
#' @param i either one of the following:
#'  * if \code{i} is not given or \code{NULL},
#'  \code{strfind()} extracts all found pattern occurrences.
#'  * if \code{i = "all"}, \code{strfind()} locates all found pattern occurrences.
#'  * if \code{i} is an integer,
#'  \code{strfind()} locates the \eqn{i^{th}} pattern occurrences. \cr
#'  See the `i` argument in \link{stri_locate_ith} for details.
#'  * for \code{strfind() <- value}, `i` must not be specified.
#' @param value a character vector giving the replacement values.
#' @param ... additional arguments to be passed to the 'stringi' functions. \cr \cr
#'
#'
#'
#' @returns
#' The \code{x %s{}% p} and \code{x %s!{}% p} operators
#' return logical vectors. \cr
#' \cr
#' \code{strfind()} returns a list with extractions of all found patterns. \cr
#' \cr
#' \code{strfind(..., i = "all")} returns a list with all found pattern locations. \cr
#' \cr
#' \code{strfind(..., i = i)},
#' with `i` being an integer,
#' returns an integer matrix with two columns,
#' giving the start and end positions of the \eqn{i^{th}} matches,
#' two NAs if no matches are found, and also two `NA`s if str is `NA`. \cr
#' \cr
#' \code{strfind(x, p) <- value} returns nothing,
#' but performs in-place replacement of the found patterns in `x`. \cr
#'
#'
#' @seealso \link{tinycodet_strings}
#'
#'
#' @examples
#'
#' # example of %s{}% ====
#'
#' x <- c(paste0(letters[1:13], collapse=""), paste0(letters[14:26], collapse=""))
#' print(x)
#' x %s{}% "a"
#' x %s!{}% "a"
#' which(x %s{}% "a")
#' which(x %s!{}% "a")
#' x[x %s{}% "a"]
#' x[x %s!{}% "a"]
#' x[x %s{}% "a"] <- 1
#' x[x %s!{}% "a"] <- 1
#' print(x)
#'
#' x <- c(paste0(letters[1:13], collapse=""), paste0(letters[14:26], collapse=""))
#' x %s{}% "1"
#' x %s!{}% "1"
#' which(x %s{}% "1")
#' which(x %s!{}% "1")
#' x[x %s{}% "1"]
#' x[x %s!{}% "1"]
#' x[x %s{}% "1"] <- "a"
#' x[x %s!{}% "1"] <- "a"
#' print(x)
#'
#'
#' #############################################################################
#'
#' # Example of strfind ====
#'
#' # replace all:
#' x <- rep('The quick brown fox jumped over the lazy dog.', 3)
#' print(x)
#' p <- c('quick', 'brown', 'fox')
#' rp <- c('slow',  'black', 'bear')
#' x %s{}% p
#' strfind(x, p)
#' strfind(x, p) <- rp
#' print(x)
#'
#'
#' # new character vector:
#' x <- c(paste0(letters[1:13], collapse=""), paste0(letters[14:26], collapse=""))
#' print(x)
#'
#' # report ith (second and second-last) vowel locations:
#' p <- s_regex( # vowels
#'   rep("A|E|I|O|U", 2),
#'   case_insensitive=TRUE
#' )
#' loc <- strfind(x, p, i = c(2, -2))
#' print(loc)
#'
#' # extract ith vowels:
#' extr <- stringi::stri_sub(x, from = loc)
#' print(extr)
#'
#' # replace ith vowels with numbers:
#' repl <- chartr("aeiou", "12345", extr)
#' stringi::stri_sub(x, loc) <- repl
#' print(x)
#'
#'
#' x <- c(paste0(letters[1:13], collapse=""), paste0(letters[14:26], collapse=""))
#' print(x)
#' strfind(x, "abc", i=1)
#'
#' @name str_search
NULL
#' @rdname str_search
#' @export
`%s{}%` <- function(x, p) {
if(is.list(p)){
return(do.call(stringi::stri_detect, c(list(str = x), p)))
}
if(is.character(p)) {
return(stringi::stri_detect(x, regex=p))
} else {
stop("right hand side must be a character vector or list")
}
}
#' @rdname str_search
#' @export
`%s!{}%` <- function(x, p) {
if(is.list(p)){
return(do.call(stringi::stri_detect, c(list(str = x, negate = TRUE), p)))
}
if(is.character(p)) {
return(stringi::stri_detect(x, regex = p, negate = TRUE))
} else {
stop("right hand side must be a character vector or list")
}
}
#' @rdname str_search
#' @export
strfind <- function(x, p, i = NULL, ...) {
if(!is.null(i) && is.numeric(i)) {
if(is.list(p)){
args <- list(str = x, i = i)
return(do.call(stri_locate_ith, c(args, p, list(...))))
} else if(is.character(p)) {
return(stri_locate_ith(
str = x, i = i, regex = p, ...
))
} else {
stop("`p` must be a character vector or list")
}
}
else if(!is.null(i) && i == "all") {
if(is.list(p)){
return(do.call(stringi::stri_locate_all, c(list(str = x), p, list(...))))
} else if(is.character(p)) {
return(stringi::stri_locate_all(
str = x, regex = p, ...
))
} else {
stop("`p` must be a character vector or list")
}
}
else if(is.null(i)) {
if(is.list(p)){
return(do.call(stringi::stri_extract_all, c(list(str = x), p, list(...))))
} else if(is.character(p)) {
return(stringi::stri_extract_all(
str = x, regex = p, ...
))
} else {
stop("`p` must be a character vector or list")
}
}
else {
stop("improper `i` given")
}
}
#' @rdname str_search
#' @export
`strfind<-` <- function(x, p, ..., value) {
if(is.list(p)){
args <- list(str = x,replacement = value)
return(do.call(stringi::stri_replace_all, c(args, p)))
} else if(is.character(p)) {
return(stringi::stri_replace_all(
str = x, replacement = value, regex = p, ...
))
} else {
stop("`p` must be a character vector or list")
}
}
strfind(x, "abc", i=1)
library(tinycodet)
strfind(x, "abc", i=1)
strfind(x, "abc", i=1)[,1] == 1
strfind(x, "abc", i=1)[,1] == 1
?na.action
?na.omit
?stringi::stri_locate_all
?stringi::stri_detect
?tinycodet::strcut_loc
?stringr::starts
?stringr::starts
?stringr::str_starts
# set-up ====
setwd("D:/D Desktop/Publications/R package tinycodet")
sessionInfo()
pkgs <- c("devtools", "roxygen2", "usethis", "rcmdcheck", "spelling", "tinytex",
"tinytest", "pkgdown", "goodpractice", "rhub")
for(i in pkgs) if(!requireNamespace(i))install.packages(i)
library(tinytest)
# install + extra checks ====
devtools::install("tinycodet")
stri_locate_ith_regex2 <- function(str, pattern, i, ..., opts_regex = NULL) {
n <- length(str)
p1 <- stringi::stri_locate_all_regex(
str = str, pattern = pattern, capture_groups = FALSE,
omit_no_match = FALSE, get_length = FALSE,
..., opts_regex = opts_regex
)
return(.stri_locate_ith_internal2(p1, i, n, sys.call()))
}
.stri_locate_ith_internal2 <- function(p1, i, n, abortcall) {
if(length(i) == 1) i <- rep.int(i, n)
if(length(i) != n) {
stop(simpleError("`i` must be the same length as `str`, or be a length of 1", call = abortcall))
}
n.matches <- collapse::vlengths(p1) / 2
n.matches <- pmax(n.matches, 1) # if no matches found, n.matches must be 1 so that "match" NA is returned.
neg <- which(i < 0)
pos <- which(i > 0)
bad_i <- length(i) != (length(neg) + length(pos))
if(bad_i){
stop(simpleError("`i` is not allowed to be zero or NA", call = abortcall))
}
i[neg] <- pmax(n.matches[neg] - abs(i[neg] + 1), 1)
i[pos] <- pmin(i[pos], n.matches[pos])
rowind <- i + c(0, collapse::fcumsum.default(n.matches))[seq_len(n)]
mat <- do.call(rbind, p1)
mat <- mat[rowind, , drop = FALSE]
colnames(mat) <- c("start", "end")
return(mat)
}
library(tinycodet)
library(ggplot2)
n <- 1e5
x <- rep(paste0(1:50, collapse = ""), n)
p <- "\\d"
i <- sample(c(-50:-1, 1:50), replace=TRUE, size = n)
n <- 1e5
x <- rep(paste0(1:50, collapse = ""), n)
p <- "\\d"
i <- sample(c(-50:-1, 1:50), replace=TRUE, size = n)
bench::mark(
stri_locate_ith_regex(x, p, i),
stri_locate_ith_regex2(x, p, i),
min_iterations = 500
)
foo <- bench::mark(
stri_locate_ith_regex(x, p, i),
stri_locate_ith_regex2(x, p, i),
min_iterations = 10
)
foo
ggplot2::autoplot(foo)
foo <- bench::mark(
stri_locate_ith_regex(x, p, i),
stri_locate_ith_regex2(x, p, i),
min_iterations = 100
)
foo
ggplot2::autoplot(foo)
367/280
280/367
library(tinycodet)
library(ggplot2)
n <- 1e5
x <- rep(paste0(1:50, collapse = ""), n)
p <- "\\d"
i <- sample(c(-50:-1, 1:50), replace=TRUE, size = n)
locate_stringi <- function(...) {
stringi::stri_locate_all(...)
stringi::stri_count(...)
}
bm.stri_locate_ith <- bench::mark(
"stri_locate_ith" = { stri_locate_ith_regex(x, p, i) },
"stringi::(stri_locate_all + stri_count)" = { locate_stringi(str=x, regex = p) },
min_iterations = 500,
check = FALSE,
filter_gc = FALSE
)
bm.stri_locate_ith
autoplot(bm.stri_locate_ith)
437/287
287/437
setwd("D:/D Desktop/Publications/R package tinycodet/tinycodet/vignettes/articles")
save(bm.stri_locate_ith, file = "bm.stri_locate_ith.RData")
