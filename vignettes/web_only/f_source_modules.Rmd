---
title: "Source modules"
output:
  rmarkdown::html_vignette:
    toc: true
    number_sections: true
vignette: >
  %\VignetteIndexEntry{Source modules}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(tinyoperations)
```

&nbsp;

# Introduction

The article "Package import system" explained the new import system introduced by the `tinyoperations` R package. Some of its functionality is also extended to work on scripts that provide user-defined functions and datasets. These scripts, which should have no side-effects (i.e. plots, prints, messages), are referred to as "modules".

&nbsp;

# Main

The the `tinyoperations` R package adds the `alias %@source% list(file=...)` operator and the `source_inops()` function. The `alias %@source% list(file=...)` operator sources a script and returns all the objects in the script under an `alias`, similar to `import_as()`. The `source_inops()` function sources a script and places all infix operators in the script (if any) in the current environment (like the Global environment, or the environment within a function), similar to `import_inops()`.

Example:

```{r}
myalias. %@source% list(file="sourcetest.R")
source_inops(file="sourcetest.R")

myalias.$helloworld()
```

Another example, this time using an expression:

```{r}
exprs <- expression({
  helloworld = function()print("helloworld")
  goodbyeworld <- function() print("goodbye world")
  `%s+test%` <- function(x,y) stringi::`%s+%`(x,y)
  `%s*test%` <- function(x,y) stringi::`%s*%`(x,y)
})

myalias. %@source% list(exprs=exprs)

myalias.$helloworld()

temp.fun <- function(){
  source_inops(exprs=exprs) # places the function inside the function environment
  ls() # list all objects residing within the function definition
}
temp.fun()
```

&nbsp;

Note that, as long as `@source` and `source_inops()` **source the same file/expression**, they will both have access to the same functions.

To demonstrate this, consider the following:

```{r}
exprs <- expression({
  mypaste <- function(x,y) stringi::`%s+%`(x,y)
  `%s+test%` <- function(x,y){
    mypaste(x,y) # notice this operator needs to "see" mypaste() in order to work.
  }
})
myalias. %@source% list(exprs=exprs)
source_inops(exprs=exprs)
"a" %s+test% "b"

# both the aliased functions and the exposed infix operator
# have access to the same functions:
ls(environment(`%s+test%`))
ls(environment(myalias.$mypaste))
```

So no need to worry about their scope (unless you start tinkering with the environments of the functions.)


&nbsp;

# The report_inops() function

`tinyoperations` adds the `report_inops()` function. This is a convenience function that prints all infix operators in the current environment, as well as from which package it came (if the function can find that out).

Example:

```{r}
import_inops("magrittr")
exprs <- expression({
  helloworld = function()print("helloworld")
  goodbyeworld <- function() print("goodbye world")
  `%s+test%` <- function(x,y) stringi::`%s+%`(x,y)
  `%s*test%` <- function(x,y) stringi::`%s*%`(x,y)
})
source_inops(exprs=exprs)
report_inops()
```


&nbsp;

# Regarding S3 methods

When importing packages with `tinyoperations`' import system, S3 methods will work just fine. For example, the S3 method " `plot()` " works on the pre-installed recommended R package `mgcv`, even when loaded in an alias:

```{r}
import_as(mgcv., "mgcv")
d <- import_data("chicago", "gamair")
model <- mgcv.$gam(death ~ s(o3median), data=d) # just a random model for the sake of demonstration
isS3method(f="plot", class="gam") # this is an S3 method
plot(model)
```

Also, S3 methods defined in the package will automatically be registered, and thus automatically work. For example, the following code just works:

```{r}
import_as(dr., "dplyr")
import_inops("magrittr")
d <- import_data("starwars", "dplyr")
d <- d %>% dr.$group_by(species)

isS3method(f="arrange", class="data.frame", envir = dr.) # this is an S3 method
isS3method(f="relocate", class="data.frame", envir = dr.) # this is an S3 method
# this works:
d %>%
  dr.$arrange(dr.$desc(mass)) %>%
  dr.$relocate(species, mass)
```

So when importing packages, everything works as expected, including S3 methods.

&nbsp;

So for packages, there's no need to worry about S3 methods. This is unfortunately not the case for most simple scripts that users create themselves, as simple scripts usually do not register S3 methods outside of the script's own environment.

The following code, for example, gives an error:

```{r}
exprs <- expression({
  mymeth <- function(x){
  UseMethod("mymeth", x)
  }

  mymeth.numeric <- function(x)x *2
  
  mymeth.character <- function(x){chartr(x, old = "a-zA-Z", new = "A-Za-z")}
})

myalias. %@source% list(exprs=exprs)

tinytest::expect_error(myalias.$mymeth(0))
tinytest::expect_error(myalias.$mymeth("a"))
```

The `tinyoperations` R package does not provide support for registering S3 methods from sourced scripts, at least not out of the box.

The solution is quite simple though: If you have your own script containing S3/S4 methods, put all methods, and all functions that interact with said methods, in their own script, and source them using the regular `source()` function:

```{r}
exprs <- expression({
  mymeth <- function(x){
  UseMethod("mymeth", x)
  }

  mymeth.numeric <- function(x)x *2
  
  mymeth.character <- function(x){chartr(x, old = "a-zA-Z", new = "A-Za-z")}
})
source(exprs = exprs)
mymeth(0)
mymeth("a")
```

If you dislike this approach, you can also use the [import](https://github.com/rticulate/import) package to source a script, as that package provides an (experimental) S3 registering system for sourced scripts. Note, however, that the [import](https://github.com/rticulate/import) R package does not provide some of the other features of `tinyoperations`, such as importing multiple related packages under the same alias, and convenient infix operator handling.


&nbsp;



