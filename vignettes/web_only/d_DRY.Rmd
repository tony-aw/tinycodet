---
title: "Don't Repeat Yourself"
output:
  rmarkdown::html_vignette:
    toc: true
    number_sections: true
vignette: >
  %\VignetteIndexEntry{Don't Repeat Yourself}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(tinyoperations)
```


# The transform_if function, and related operators

"Don't Repeat Yourself", sometimes abbreviated as "DRY", is the coding principle that you should try to reduce repeating patterns in your code (within reason).

Consider the following code:


```{r echo=TRUE}
object <- matrix(c(-9:8, NA, NA) , ncol=2)
y <- 0
z <- 1000
ifelse(
  is.na(object>y), -z,
  ifelse(
    object>y,  log(object), object^2
  )
)
```


Here a conditional subset of the object `object` is transformed where the condition is using a function referring to `object` itself. Consequently, reference to `object` is written 4 times! This can become cumbersome quickly (notice also that `ifelse()` gives an unnecessary warning).


The `tinyoperations` package therefore adds the `transform_if(x, cond, yes, no, other, text)` function which will "dry" this up.
Here, in argument `cond` a function must be given that returns a logical vector. For every value where `cond(x)==TRUE`, function `yes(x)` is run, for every value where `cond(x)==FALSE`, function `no(x)` is run, and for every value where `cond(x)==NA`, function `other` is run.

The above code can now be compactly re-written as:

```{r echo=TRUE}
object |> transform_if(\(x)x>y, log, \(x)x^2, \(x) -z)
```


You may have noticed there's also the `text` argument. The user can supply a single string here, in which case the `cond, yes, no, other` arguments will be ignored. The string must be consist of 5 pieces of simple text, delimited by semicolons (;), in the form of `"x ; cond ; yes ; no ; other"`, with `x` being the declared variable, and `cond, yes, no, other` being expressions describing the respective functions. (The help file page of this functions gives more specific details.) So we can also rewrite the original code as:

```{r echo=TRUE}
object |> transform_if(text = "x ; x>y ; log(x) ; x^2 ; -z")
```


&nbsp;

Besides `transform_if`, the `tinyoperations` package also adds 2 "subset_if" operators:

 - The `x %[if]% cond` operator selects elements from vector/matrix/array `x`, for which the result of `cond(x)` returns `TRUE`.

 - The `x %[!if]% cond` operator selects elements from vector/matrix/array `x`, for which the result of `cond(x)` returns `FALSE`.

For example:

```{r}
object_with_very_long_name <- matrix(-10:9, ncol=2)
print(object_with_very_long_name)
object_with_very_long_name %[if]% \(x)x %in% 1:10
object_with_very_long_name %[!if]% \(x)x %in% 1:10
```


Another operator added by `tinyoperations` is `x %unreal =% y`, which replaces all NA, NaN, Inf and -Inf in `x` with the value given in `y`.

So `x %unreal =% y` is the same as `x[is.na(x)|is.nan(x)|is.infinite(x)] <- y`.


&nbsp;


# Generalized in-place (mathematical) modifier


This R package includes infix operators for in-place modifying mathematical arithmetic.

Consider the following line of code:

```{r eval=FALSE}
mtcars$mpg[mtcars$cyl>6] <- mtcars$mpg[mtcars$cyl>6]^2
```

The same expression, `mtcars$mpg[mtcars$cyl>6]`, is written twice, making this code rather long and cumbersome, even though we're just squaring the expression. 

This R package solves the above laid-out problem by implementing a generalized in-place (mathematical) modifier, through the `x %:=% f` operator.

With `tinyoperations` one can now make this more compact (more "tiny", if you will) as follows:

```{r eval=FALSE}
mtcars$mpg[mtcars$cyl>6] %:=% \(x)x^2
```


This function based method is used instead of the more traditional in-place mathematical modification like `+=` to prevent precedence issues (functions come before mathematical arithmetic in `R`). Precedence issues are a common occurrence in R packages that attempt to implement in-place modifying arithmetic; `tinyoperations`'s `%:=%` operator does not have this problem, as the math is specified inside a function.

&nbsp;

# Atomic type casting

Atomic type casting in R is generally performed using the functions `as.logical()`, `as.integer()`, `as.double()`, `as.character()`.

These functions have the annoying property that they strip attributes. The safest and most consistent way (as far as I was able to test out) to convert atomic types without loosing attributes, and without getting inconsistent results, is to first store the attributes, convert the object, and then re-assign the attributes. Like so:

```{r}
x <- rnorm(10) |> matrix(ncol=2)
colnames(x) <- c("one", "two")
attr(x, "test") <- "test"
print(x)

# First, store the attributes:
myattr <- attributes(x)
# Second, convert the object:
x <- as.integer(x)
print(x) # no longer a matrix, nor any other attributes
# Third, re-assign attributes:
attributes(x) <- myattr
print(x)

```


The above code ... is just sad. So I've taken the liberty of creating more convenient atomic type conversion functions (properly tested, of course).

 - `as_bool()`: same as `as.logical()`, but with attributes preserved.
 - `as_int()`: same as `as.integer()`, but with attributes preserved.
 - `as_dbl()`: same as `as.double()` (i.e. convert to real numbers), but with attributes preserved.
 - `as_chr()`: same as `as.character()`, but with attributes preserved.
 
Examples:

```{r}
x <- rnorm(10) |> matrix(ncol=2)
colnames(x) <- c("one", "two")
attr(x, "test") <- "test"

as_bool(x)
as_int(x)
as_dbl(x)
as_chr(x)
```


&nbsp;

# In-place modifying string arithmetic and sub-setting

With the exception of  `%ss%`, all infix operators for string arithmetic and string sub-setting have their in-place modifying equivalent:

 - `x %s+ =% y` is the same as `x <- x %s+% y`
 - `x %s- =% p` is the same as `x <- x %s-% p`
 - `x %s* =% n` is the same as `x <- x %s*% n`
 - `x %s/ =% p` is the same as `x <- x %s/% p`
 - `x %sget =% ss` is the same as `x <- x %sget% ss`
 - `x %strim =% ss` is the same as `x <- x %strim% ss`

 
Notice the extra space before the `=` sign. 


&nbsp;

