---
output:
  github_document:
    toc: true
    number_sections: true
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
library(badger)
library(knitr)
library(tinyoperations)
set.seed(1)
```

&nbsp;

# Safer decimal number truth testing operators

This package adds the `%d==%, %d!=% %d<%, %d>%, %d<=%, %d>=%` (in)equality operators, which perform safer decimal number truth testing. They are virtually equivalent to the regular (in)equality operators,
`==, !=, <, >, <=, >=`,
except for one aspect: The decimal number truth testing operators assume that if the absolute difference between `x` and `y` is smaller than the Machine tolerance, `sqrt(.Machine$double.eps)`, then `x` and `y` ought to be consider to be equal.

Thus these provide safer decimal number (in)equality operators.

For example: `(0.1*7) == 0.7` returns `FALSE`, even though they are equal, due to the way decimal numbers are stored in programming languages like `R`, `Python`, etc. But `(0.1*7) %d==% 0.7` returns `TRUE`.

Some examples:

```{r}
x <- c(0.3, 0.6, 0.7)
y <- c(0.1*3, 0.1*6, 0.1*7)
print(x); print(y)
x == y # gives FALSE, but should be TRUE
x!= y # gives TRUE, should be FALSE
x > y # not wrong
x < y # gives TRUE, should be FALSE
x %d==% y # here it's done correctly
x %d!=% y
x %d<% y # correct
x %d>% y # correct
x %d<=% y # correct
x %d>=% y # correct

x <- c(0.3, 0.6, 0.7)
bnd <- matrix(c(x-0.1, x+0.1), ncol=2)
x %d{}% bnd
x %d!{}% bnd
```

Although designed for objects (vectors, matrices, arrays) of class `double` (decimal numbers), these operators also work correctly for integers. These operators do not work for non-numeric objects.


&nbsp;

# Matrix re-ordering operators

The `tinyoperations` R package adds 2 additional matrix operators:

 - The `x %row~% mat` operator re-orders the elements within every row of matrix `x` by the ordering ranks given in matrix `mat`.
 - The `x %col~% mat` operator re-orders the elements within every column of matrix `x` by the ordering ranks given in matrix `mat`.
 
If matrix `x` is a numeric matrix, and one wants to numerically sort the elements of every row or column, `x %row~% x` or `x %col~% x` would suffice, respectively.

If matrix `x` is not numeric, sorting using `x %row~% x` and `x %col~% x `are still possible, but probably not the best option. In the non-numeric case, providing a matrix of ordering ranks would probably be faster and give more accurate ordering.

If `mat` is a matrix of non-repeating random integers (i.e. `sample(1:length(x), replace=FALSE)`), `x %row~% mat` will randomly shuffle the elements of every row, where the shuffling order of every row is independent of the other rows. Similarly, `x %col~% mat` will randomly shuffle the elements of every column, where the shuffling order of every column is independent of the other columns.

&nbsp;

Examples with a numeric matrix:

```{r}
x <- matrix(sample(1:25), nrow=5)
print(x)
x %row~% x # sort elements of every row
x %row~% -x # reverse-sort elements of every row
x %col~% x # sort elements of every column
x %col~% -x # reverse-sort elements of every column

x <- matrix(sample(1:25), nrow=5)
print(x)
rand <- sample(1:length(x)) |> matrix(ncol=ncol(x)) # matrix of random integers
x %row~% rand # random shuffle every row independent of other rows
x %col~% rand # random shuffle every column independent of other columns
```


Examples with a character matrix:

```{r}
x <- matrix(sample(letters, 25), nrow=5)
print(x)
mat <- stringi::stri_rank(as.vector(x)) |>
  matrix(ncol=ncol(x)) # matrix of ordering ranks
x %row~% mat # sort elements of every row
x %row~% -mat # reverse-sort elements of every row
x %col~% mat # sort elements of every column
x %col~% -mat # reverse-sort elements of every column

x <- matrix(sample(letters, 25), nrow=5)
print(x)
rand <- sample(1:length(x)) |> matrix(ncol=ncol(x)) # matrix of random integers
x %row~% rand # random shuffle every row independent of other rows
x %col~% rand # random shuffle every column independent of other columns
```

These operators internally only use vectorized operations (no loops or apply-like functions), and are faster than re-ordering matrices using loops or apply-like functions.

&nbsp;

# String functions

## Matrix joining

The `tinyoperations` package adds a tiny additional function to `stringi`:

`stri_join_mat` (and their aliases `stri_c_mat` and `stri_paste_mat`).

As the name suggests, these functions perform row-wise (`margin=1`; the default) or column-wise (`margin=2`) joining of a matrix of strings, thereby transforming it to a vector of strings. You can do this already in base R, but it requires converting the matrix to a data.frame or list, and then calling `stri_join` inside `do.call()`, which to me just seems too much trouble for something *soooo* abysmally simple.

Here is an example of their usage when re-ordering strings, words, or sentences :

```{r}
# sorting characters in strings:
x <- c("Hello world", "Goodbye world")
print(x)
x <- stringi::stri_split_boundaries(x, simplify = TRUE, type="character")
mat <- stringi::stri_rank(as.vector(x)) |>  matrix(ncol=ncol(x))
sorted <- x %row~% mat # fast sort matrix row-wise
stri_join_mat(sorted, margin=1, sep="") # <- using new function here

# sorting words:
x <- c("Hello everyone", "Goodbye everyone")
print(x)
x <- stringi::stri_split_boundaries(x, simplify = TRUE, type="word")
mat <- stringi::stri_rank(as.vector(x)) |>  matrix(ncol=ncol(x))
sorted <- x %row~% mat # <- fast sort matrix row-wise
stri_c_mat(sorted, margin=1, sep=" ") # <- alias for stri_join_mat

# randomly shuffle sentences:
x <- c("Hello, who are you? Oh, really?! Cool!", "I don't care. But I really don't.")
print(x)
x <- stringi::stri_split_boundaries(x, simplify = TRUE, type="sentence")
mat <- sample(1:length(x)) |> matrix(ncol=ncol(x))
shuffled <- x %row~% mat # <- fast sort matrix row-wise
print(shuffled)
stri_paste_mat(shuffled, margin=1, sep=" ") # <- another alias for stri_join_mat
```

&nbsp;

## stri_locate_ith

Suppose one wants to transform the **first** vowels in the strings of a character vector `str`, such that all upper case vowels become lower case, and vice-versa.
One can do that completely in `stringi` + base R as follows:

```{r}

x <- c("HELLO WORLD", "goodbye world")
loc <- stringi::stri_locate_first(x, regex="a|e|i|o|u", case_insensitive=TRUE)
extr <- stringi::stri_sub(x, from=loc)
repl <- chartr(extr, old = "a-zA-Z", new = "A-Za-z")
stringi::stri_sub_replace(x, loc, replacement=repl)
```

But now suppose one wants to transform the **second-last** vowel. How are you going to do that? It's not impossible, but also not super straight-forward. For clear code, `stringi` really needs some kind of "stri_locate_ith" function. And, of course, the `tinyoperations` package provides just that.

The `stri_locate_ith(str, i, ...)` function locates for every element/string in character vector `str`, the $i^\textrm{th}$ occurrence of some (regex/fixed/etc) pattern. When `i` is positive, the occurrence is counted from left to right. Negative values for `i` are also allowed, in which case the occurrence is counted from the right to left. But `i=0` is not allowed though. Thus, to get the **second** occurrence of some pattern, use `i=2`, and to get the **second-last** occurrence, use `i=-2`.

The `stri_locate_ith(str, i, ...)` function uses the exact same argument and naming convention as `stringi`, to keep your code consistent. And just like `stringi::stri_locate_first/last`, the `stri_locate_ith(str, i, ...)` function is a vectorized function: `str` and  `i` as well as the pattern (`regex, fixed, coll, charclass`) can all be different-valued vectors. It is also vectorized in the sense that no loops (in R) are used, only vectorized functions.


&nbsp;

To transform the **second-last** occurrence, one can now use `stri_locate_ith()` in a very similar way as was done with `stri_locate_first/last`:

```{r}
x <- c("HELLO WORLD", "goodbye world")

loc <- stri_locate_ith( # this part is the key-difference
  x, -2, regex="a|e|i|o|u", case_insensitive=TRUE
)

extr <- stringi::stri_sub(x, from=loc)
repl <- chartr(extr, old = "a-zA-Z", new = "A-Za-z")
stringi::stri_sub_replace(x, loc, replacement=repl)
```

Notice that the code is virtually equivalent. We *only* need to change the locate function.

Regarding its speed:

The `stri_locate_ith()` function needs to know the number of matches of some pattern for every string in a character vector, as well as the actual matches themselves, before being able to actually give the $i^\textrm{th}$ occurrence of some pattern. Thus `stri_locate_ith()` (at least in its current implementation) cannot be faster than the combined run-time of the `stri_locate_all()` and `stri_count()` functions. As `stri_locate_ith()` is written only in fully vectorized statements in R (no loops), the function is very fast, and takes about as much time as the time of `stri_locate_all()` and `stri_count()` combined.

&nbsp;

## Substr - functions

The `tinyoperations` R-package includes the following "substr-" functions:

 - The `substr_repl(x, rp, ...)` function replaces a position (range) with string `rp`.
 - The `substr_chartr(x, old, new, ...)` function transforms the sub-string at a position (range) using `chartr(old, new)`. By default, it will translate upper-case characters to lower-case, and vice-versa.
 - The `substr_addin(x, addition, side, ...)` function adds the additional string `addition` at the side `side` of a position.
 - The `substr_extract(x, type, ...)` function extracts the string at, before, or after some position (range).
 - The `substr_arrange(x, arr, ...)` function re-arranges (sort, reverse, randomize) the sub-string at a position (range).

The "position" in the functions above can be specified either by giving the result of the `stri_locate_ith()` function (see the previous section) in argument `loc`, or one can give manual positions using the `start, end` or `at` arguments. 

Examples:

```{r}
x <- c("Good - good - GOOD", "Good - GOOD - good")
loc <- stri_locate_ith(
  # locate second "good" (ignore case) of each string in x:
  x, 2, regex="good", case_insensitive=TRUE 
)
```

```{r echo=FALSE}
tab <- data.frame(
  x=x,
  `substr_extract(x, loc=loc)` = substr_extract(x, loc=loc),
  `substr_extract(x, "before", loc=loc)` = substr_extract(x, "before", loc=loc),
  `substr_extract(x, "after", loc=loc)` = substr_extract(x, "after", loc=loc),
  `substr_repl(x, "??", loc=loc)` = substr_repl(x, "??", loc=loc),
  `substr_chartr(x, loc=loc)` = substr_chartr(x, loc=loc),
  `substr_addin(x, "~~", "after", loc=loc)` = substr_addin(x, "~~", "after", loc=loc),
  `substr_addin(x, "~~", "before", loc=loc)` = substr_addin(x, "~~", "before", loc=loc),
  `substr_arrange(x, loc=loc)` = substr_arrange(x, loc=loc),
  `substr_arrange(x, "decr", loc=loc)` = substr_arrange(x, "decr", loc=loc),
  `substr_arrange(x, "rev", loc=loc)` = substr_arrange(x, "rev", loc=loc),
  `substr_arrange(x, "rand", loc=loc)` = substr_arrange(x, "rand", loc=loc),
  check.names = FALSE
)
tab <- tab |> as.matrix() |> t()
kable(tab)
```


&nbsp;

# String infix operators

The `tinyoperations` R package implements infix operators for string arithmetic and sub-setting, as well some of their in-place modifier equivalents. For consistency, and to avoid masking other common operators, all string-related operators start with `%s`, where the "s" stands for "string".

&nbsp;


## String subsetting operators

As a first sub-setting operator, we have `x %sget% ss`, which returns a subset of each string in character vector `x`. Here `ss` is a vector of length 2, or a matrix with `nrow(ss)=length(x)` and 2 columns. The object `ss` should consist entirely of non-negative integers (thus 0, 1, 2, etc. are valid, but -1, -2, -3 etc are not valid). The first element/column of ss gives the number of characters counting from the left side to be extracted from x. The second element/column of ss gives the number of characters counting from the right side to be extracted from x.

Here are 2 examples:

```{r}
x <- c(paste0(letters[1:13], collapse=""), paste0(letters[14:26], collapse=""))
print(x)
ss <- c(2,3)
x %sget% ss

x <- c(paste0(letters[1:13], collapse=""), paste0(letters[14:26], collapse=""))
print(x)
ss <- c(1,0)
x %sget% ss
```

Thus `x %sget% ss` "gets" or extracts the given number of characters from the left and the right, and removes the rest.
There is also `x %strim% ss`, which is the opposite: it trims away the number of characters from the left and right as defined in the matrix `ss`, leaving you with whatever is left.

Here are again 2 examples:

```{r}
x <- c(paste0(letters[1:13], collapse=""), paste0(letters[14:26], collapse=""))
print(x)
ss <- c(2,3)
x %strim% ss

x <- c(paste0(letters[1:13], collapse=""), paste0(letters[14:26], collapse=""))
print(x)
ss <- c(1,0)
x %strim% ss
```


&nbsp; 


## String arithmetic

The `tinyoperations` package adds 4 string arithmetic operators:

 - `x %s+% y` concatenates `x` and `y`;
 - `x %s-% p` removes pattern `p` from each string in character vector `x`;
 - `x %s*% n` repeats each string in character vector `x` for `n` times;
 - `x %s/% p` counts how often pattern `p` occurs in string or vector `x`
 
I.e.:

```{r}
"Hello "%s+% " world"
c("Hello world", "Goodbye world") %s-% " world"
c("Ha", "Ho", "Hi", "Hu", "He", "Ha") %s*% 2:7
c("hello world & goodbye world", "world domination!") %s/% "world"
```

The right-side arguments `p`, `y`, and `n` can be a single value, or a vector of the same length as `x`.

&nbsp;

## Specifying Pattern search attributes in string infix operators

The `x %s-% p` and `x %s/% p` operators (and their in-place equivalents, given later), and the `%sgrep%` operator perform pattern matching for various purposes. By default the pattern matching is interpreted as case-sensitive `regex` patterns from `stringi`.

But, of course, sometimes one wants to change this. For example, one may want it to be case insensitive. Or perhaps one wants to use fixed expressions, or something else.

The `tinyoperations` package provides options for these cases. To use more refined pattern definition, simply replace the argument/right-hand-side expression `p` in the relevant operators with a call from the `s_pattern()` function.

The `s_pattern()` function uses the exact same argument convention as `stringi`. For example:

 - `s_pattern(regex=p, case_insensitive=FALSE, ...)`
 - `s_pattern(fixed=p, ...)`
 - `s_pattern(coll=p, ...)`
 - `s_pattern(charclass=p, ...)`

Note that the `s_pattern()` function only works for the infix operators (functions surrounded by `%` signs) related to strings in this R package.


Examples with Regular expressions:

```{r}
x <- c("Hello world", "Goodbye world")
p <- s_pattern(regex=" world")
x %s-% p

x <- c("Ha", "Ho", "Hi", "Hu", "He", "Ha") %s*% 10
p <- s_pattern(regex="Ha")
x %s/% p
```

Examples with Fixed expressions:

```{r}
x <- c("Hello world", "Goodbye world")
p <- s_pattern(fixed=" world")
x %s-% p

x <- c("Ha", "Ho", "Hi", "Hu", "He", "Ha") %s*% 10
p <- s_pattern(fixed="Ha")
x %s/% p
```

And so on. I'm sure you get the idea.

&nbsp;


# Miscellaneous functionality

## Additional logic operators

The tinyoperations package adds a few basic logic operators:

 - `%xor%`: Exclusive OR
 - `%n&%`: NOT AND (i.e. `(!x) & (!y)`). Note that if either `x` or `y` is `NA`, `%n&%` will also give `NA` (unlike `(!x) & (!y)`, which would give `FALSE`.)
 - `%?=%`: checks if both `x` and `y` are unknown or unreal (NA, NaN, Inf, -Inf)
 - `%out%`: the opposite of `%in%` (i.e. `!x %in% y`)
 - `s %sgrep% p` checks if pattern `p` (defined as either `regex`, or as a call from `s_pattern()`) appears in character vector `s` (info on the `s_pattern()` function can be found in the string section of this read-me)

Here are some examples:

```{r}
x <- c(TRUE, FALSE, TRUE, FALSE, NA, NaN, Inf, -Inf, TRUE, FALSE)
y <- c(FALSE, TRUE, TRUE, FALSE, rep(NA, 6))
outcome <- data.frame(
  x=x, y=y,
  "x %xor% y"=x %xor% y, "x %n&% y" = x %n&% y, "x %?=% y" = x %?=% y,
  check.names = FALSE
)
kable(outcome)

1:3 %out% 1:10
1:10 %out% 1:3
```



Numbers can have many different sub-types whilst still being `numeric`. The `n %=numtype% numtype` operator will check for every value of numeric vector `n` if it can be considered a number belonging to type `numtype`. The following values for `numtype` are allowed:

 - "~0": zero, or else a number whose absolute value is smaller than the Machine tolerance (`sqrt(.Machine$double.eps)`);
 - "B": binary numbers (0 or 1);
 - "prop": proportions;
 - "I": Integers;
 - "odd": odd integers;
 - "even": even integers
 - "R": Real numbers;
 - "unreal": infinity, NA, or NaN;

The string counterpart for `%=numtype%` is `s %=strtype% strtype`, which checks for every value of character vector `s` if it can seen as a certain `strtype`. The following values for `strtype` are allowed:

 - "empty": checks if the string only consists of empty spaces.
 - "unreal": checks if the string is NA, or if it has literal string "NA", "NaN" or "Inf", regardless if it has leading or trailing spaces.
 - "numeric": checks if the string can be converted to a number, disregarding leading and trailing spaces. I.e. the string "5.0" can be converted to the the actual number 5.0.
 - "special": checks if the string consists of only special characters.

Here are some examples:

```{r}

1e-20 %=numtype% "~0"
n <- c(0:5, 0:-5, 0.1, -0.1, 0, 1, Inf, -Inf, NA, NaN)
n[n %=numtype% "B"]
n[n %=numtype% "prop"]
n[n %=numtype% "B"]
n[n %=numtype% "I"]
n[n %=numtype% "odd"]
n[n %=numtype% "even"]
n[n %=numtype% "R"]
n[n %=numtype% "unreal"]

s <- c(" AbcZ123 ", " abc ", " 1.3 ", " !#$%^&*() ", "  ", "  NA  ", "  NaN  ", " Inf ")
s[s %=strtype% "empty"]
s[s %=strtype% "unreal"]
s[s %=strtype% "numeric"]
s[s %=strtype% "special"]
```


&nbsp;

## Other

The `tinyoperations` R package also adds a few other things:


 - The `lock_TF()` function locks `T` and `F` to `TRUE` and `FALSE`, to prevent the user from re-assigning them. Removing the created `T` and `F` constants allows re-assignment again.
 - The `X %<-c% A` operator creates a `CONSTANT` `X` with assignment `A`. Constants cannot be changed, only accessed or removed. So if you have a piece of code that requires some unchangeable constant, use this operator to create said constant.

&nbsp;
