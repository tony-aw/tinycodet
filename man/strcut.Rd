% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/strcut.R
\name{strcut_loc}
\alias{strcut_loc}
\alias{strcut_brk}
\title{Cut strings}
\usage{
strcut_loc(str, loc, fill_loc = TRUE)

strcut_brk(str, brk = "chr", ...)
}
\arguments{
\item{str}{a string or character vector.}

\item{loc}{Either one of the following:
\itemize{
\item the result from the \link{stri_locate_ith} function.
\item a matrix of 2 integer columns, with \code{nrow(loc)==length(str)},
giving the location range of the middle part.
\item a vector of length 2, giving the location range of the middle part.
}}

\item{fill_loc}{logical, indicating what should be done if
for some row \code{i},
\code{loc[i, ]} is \code{c(NA, NA)}. \cr
\itemize{
\item If \code{TRUE}, \code{c(NA, NA)} in \code{loc[i, ]}
is translated to \code{c(1, nc[i])},
where \code{nc[i]} is the number of characters of \code{str[i]}
\item If \code{FALSE}, \code{strcut_loc()} will return \code{c(NA, NA, NA)}
for when \code{loc[i,]} is \code{c(NA, NA)}.
}}

\item{brk}{a single string, giving one of the following:
\itemize{
\item \code{"chr"} or \code{"character"}: attempts to split string into individual characters.
\item \code{"line"} or \code{"line_break"}: attempts to split string into individual lines
(NOTE: this is somewhat locale dependent).
\item \code{"word"}: attempts to split string into individual words
(NOTE: this is highly locale dependent!).
\item \code{"sentence"}: attempts to split string into individual sentences
(NOTE: this is highly locale dependent!).
}

For information on the boundary rules and definitions, please see: \cr
The ICU User Guide on Boundary Analysis \cr
(\url{https://unicode-org.github.io/icu/userguide/boundaryanalysis/})}

\item{...}{additional settings for \link[stringi]{stri_opts_brkiter}}
}
\value{
For the \code{strcut_loc()} function: \cr
A character matrix with \code{length(str)} rows and 3 columns:
\itemize{
\item the first column contains the sub-strings \bold{before} \code{loc};
\item the second column contains the sub_strings at \code{loc};
\item the third and last column contains the sub-strings \bold{after} \code{loc}. \cr
\cr
}

For the \code{strcut_brk()} function: \cr
A character matrix with \code{length(str)} rows and
a number of columns equal to the maximum number of pieces \code{str} was cut in.
}
\description{
The \code{strcut_loc()} function
cuts every string in a character vector around a location range \code{loc},
such that every string is cut into the following parts:
\itemize{
\item the sub-string \bold{before} \code{loc};
\item the sub-string at \code{loc} itself;
\item the sub-string \bold{after} \code{loc}.
}

The location range \code{loc} would usually be matrix with 2 columns,
giving the start and end points of some pattern match. \cr
\cr
The \code{strcut_brk()} function
(a wrapper around \link[stringi]{stri_split_boundaries})
cuts every string into individual text breaks
(like character, word, line, or sentence boundaries). \cr
\cr
The main difference between the \code{strcut_} - functions
and \link[stringi]{stri_split} /  \link[base]{strsplit},
is that the latter generally removes the delimiter patterns in a string when cutting,
while the \code{strcut_}-functions do not attempt to remove parts of the string by default,
they only attempt to cut the strings into separate pieces.
Moreover, the \code{strcut_} - functions always return a matrix, not a list.
}
\examples{


x <- rep(paste0(1:10, collapse=""), 10)
print(x)
loc <- stri_locate_ith(x, 1:10, fixed = as.character(1:10))
strcut_loc(x, loc)
strcut_loc(x, c(5,5))
strcut_loc(x, c(NA, NA), fill_loc = TRUE)
strcut_loc(x, c(NA, NA), fill_loc = FALSE)

test <- "The\u00a0above-mentioned    features are very useful. " \%s+\%
"Spam, spam, eggs, bacon, and spam. 123 456 789"
strcut_brk(test, "line")
strcut_brk(test, "word")
strcut_brk(test, "sentence")
strcut_brk(test, "chr")
}
\seealso{
\code{\link[=tinycodet_strings]{tinycodet_strings()}}
}
