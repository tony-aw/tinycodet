% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/decimal_truth.R
\name{decimal_truth}
\alias{decimal_truth}
\alias{\%d==\%}
\alias{\%d!=\%}
\alias{\%d<\%}
\alias{\%d>\%}
\alias{\%d<=\%}
\alias{\%d>=\%}
\alias{\%d{}\%}
\alias{\%d!{}\%}
\title{Safer decimal number (in)equality testing operators}
\usage{
x \%d==\% y

x \%d!=\% y

x \%d<\% y

x \%d>\% y

x \%d<=\% y

x \%d>=\% y

x \%d{}\% bnd

x \%d!{}\% bnd
}
\arguments{
\item{x, y}{numeric vectors, matrices, or arrays.}

\item{bnd}{either a vector of length 2, or a matrix with 2 columns and 1 row,
or else a matrix with 2 columns where \code{nrow(bnd)==length(x)}. \cr
The first element/column of \code{bnd} gives the lower bound of the closed interval; \cr
The second element/column of \code{bnd} gives the upper bound of the closed interval; \cr}
}
\value{
A logical vector with the same dimensions as \code{x},
indicating the result of the element by element comparison.
}
\description{
The \code{\%d==\%, \%d!=\% \%d<\%, \%d>\%, \%d<=\%, \%d>=\%} (in)equality operator
perform decimal (class "double") number truth testing. \cr
They are virtually equivalent to the regular (in)equality operators, \cr
\code{==, !=, <, >, <=, >=}, \cr
except for two aspects. \cr
First: The decimal number (in)equality operators assume that
if the absolute difference between any two numbers
\code{x} and \code{y}
is smaller than the Machine tolerance,
\code{sqrt(.Machine$double.eps)},
then \code{x} and \code{y}
should be consider to be equal. \cr
Second: The decimal number (in)equality operators do NOT allow vector recycling.
When comparing any two numbers \code{x} and \code{y},
they must be of equal length,
or one of them must be a scalar (i.e. length of 1).
Otherwise, an error is returned. \cr
\cr

Thus these operators provide safer decimal number (in)equality tests. \cr
\cr
For example: \code{0.1*7 == 0.7} returns \code{FALSE}, even though they are equal,
due to the way decimal numbers are stored in programming languages (like R). \cr
But \code{0.1*7 \%d==\% 0.7} returns \code{TRUE}. \cr
\cr
Another example: The code \code{1:10 == c(4, 6)} is silently transformed to \code{1:10 == rep(c(4, 6), each = 5)},
and thus gives \code{c(rep(FALSE, 5), TRUE, rep(FALSE, 4))}. \cr
This may not be what the user wants.
But \code{1:10 \%d==\% c(4, 6)} prevents this by returning an error instead. \cr
\cr
There are also the \code{x \%d{}\% bnd} and \code{x \%d!{}\% bnd} operators,
where \code{bnd} is a vector of length 2,
or a 2-column matrix (\code{nrow(bnd)==length(x)} or \code{nrow(bnd)==1}). \cr
The \code{x \%d{}\% bnd} operator checks if \code{x}
is within the closed interval with bounds defined by \code{bnd}. \cr
The \code{x \%d!{}\% bnd} operator checks if \code{x}
is outside the closed interval with bounds defined by \code{bnd}. \cr
}
\examples{
x <- c(0.3, 0.6, 0.7)
y <- c(0.1*3, 0.1*6, 0.1*7)
print(x); print(y)
x == y # gives FALSE, but should be TRUE
x!= y # gives TRUE, should be FALSE
x > y # not wrong
x < y # gives TRUE, should be FALSE
x \%d==\% y # here it's done correctly
x \%d!=\% y # correct
x \%d<\% y # correct
x \%d>\% y # correct
x \%d<=\% y # correct
x \%d>=\% y # correct

x <- c(0.3, 0.6, 0.7)
bnd <- matrix(c(0.29, 0.59, 0.69, 0.31, 0.61, 0.71), ncol=2)
x \%d{}\% bnd
x \%d!{}\% bnd

# These operators still work for non-decimal number numerics also:
x <- 1:5
y <- 1:5
x \%d==\% y
x \%d!=\% y
x \%d<\% y
x \%d>\% y
x \%d<=\% y
x \%d>=\% y

x <- 1:5
y <- x+1
x \%d==\% y
x \%d!=\% y
x \%d<\% y
x \%d>\% y
x \%d<=\% y
x \%d>=\% y

x <- 1:5
y <- x-1
x \%d==\% y
x \%d!=\% y
x \%d<\% y
x \%d>\% y
x \%d<=\% y
x \%d>=\% y
}
\seealso{
\code{\link[=tinyoperations_safer]{tinyoperations_safer()}}
}
