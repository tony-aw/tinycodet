% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pkgs.R
\name{pkgs}
\alias{pkgs}
\alias{\%m import <-\%}
\alias{import_data}
\alias{import_lsf}
\alias{force_libPaths}
\title{Package import management operator and functions}
\usage{
alias \%m import <-\% pkgs

import_data(dataname, package)

import_lsf(package, inop = TRUE, regfun = TRUE)

force_libPaths(lib_vec)
}
\arguments{
\item{alias}{a variable name (unquoted),
giving the (not yet existing) object
where the package(s) are to be assigned to.}

\item{pkgs}{a character vector with the package name(s). \cr
NOTE: The order matters! If 2 packages share objects with the same name,
the package named last will overwrite the earlier named package.}

\item{dataname}{a single string, giving the name of the dataset.}

\item{package}{a single string, giving the name of the package.}

\item{inop}{\code{TRUE} or \code{FALSE},
indicating whether infix operators should be included in the list of functions.}

\item{regfun}{\code{TRUE} or \code{FALSE},
indicating whether regular functions - exlcuding infix operators -
should be included in the list of functions.}

\item{lib_vec}{a character vector giving the new library path(s). \cr
Just like in \code{.libPaths()}, the order matters: \cr
R will first look for packages in the first path in \code{.libPaths()}, \cr
and if it cannot find the package(s),
it will look for the packages in the second path in \code{.libPaths()},
etc.}
}
\value{
For \code{\%m import <-\%}: \cr
The variable named in the \code{alias} argument will be created
(if it did not already exist),
and it will contain the (merged) package environment. \cr
\cr
For \code{import_data()}: \cr
Returns the data directly.
Thus, one can assign the data like so: \code{mydata <- import_data(...)}. \cr
\cr
For \code{force_libPaths()}: \cr
Adjusts the R library paths as defined in \code{.libPaths()} directly.
}
\description{
The \code{alias \%m import <-\% pkgs} operator
imports the namespaces of an R package
(or a small set of R packages that "belong" to each other)
under the same alias. \cr
\cr
The \code{import_lsf(package, ...)} function gets a list of exported functions from a package. \cr
\cr
The \code{import_data(dataname, package)} function gets a specified data set from a package. \cr
Unlike \code{utils::data()}, \code{import_data()} returns the dataset directly,
and allows assigning the dataset like so: \cr
\code{mydata <- import_data(...)}. \cr
\cr
The \code{force_libPaths()} function allows the user to force R to specific libraries.
This was needed since base R's \code{.libPaths()} function
only allows adding new library paths, not overwrite existing ones.
The library paths are of course re-set again every time R restarts.
}
\details{
The \code{alias \%m import <-\% pkgs} command is essentially the same as \cr
\code{alias <- loadNamespace("packagename")} \cr
except the \code{alias \%m import <-\% pkgs} operator
allows assigning multiple packages to the same alias,
and this operator does not import internal functions
(i.e. internal functions are kept internal, as they should). \cr
\cr
The \code{alias \%m import <-\% pkgs} operator will tell the user
about conflicting objects. It will also inform the user when importing
a package that consists mostly of infix operators. \cr
\cr
Note: the user should not use the \code{alias \%m import <-\% pkgs} operator
unless the user knows what he/she is doing. \cr
The operator will give a warning when more than 3 packages being imported into the same alias. \cr
\cr
}
\examples{

\dontrun{
force_libPaths("/mylibrary")
fv \%m import <-\% c("data.table", "collapse", "tidytable")
d <- import_data("chicago", "gamair")
}



}
\references{
McBain (2019, June 20). Before I Sleep: Hacking R's library paths. Retrieved from https://milesmcbain.com/posts/hacking-r-library-paths/
}
