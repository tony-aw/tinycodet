% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/import_as.R
\name{import_as}
\alias{import_as}
\title{Load main package + its re-exports + its dependencies + its extensions under one alias}
\usage{
import_as(
  alias,
  main_package,
  re_exports = TRUE,
  dependencies = NULL,
  extensions = NULL,
  lib.loc = .libPaths(),
  loadorder = c("dependencies", "main_package", "extensions")
)
}
\arguments{
\item{alias}{a syntactically valid non-hidden name giving the alias object
where the package(s) are to be loaded into. \cr
This name can be given either as a single string (i.e. \code{"alias."}),
or as a one-sided formula with a single term (i.e. \code{~ alias.}). \cr
NOTE: To keep aliases easily distinguishable from other objects
that can also be subset with the \code{$} operator,
I recommend ending (not starting!) all alias names
with a dot (\code{.}) or underscore (\code{_}).}

\item{main_package}{a single string,
giving the name of the main package to load under the given alias.}

\item{re_exports}{logical;
Some R packages export functions that are not defined in their own package,
but in their direct dependencies; "re-exports", if you will. \cr
This argument determines what the \code{import_as} function
will do with the re-exports of the \code{main_package}: \cr
\itemize{
\item If \code{TRUE} the re-exports from the \code{main_package}
are added to the alias,
even if \code{dependencies = NULL}.
This is the default, as it is analogous to the behaviour of base R's \link{::} operator. \cr
\item If \code{FALSE}, these re-exports are not added,
and the user must specify the appropriate packages in argument \code{dependencies}.
}}

\item{dependencies}{an optional character vector,
giving the names of the dependencies of the
\code{main_package} to be loaded also under the alias. \cr
Defaults to \code{NULL}, which means no dependencies are loaded. \cr
See \link{pkg_get_deps} to quickly get dependencies from a package.}

\item{extensions}{an optional character vector,
giving the names of the extensions of the
\code{main_package} to be loaded also under the alias. \cr
Defaults to \code{NULL}, which means no extensions are loaded.}

\item{lib.loc}{character vector specifying library search path
(the location of R library trees to search through). \cr
The \code{lib.loc} argument would usually be \code{.libPaths()}. \cr
See also \link[base]{loadNamespace}.}

\item{loadorder}{the character vector \cr
\code{c("dependencies", "main_package", "extensions")}, \cr
or some re-ordering of this character vector,
giving the relative load order of the groups of packages. \cr
The default setting (which is highly recommended) is the character vector \cr
\code{c("dependencies", "main_package", "extensions")}, \cr
which results in the following load order: \cr
\enumerate{
\item The dependencies, \bold{in the order specified by the \code{depenencies} argument}. \cr
\item The main_package (see argument \code{main_package}),
including re-exports (if \code{re_exports=TRUE}). \cr
\item The extensions, \bold{in the order specified by the \code{extensions} argument}.
}}
}
\value{
A locked environment object, similar to the output of \link[base]{loadNamespace},
with the name as specified in the \code{alias} argument,
will be created in the current environment
(like the global environment, or the environment within a function). \cr
\cr
To use, for example, function "some_function()" from alias "alias.", use: \cr
\code{alias.$some_function()} \cr
To see the special attributes of this alias object, use \link{attr.import}. \cr
To "unload" the package alias object, simply remove it (i.e. \code{rm(list="alias.")}). \cr
}
\description{
The \code{import_as()} function
imports the namespace of an R package,
and optionally also its re-exports, dependencies, and extensions,
all under the same alias.
The specified alias will be placed in the current environment
(like the global environment, or the environment within a function). \cr
}
\details{
\bold{On the \code{dependencies} and \code{extensions} arguments} \cr
\itemize{
\item \code{dependencies}: "Dependencies" here are defined as any package appearing in the
"Depends", "Imports", or "LinkingTo" fields of the Description file of the
\code{main_package}. So no recursive dependencies.
\item \code{extensions}: "Extensions" here are defined as reverse-depends or reverse-imports.
It does not matter if these are CRAN or non-CRAN packages.
However, the intended meaning of an extension is not merely being a reverse dependency,
but a package that actually extends the functionality of the \code{main_package}.
}

As implied in the description of the \code{loadorder} argument,
the order of the character vectors given in the
\code{dependencies}, and \code{extensions} arguments
matter: \cr
If multiple packages share objects with the same name,
the objects of the package named last will overwrite those of the earlier named packages. \cr
\cr
\cr
\bold{Additional details} \cr
The \code{import_as()} function
does not support loading base/core R under an alias. \cr
\cr
}
\examples{
\dontrun{
import_as( # this creates the 'tdt.' object
  "tdt.", "tidytable", dependencies = "data.table"
)
# same as:
import_as(
  ~ tdt., "tidytable", dependencies = "data.table"
)
# using a function from the alias:
tdt.$mutate
}


}
\seealso{
\code{\link[=tinyoperations_import]{tinyoperations_import()}}
}
