% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/import_as.R
\name{import_as}
\alias{import_as}
\title{Load R-package and its Re-exports and/or its (Reverse) Dependencies Under a Single Alias}
\usage{
import_as(
  alias,
  main_package,
  re_exports = TRUE,
  dependencies = NULL,
  extensions = NULL,
  lib.loc = .libPaths(),
  loadorder = c("dependencies", "main_package", "extensions")
)
}
\arguments{
\item{alias}{a syntactically valid non-hidden name giving the alias object
where the package(s) are to be loaded into. \cr
This name can be given either as a single string (i.e. \code{"alias."}),
or as a one-sided formula with a single term (i.e. \code{~ alias.}). \cr
NOTE: To keep aliases easily distinguishable from other objects
that can also be subset with the \code{$} operator,
I recommend ending (not starting!) all alias names
with a dot (\code{.}) or underscore (\code{_}).}

\item{main_package}{a single string,
giving the name of the main package to load under the given alias.}

\item{re_exports}{logical;
Some R-packages export functions that are not defined in their own package,
but in their direct dependencies; "re-exports", if you will. \cr
\itemize{
\item If \code{re_exports = TRUE} the re-exports from the \code{main_package}
are added to the alias together with the main package.
This is the default, as it is analogous to the behaviour of base R's \link{::} operator. \cr
\item If \code{re_exports = FALSE}, these re-exports are not added together with the main package.
The user can still specify the appropriate packages in argument \code{dependencies}.
}}

\item{dependencies}{an optional character vector,
giving the names of the dependencies of the
\code{main_package} to be loaded also under the alias. \cr
Defaults to \code{NULL}, which means no dependencies are loaded. \cr
See \link{pkg_get_deps} to quickly get dependencies from a package. \cr
NOTE: The order of the given character vector matters.
If multiple packages share objects with the same name,
the objects of the package named last will overwrite those of the earlier named packages.}

\item{extensions}{an optional character vector,
giving the names of the extensions of the
\code{main_package} to be loaded also under the alias. \cr
Defaults to \code{NULL}, which means no extensions are loaded. \cr
NOTE: The order of the given character vector matters.
If multiple packages share objects with the same name,
the objects of the package named last will overwrite those of the earlier named packages.}

\item{lib.loc}{character vector specifying library search path
(the location of R library trees to search through). \cr
The \code{lib.loc} argument would usually be \code{.libPaths()}. \cr
See also \link[base]{loadNamespace}.}

\item{loadorder}{the character vector \cr
\code{c("dependencies", "main_package", "extensions")}, \cr
or some re-ordering of this character vector,
giving the relative load order of the groups of packages. \cr
See Details section for more information. \cr}
}
\value{
A locked environment object, similar to the output of \link[base]{loadNamespace},
with the name as specified in the \code{alias} argument,
will be created in the current environment
(like the global environment, or the environment within a function). \cr
\cr
To use, for example, function "some_function()" from alias "alias.", use: \cr
\code{alias.$some_function()} \cr
To see the special attributes of this alias object, use \link{attr.import}. \cr
To "unload" the package alias object, simply remove it (i.e. \code{rm(list="alias.")}). \cr
}
\description{
The \code{import_as()} function
imports the namespace of an R-package,
and optionally also its re-exports, dependencies, and extensions,
all under the same alias.
The specified alias will be placed in the current environment
(like the global environment, or the environment within a function). \cr
}
\details{
\bold{On the \code{loadorder} argument} \cr
The default setting of the \code{loadorder} argument
(which is highly recommended)
is the character vector \cr
\code{c("dependencies", "main_package", "extensions")}, \cr
which results in the following load order: \cr
\enumerate{
\item The dependencies, \bold{in the order specified by the \code{depenencies} argument}. \cr
\item The main_package (see argument \code{main_package}),
including re-exports (if \code{re_exports=TRUE}). \cr
\item The extensions, \bold{in the order specified by the \code{extensions} argument}. \cr
}

\bold{On the \code{dependencies} and \code{extensions} arguments} \cr
\itemize{
\item \code{dependencies}: "Dependencies" here are defined as any package appearing in the
"Depends", "Imports", or "LinkingTo" fields of the Description file of the
\code{main_package}. So no recursive dependencies.
\item \code{extensions}: "Extensions" here are defined as
direct reverse-depends or direct reverse-imports.
It does not matter if these are CRAN or non-CRAN packages.
However, the intended meaning of an extension is not merely being a reverse dependency,
but a package that actually extends the functionality of the \code{main_package}. \cr
}

\bold{Additional details} \cr
The \code{import_as()} function
does not support loading base/core R under an alias. \cr
\cr
}
\examples{

check <- all(c("tidytable", "data.table", "magrittr", "dplyr") \%installed in\% .libPaths())

if(check) import_as( # this creates the 'tdt.' object
  "tdt.", "tidytable", dependencies = "data.table"
)
# same as:
if(check) import_as(
  ~ tdt., "tidytable", dependencies = "data.table"
)


# exposing infix operators from "magrrittr" to current environment:
if(check) import_inops("magrittr")

# directly assigning dplyr's "starwars" dataset to object "d":
if(check) d <- import_data("dplyr", "starwars")

# see it in action:
if(check) d \%>\% tdt.$filter(species == "Droid") \%>\%
  tdt.$select(name, tdt.$ends_with("color"))



}
\seealso{
\code{\link[=tinycodet_import]{tinycodet_import()}}
}
