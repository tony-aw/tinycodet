% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/logic_ops.R
\name{logic_ops}
\alias{logic_ops}
\alias{\%xor\%}
\alias{\%n&\%}
\alias{\%out\%}
\alias{\%?=\%}
\alias{\%sgrep\%}
\alias{\%=numtype\%}
\alias{\%=strtype\%}
\title{Logic operators}
\usage{
x \%xor\% y

x \%n&\% y

x \%out\% y

x \%?=\% y

s \%sgrep\% p

n \%=numtype\% numtype

s \%=strtype\% strtype
}
\arguments{
\item{x, y}{see \link[base]{Logic}.}

\item{s}{a character vector.}

\item{p}{the result from \link{s_pattern},
or else a character vector of the same length as \code{s} with regular expressions.}

\item{n}{a numeric vector.}

\item{numtype}{a single string giving the type if numeric to be checked.
The following options are supported: \cr
\itemize{
\item \code{"~0"}: zero, or else a number whose absolute value is smaller than the
Machine tolerance (\code{sqrt(.Machine$double.eps)}). \cr
\item \code{"B"}: binary numbers (exactly 0 or exactly 1); \cr
\item \code{"prop"}: proportions - numbers between 0 and 1 (exactly 0 or 1 is also allowed); \cr
\item \code{"I"}: Integers; \cr
\item \code{"odd"}: odd integers; \cr
\item \code{"even"}: even integers; \cr
\item \code{"R"}: Real numbers; \cr
\item \code{"unreal"}: infinity, NA, or NaN; \cr
}}

\item{strtype}{a single string giving the type of string to be checked.
The following options are supported: \cr
\itemize{
\item \code{"empty"}: checks if the string only consists of empty spaces. \cr
\item \code{"unreal"}: checks if the string is NA, or if it has literal string "NA", "NaN" or "Inf",
regardless if it has leading or trailing spaces. \cr
\item \code{"numeric"}: checks if the string can be converted to a number,
disregarding leading and trailing spaces.
I.e. the string "5.0" can be converted to the the actual number \code{5.0}. \cr
\item \code{"special"}: checks if the string consists of only special characters. \cr
}}
}
\description{
Additional logic operators: \cr
\cr
The \code{x \%xor\% y} operator is the "exclusive-or" operator, the same as \code{xor(x, y)}. \cr
\cr
The \code{x \%n&\%} operator is the "not-and" operator, the same as \code{(!x) & (!y)}. \cr
\cr
The \code{x \%out\% y} operator is the same as \code{!x \%in\% y}. \cr
\cr
The \code{x \%?=\% y} operator checks if \code{x} and \code{y}
are \strong{both} unreal or unknown (i.e. NA, NaN, Inf, -Inf). \cr
\cr
The \code{n \%=numtype\% numtype} operator is a vectorized operator that checks
for every value of numeric vector \code{n}
if it can be considered a number belonging to type \code{numtype}.
See arguments for details. \cr
\cr
The \code{s \%=strtype\% strtype} operator is a vectorized operator that checks
for every value of character vector \code{s} \cr
if it can seen as a certain \code{strtype}. See arguments for details. \cr
\cr
The \code{s \%sgrep\% p} operator is a vectorized operator that checks
for every value of character vector \code{s} if it has pattern \code{p}.
}
\examples{
x <- c(TRUE, FALSE, TRUE, FALSE, NA, NaN, Inf, -Inf, TRUE, FALSE)
y <- c(FALSE, TRUE, TRUE, FALSE, rep(NA, 6))
outcome <- data.frame(
  x=x, y=y,
  "x \%xor\% y"=x \%xor\% y, "x \%n&\% y" = x \%n&\% y, "x \%?=\% y" = x \%?=\% y,
  check.names = FALSE
)
print(outcome)

1:3 \%out\% 1:10
1:10 \%out\% 1:3


n <- c(0:5, 0:-5, 0.1, -0.1, 0, 1, Inf, -Inf, NA, NaN)
1e-20 \%=numtype\% "~0"
n[n \%=numtype\% "B"]
n[n \%=numtype\% "prop"]
n[n \%=numtype\% "I"]
n[n \%=numtype\% "odd"]
n[n \%=numtype\% "even"]
n[n \%=numtype\% "R"]
n[n \%=numtype\% "unreal"]

s <- c(" AbcZ123 ", " abc ", " 1.3 ", " !#$\%^&*() ", "  ", "  NA  ", "  NaN  ", " Inf ")
s[s \%=strtype\% "empty"]
s[s \%=strtype\% "unreal"]
s[s \%=strtype\% "numeric"]
s[s \%=strtype\% "special"]


s <- c("Hello world", "Goodbye world")
p <- s_pattern(regex = c("Hello", "Hello"))
s \%sgrep\% p

}
