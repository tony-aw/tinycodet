% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tinyoperators_help.R,
%   R/tinyoperators_importsystem.R
\name{tinyoperators_help}
\alias{tinyoperators_help}
\alias{tinyoperators_importsystem}
\title{The tinyoperators help page}
\usage{
tinyoperators_help()

tinyoperators_importsystem()
}
\description{
Welcome to the \code{tinyoperators} help page! \cr
\cr
The 'tinyoperators' R-package adds some much needed infix operators,
and a few functions, to make your R code much more tiny.
It includes infix operators for additional logic operators,
safer float (in)equality operators,
and infix operators for custom row- and column-wise ordering of matrices.
It also adds some stringi-based string related functions and operators.
It also adds operators and a few functions to help reduce unnecessary repetitive code.
And finally, it also adds some functions and an operator for easier package/library management.
The 'tinyoperators' R-package has only one dependency, namely 'stringi',
though it does allows multi-threading of some of the string-related functions
(when appropriate)
via the suggested 'stringfish' R-package. \cr
\cr

The \code{tinyoperators} R package adds the following functionality: \cr
\cr
\itemize{
\item \link[=\%xor\%]{Infix logical operators} for exclusive-or, not-and, not-in, number-type, and string-type. \cr
\item \link[=\%f==\%]{Safer (in)equality operators for floating numbers}. \cr
\item Infix operators for \link[=\%s+\%]{string arithmetic}. \cr
\item Infix operators for \link[=\%ss\%]{string sub-setting}. \cr
\item Several operators for the "Don't Repeat Yourself" coding principle (\code{DRY}).
This includes the \link[=\%:=\%]{generalized in-place (mathematical) modification operator},
infix operators for \link[=\%s+ =\%]{In-place modifying string arithmetic},
and infix operators for \link[=\%sget =\%]{In-place modifying string sub-setting}. \cr
\item \link[=\%row~\%]{Infix operators for row- and column-wise re-ordering of matrices}. \cr
\item The \code{tinyoperators} package adds additional
\code{stringi} functions, namely \link{stri_locate_ith} and
\link{stri_join_mat} (and aliases).
These functions use the same naming and argument convention as the rest of
the \code{stringi} functions, thus keeping your code consistent. \cr
\item The fully vectorized \link[=substr_repl]{sub-string functions},
that extract, replace, add-in, transform, or re-arrange,
the \eqn{i^{th}} pattern occurrence or location. \cr
\item The \link{s_pattern} helper function for string operators. \cr
\item \link[=import_data]{New package import functions},
and \link[=source_inops]{new module sourcing functions}. \cr
\item Most \code{stringi} pattern expressions options
are available for the string-pattern-related functions, when appropriate. \cr
\item This R package has only one dependency: \code{stringi}.
No other dependencies, as to avoid \code{"dependency hell"}. \cr
\item Although this package has no other dependencies,
it allows multi-threading of the sub-string functions
through the \code{stringfish} R package. \cr
\cr
}

Please also have a look at the Read-Me file on the Github main page before using this package: \cr
\url{https://github.com/tony-aw/tinyoperators}

Attaching a package necessarily loads a package,
but loading a package does not entail attaching a package. \cr
\cr
Whenever a package is used in any way,
even internally by a function,
a package is \strong{loaded}.
A loaded package is simply a package that R is prepared to use.
A package that is loaded is not necessarily attached.
But \strong{attaching} package is what happens when one uses
the \code{library}() or \code{require}() function: \cr
the functions from the package are exposed to the namespace. \cr
Exposing functions to the namespace is
\strong{not a necessity},
it is merely a \strong{convenience}. \cr
\cr
Without attaching a package,
there are basically 2 ways to use functions from a package: \cr
\itemize{
\item Using the \code{::} operator, like so: \code{package_name::function_name()}. \cr
\item If a package name is very long, the \code{::} approach may eventually become annoying.
So alternatively, one can use an abbreviated \code{alias}, like so: \code{alias <- loadNamespace("packagename")};
then one can use \code{alias$function_name()}, instead of the longer \code{package_name::function_name()}. \cr
}

The advantages of attaching a package instead are as follows:
\enumerate{
\item \strong{Less typing}:
You have to type less to use functions. This is especially handy for \strong{infix operators} - which \code{tinyoperators} obviously focuses on - as operators use special characters, which require them to be surrounded by back-ticks when using \code{::} or \verb{alias$}. \cr
\item \strong{More collective usage}:
If multiple packages are meant to work together, constantly switching between the different package name/alias prefixes may eventually become annoying and even syntactically chaotic-looking. By attaching the packages, you no longer have to deal with this annoyance. \cr
}

But, attaching many packages willy-nilly has a few potentially serious drawbacks:
\enumerate{
\item \strong{masking namespaces}: functions from different packages that have the same function names will mask each other.
\item \strong{overloading core R functions}: some R packages overload core R functions. This is not always wanted (or even expected) from the user. Using \code{::} or a package alias will allow one to explicitly choose whether to use the original R function, or the package function.
\item \strong{lack of code clarity}: The absence of a package name or alias prefix at function calls makes it less clear from which package which function came. This will be compounded when an R package overloads core R functions. If something goes wrong in a script, one has to figure out from which package a function came from, in order to figure out the cause of the issue. The lack of a package name or alias prefix makes this more cumbersome.
\item \strong{global assignment}: Unlike aliases, which exist \strong{locally}, when packages are attached, they are attached \strong{globally}. Using \code{library()} inside a function will thus not merely attach the package inside the function, but attach it globally, which may worsen the previously named problems when a function silently attaches a package.
\item \strong{Polluting your namespace}: The more packages one attaches, the greater the chance for bugs caused by masked namespaces, and the greater the difficulty in de-bugging your code due to the aforementioned lack of syntactical clarity.
}

Some programming languages don't even allow attaching packages, because of these issues.

I do see the advantages of attaching a package - especially when it comes to using \verb{infix operators}. But the disadvantages of attaching a package cannot just be ignored. So what \code{tinyoperators} attempts to do with the functions described in this section, is to somewhat find the best of both worlds. Basically, \code{tinyoperators} has functions that allow the following functionality lacking in base R:
\itemize{
\item Allow \strong{multiple related} packages to be loaded under \strong{one alias}. This essentially combines the advantages of "collective usage" (see attaching advantage number 2), whilst keeping most advantages of only loading a package under an alias.
\item Allow \strong{exposing} of infix operators to the \strong{current environment}. This gains advantages "less typing" whilst simultaneously avoiding the disadvantage of "global assignment".
}

Moreover, \code{tinyoperators} extends this functionality to also work on \strong{sourced modules}.
}
