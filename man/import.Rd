% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/import.R
\name{import}
\alias{import}
\alias{import_as}
\alias{import_inops}
\alias{import_data}
\alias{import_lsf}
\title{Additional package import management}
\usage{
import_as(
  alias,
  main_package,
  depends = FALSE,
  enhances = NULL,
  extends = NULL,
  loadorder = c("depends", "main_package", "enhances", "extends"),
  lib.loc = .libPaths()
)

import_inops(pkgs, lib.loc = .libPaths(), exclude, include.only)

import_data(dataname, package, lib.loc = .libPaths())

import_lsf(package, type, lib.loc = .libPaths())
}
\arguments{
\item{alias}{a variable name (unquoted),
giving the (not yet existing) object
where the package(s) are to be assigned to. \cr
Syntactically invalid names are not allowed for the alias name.}

\item{main_package}{a single string, giving the name of the main package to load under the given alias.}

\item{depends}{either logical, or a character vector. \cr
If \code{FALSE} (default), no dependencies are loaded under the alias. \cr
If \code{TRUE}, ALL dependencies of the \code{main_package} are loaded under the alias,
but \bold{excluding} core/base R packages,
and also \bold{excluding} pre-installed "recommended" R packages.
See also \link{pkgs_get_deps} \cr
If a character vector, then it is taken as the dependencies of the
package to be loaded also under the alias. \cr
NOTE (1): "Dependencies" here are defined as any package appearing in the
"Depends", "Imports", or "LinkingTo" sections of the Description file of the
\code{main_package}. \cr
NOTE (2): If \code{depends} is a character vector:
The order of the character vector matters!
If multiple packages share objects with the same name,
the package named last will overwrite the earlier named packages. \cr}

\item{enhances}{a character vector,
giving the names of the packages enhanced by the
\code{main_package} to be loaded also under the alias. \cr
NOTE(1): Enhances are defined as packages appearing in the "Enhances" section
of the Description file of the \code{main_package}. \cr
NOTE (2): The order of the character vector matters!
If multiple packages share objects with the same name,
the objects of the package named last will overwrite those of the earlier named packages. \cr}

\item{extends}{a character vector,
giving the names of the extensions / reverse-dependencies of the
\code{main_package} to be loaded also under the alias.
Defaults to \code{NULL}, which means no extensions are loaded. \cr
NOTE (1): "Extensions" here are defined as reverse-depends or reverse-imports.
It does not matter if these are CRAN or non-CRAN packages. \cr
NOTE (2): The order of the character vector matters!
If multiple packages share objects with the same name,
the objects of the package named last will overwrite those of the earlier named packages. \cr}

\item{loadorder}{the character vector \cr
\code{c("depends", "main_package", "enhances", "extends")}, \cr
or some re-ordering of this character vector,
giving the relative load order of the groups of packages. \cr
By default this is the character vector \cr
\code{c("depends", "main_package", "enhances", "extends")}.}

\item{lib.loc}{character vector specifying library search path
(the location of R library trees to search through).
This is usually \code{.libPaths()}.
See also \link[base]{loadNamespace}.}

\item{pkgs}{a single string, or character vector, with the package name(s). \cr
NOTE (1): The order of the character vector matters!
If multiple packages share objects with the same name,
the objects of the package named last will overwrite those of the earlier named packages. \cr
NOTE (2): The \code{import_inops} function performs a basic check
that the packages are mostly (reverse) dependencies of each other.
If not, it will give an error.}

\item{exclude}{a character vector,
giving the infix operators NOT to expose to the current environment. \cr
This can be handy to prevent overwriting any (user defined)
infix operators already present in the current environment. \cr
NOTE: You cannot specify both the \code{exclude} and \code{include.only} arguments.
Only one or the other, or neither.}

\item{include.only}{a character vector,
giving the infix operators to expose to the current environment,
and the rest of the operators will not be exposed. \cr
This can be handy to prevent overwriting any (user defined)
infix operators already present in the current environment. \cr
NOTE: You cannot specify both the \code{exclude} and \code{include.only} arguments.
Only one or the other, or neither.}

\item{dataname}{a single string, giving the name of the data set.}

\item{package}{the quoted package name.}

\item{type}{The type of functions to list. Possibilities: \cr
\code{"inops"} or \code{"operators"}: Only infix operators. \cr
\code{"regfuns"}: Only regular functions (thus excluding infix operators). \cr
\code{"all"}: All functions, both regular functions and infix operators. \cr}
}
\value{
For \code{import_as}: \cr
The variable named in the \code{alias} argument will be created
(if it did not already exist),
in the current environment
(like the global environment, or the environment within a function).
The alias object will contain the (merged) package environment. \cr
\cr
For \code{import_inops()}: \cr
The infix operators from the specified packages will be placed
in the current environment
(like the Global environment, or the environment within a function).\cr
\cr
For \code{import_data()}: \cr
Returns the data directly.
Thus, one can assign the data like so: \code{mydata <- import_data(...)}. \cr
\cr
For \code{import_lsf()}: \cr
Returns a character vector of function and/or operator names. \cr
\cr
}
\description{
These functions implement a new package import system,
that attempts to combine the benefits of aliasing a package with the benefits of attaching a package. \cr
\cr
\code{import_as}: \cr
The \code{import_as()} function
imports the namespace of an R package,
and optionally also its dependencies, enhances, and extensions,
under the same alias.
The specified alias will be placed in the current environment
(like the global environment, or the environment within a function). \cr
\cr
\code{import_inops}: \cr
The \code{import_inops()} function
exposes the infix operators of the specified packages to the current environment
(like the global environment, or the environment within a function). \cr
To ensure the user can still verify which operator function came from which package,
a "package" attribute is added to each exposed operator. \cr
Naturally, the namespaces of the operators remain intact. \cr
\cr
\code{import_data}: \cr
The \code{import_data()} function gets a specified data set from a package. \cr
Unlike \code{utils::data()}, the \code{import_data()} function returns the data set directly,
and allows assigning the data set like so: \cr
\code{mydata <- import_data(...)}. \cr
\cr
\code{import_lsf}: \cr
The \code{import_lsf(package, ...)} function gets a list of exported functions/operators from a package. \cr
\cr
}
\details{
Regarding "
For a more detailed description of the import system introduced by the
\code{tinyoperators} R package,
please refer to the Read Me file on the GitHub main page: \cr
\url{https://github.com/tony-aw/tinyoperators} \cr
}
\examples{

\dontrun{
depends <- unlist(tools::package_dependencies("devtools"))
pkgs <- c(depends, "devtools")
import_as(devt, "devtools", depends = TRUE) # this creates the devt object
import_inops(pkgs)
d <- import_data("chicago", "gamair")
head(d)
}



}
