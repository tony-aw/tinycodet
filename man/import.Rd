% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/import.R
\name{import}
\alias{import}
\alias{import_as}
\alias{import_inops}
\alias{import_data}
\alias{import_lsf}
\title{Additional package import management}
\usage{
import_as(
  alias,
  main_package,
  depends = FALSE,
  enhances = FALSE,
  extends = NULL,
  lib.loc = .libPaths()
)

import_inops(pkgs, lib.loc = .libPaths(), exclude, include.only)

import_data(dataname, package, lib.loc = .libPaths())

import_lsf(package, type, lib.loc = .libPaths())
}
\arguments{
\item{alias}{a variable name (unquoted),
giving the (not yet existing) object
where the package(s) are to be assigned to. \cr
Syntactically invalid names are not allowed for the alias name.}

\item{main_package}{a single string, giving the name of the main package to load under the given alias.}

\item{depends}{either logical, or a character vector. \cr
If \code{FALSE} (default), no dependencies are loaded under the alias. \cr
If \code{TRUE}, ALL dependencies of the \code{main_package} are loaded under the alias. \cr
If a character vector, then it is taken as the dependencies of the
package to be loaded also under the alias. \cr
NOTE (1): "Dependencies" here are defined as any package appearing in the
"Depends", "Imports", or "LinkingTo" sections of the Description file of the
\code{main_package}. \cr
NOTE (2): If \code{depends} is a character vector:
The order of the character vector matters!
If multiple packages share objects with the same name,
the package named last will overwrite the earlier named package. \cr}

\item{enhances}{either logical, or a character vector. \cr
If \code{FALSE} (default), no enhances are loaded under the alias. \cr
If \code{TRUE}, ALL "Enhances" packages are loaded under the alias. \cr
If a character vector, then it is taken as the list of enhanced packages
to be loaded also under the alias. \cr
NOTE(1): Enhances are defined as packages appearing in the "Enhances" section
of the Description file of the \code{main_package}. \cr
NOTE (2): The order of the character vector matters!
If multiple packages share objects with the same name,
the package named last will overwrite the earlier named package. \cr}

\item{extends}{a character vector,
giving the names of the reverse-dependencies of the
\code{main_package} to be loaded also under the alias.
Defaults to \code{NULL}, which means no extensions are loaded. \cr
NOTE (1): "Extensions" here are defined as reverse-depends or reverse-imports.
It does not matter if these are CRAN or non-CRAN packages. \cr
NOTE (2): The order of the character vector matters!
If multiple packages share objects with the same name,
the package named last will overwrite the earlier named package. \cr}

\item{lib.loc}{character vector specifying library search path
(the location of R library trees to search through).
This is usually \code{.libPaths()}.
See also \link[base]{loadNamespace}.}

\item{pkgs}{a single string, or character vector, with the package name(s). \cr
NOTE (1): The order of the character vector matters!
If multiple packages share objects with the same name,
the package named last will overwrite the earlier named package. \cr
NOTE (2): The \code{import_inops} function performs a basic check
that the packages are mostly (reverse) dependencies of each other.
If not, it will give an error.}

\item{exclude}{a character vector,
giving the infix operators NOT to expose to the current environment. \cr
This can be handy to prevent overwriting any (user defined)
infix operators already present in the current environment. \cr
NOTE: You cannot specify both the \code{exclude} and \code{include.only} arguments.
Only one or the other, or neither.}

\item{include.only}{a character vector,
giving the infix operators to expose to the current environment,
and the rest of the operators will not be exposed. \cr
This can be handy to prevent overwriting any (user defined)
infix operators already present in the current environment. \cr
NOTE: You cannot specify both the \code{exclude} and \code{include.only} arguments.
Only one or the other, or neither.}

\item{dataname}{a single string, giving the name of the data set.}

\item{package}{the quoted package name.}

\item{type}{The type of functions to list. Possibilities: \cr
\code{"inops"} or \code{"operators"}: Only infix operators. \cr
\code{"regfuns"}: Only regular functions (thus excluding infix operators). \cr
\code{"all"}: All functions, both regular functions and infix operators. \cr}
}
\value{
For \code{import_as}: \cr
The variable named in the \code{alias} argument will be created
(if it did not already exist),
and it will contain the (merged) package environment. \cr
\cr
For \code{import_inops()}: \cr
The infix operators from the specified packages will be placed
in the current environment
(like the Global environment, or the environment within a function).\cr
\cr
For \code{import_data()}: \cr
Returns the data directly.
Thus, one can assign the data like so: \code{mydata <- import_data(...)}. \cr
\cr
For \code{import_lsf()}: \cr
Returns a character vector of function and/or operator names. \cr
\cr
}
\description{
These functions and operator are focused on making it easier to
use packages without having to explicitly attaching them to your namespace. \cr
\cr
\code{import_as}: \cr
The \code{import_as()} function
imports the namespace of an R package,
and optionally also its dependencies, enhances, and extensions,
under the same alias. \cr
\cr
\code{import_inops}: \cr
The \code{import_inops()} function
exposes the infix operators of the specified packages to the current environment
(like the global environment, or the environment within a function). \cr
To ensure the user can still verify which operator function came from which package,
a "package" attribute is added to each exposed operator. \cr
Naturally, the namespaces of the operators remain intact. \cr
\cr
\code{import_data}: \cr
The \code{import_data()} function gets a specified data set from a package. \cr
Unlike \code{utils::data()}, the \code{import_data()} function returns the data set directly,
and allows assigning the data set like so: \cr
\code{mydata <- import_data(...)}. \cr
\cr
\code{import_lsf}: \cr
The \code{import_lsf(package, ...)} function gets a list of exported functions/operators from a package. \cr
\cr
}
\details{
In general: \cr
The \code{import_as} and \code{import_inops} functions will inform the user
about conflicting objects. \cr
\cr
For \code{import_as()}: \cr
The \code{import_as()} function will load the packages in the following order: \cr
(1) \code{depends}, (2) \code{main_package}, (3) \code{enhances}, (4) \code{extends}. \cr
Note that suggested packages are not included in the \code{import_as()} function.
The \code{import_as()} function does not import internal functions
(i.e. internal functions are kept internal, as they should). \cr
\cr
For \code{import_inops()}: \cr
The \code{import_inops()} function is less strict than \code{import_as()}
in terms of which R packages can be called together.
But still the packages specified in argument \code{pkgs} need to have SOME
overlap in their dependencies. \cr
\cr
}
\examples{

\dontrun{
depends <- unlist(tools::package_dependencies("devtools"))
pkgs <- c(depends, "devtools")
import_as(devt, "devtools", depends = TRUE) # this creates the devt object
import_inops(pkgs)
d <- import_data("chicago", "gamair")
head(d)
}



}
