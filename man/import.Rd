% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/import.R
\name{import}
\alias{import}
\alias{import_as}
\alias{import_inops}
\alias{import_data}
\alias{import_lsf}
\title{Additional package import management}
\usage{
import_as(
  alias,
  main_package,
  foreign_exports = TRUE,
  dependencies = FALSE,
  enhances = NULL,
  extensions = NULL,
  lib.loc = .libPaths(),
  loadorder = c("dependencies", "main_package", "enhances", "extensions")
)

import_inops(pkgs, lib.loc = .libPaths(), exclude, include.only)

import_data(dataname, package, lib.loc = .libPaths())

import_lsf(package, type, lib.loc = .libPaths())
}
\arguments{
\item{alias}{a syntactically valid non-hidden variable name (unquoted),
giving the alias object
where the package(s) are to be loaded into. \cr
\cr
NOTE: To keep aliases easily distinguished from other objects
that can also be subset with the \code{$} operator,
I recommend ending (not starting!) the names of all alias names
with a dot (\code{.}) or underscore (\code{_}). \cr}

\item{main_package}{a single string,
giving the name of the main package to load under the given alias.}

\item{foreign_exports}{logical. \cr
Some R packages export functions that are  not defined in their own package,
but in their direct dependencies; "foreign exports", if you will. \cr
If \code{foreign_exports = TRUE} these foreign exports are added to the alias
(even if \code{dependencies = FALSE}). \cr
If \code{foreign_exports = FALSE}, these foreign exports are not added,
and the user must specify the appropriate packages in argument \code{dependencies}. \cr
Defaults to \code{TRUE}, which is analogous to the behaviour of base R's \link{::} operator.}

\item{dependencies}{either logical, or a character vector. \cr
If \code{FALSE} (default), no dependencies are loaded under the alias. \cr
If \code{TRUE}, ALL direct dependencies of the \code{main_package} are loaded under the alias,
but \bold{excluding} base/core R,
and also \bold{excluding} pre-installed "recommended" R packages. \cr
See also \link{pkgs_get_deps}. \cr
If a character vector, then it is taken as the direct dependencies of the
package to be loaded also under the alias. \cr
\cr
NOTE (1): "Dependencies" here are defined as any package appearing in the
"Depends", "Imports", or "LinkingTo" sections of the Description file of the
\code{main_package}. So no recursive dependencies. \cr
NOTE (2): If \code{dependencies} is a character vector:
The order of the character vector matters!
If multiple packages share objects with the same name,
the package named last will overwrite the earlier named packages. \cr}

\item{enhances}{an optional character vector,
giving the names of the packages enhanced by the
\code{main_package} to be loaded also under the alias. \cr
Defaults to \code{NULL}, which means no enhances are loaded. \cr
\cr
NOTE (1): Enhances are defined as packages appearing in the "Enhances" section
of the Description file of the \code{main_package}. \cr
NOTE (2): The order of the character vector matters!
If multiple packages share objects with the same name,
the objects of the package named last will overwrite those of the earlier named packages. \cr}

\item{extensions}{an optional character vector,
giving the names of the extensions / reverse-dependencies of the
\code{main_package} to be loaded also under the alias. \cr
Defaults to \code{NULL}, which means no extensions are loaded. \cr
\cr
NOTE (1): "Extensions" here are defined as reverse-depends or reverse-imports.
It does not matter if these are CRAN or non-CRAN packages. \cr
NOTE (2): The order of the character vector matters!
If multiple packages share objects with the same name,
the objects of the package named last will overwrite those of the earlier named packages. \cr}

\item{lib.loc}{character vector specifying library search path
(the location of R library trees to search through). \cr
This is usually \code{.libPaths()}. \cr
See also \link[base]{loadNamespace}.}

\item{loadorder}{the character vector \cr
\code{c("dependencies", "main_package", "enhances", "extensions")}, \cr
or some re-ordering of this character vector,
giving the relative load order of the groups of packages. \cr
\cr
The default setting (which is highly recommended) is the character vector \cr
\code{c("dependencies", "main_package", "enhances", "extensions")}, \cr
which results in the following load order: \cr
(1) The dependencies, in the order specified by the \code{depenencies} argument. \cr
(2) The main_package (see argument \code{main_package}),
including foreign exports (if \code{foreign_exports=TRUE}). \cr
(3) The enhances, in the order specified by the \code{enhances} argument. \cr
(4) The reverse-dependencies/extensions, in the order specified by the \code{extensions} argument. \cr}

\item{pkgs}{a single string, or character vector, with the package name(s). \cr
\cr
NOTE (1): The order of the character vector matters!
If multiple packages share objects with the same name,
the objects of the package named last will overwrite those of the earlier named packages. \cr
NOTE (2): The \code{import_inops} function performs a basic check
that the packages are mostly (reverse) dependencies of each other.
If not, it will give an error.}

\item{exclude}{a character vector,
giving the infix operators NOT to expose to the current environment. \cr
This can be handy to prevent overwriting any (user defined)
infix operators already present in the current environment. \cr
\cr
NOTE: You cannot specify both the \code{exclude} and \code{include.only} arguments.
Only one or the other, or neither.}

\item{include.only}{a character vector,
giving the infix operators to expose to the current environment,
and the rest of the operators will not be exposed. \cr
This can be handy to prevent overwriting any (user defined)
infix operators already present in the current environment. \cr
\cr
NOTE: You cannot specify both the \code{exclude} and \code{include.only} arguments.
Only one or the other, or neither.}

\item{dataname}{a single string, giving the name of the data set.}

\item{package}{the quoted package name.}

\item{type}{The type of functions to list. Possibilities: \cr
\code{"inops"} or \code{"operators"}: Only infix operators. \cr
\code{"regfuns"}: Only regular functions (thus excluding infix operators). \cr
\code{"all"}: All functions, both regular functions and infix operators. \cr}
}
\value{
For \code{import_as}: \cr
The variable named in the \code{alias} argument will be created
in the current environment
(like the global environment, or the environment within a function).
The alias object will contain the (merged) package environment.
If the object already existed, an error is returned. \cr
\cr
For \code{import_inops()}: \cr
The infix operators from the specified packages will be placed
in the current environment
(like the Global environment, or the environment within a function).\cr
\cr
For \code{import_data()}: \cr
Returns the data directly.
Thus, one can assign the data like so: \code{mydata <- import_data(...)}. \cr
\cr
For \code{import_lsf()}: \cr
Returns a character vector of function and/or operator names. \cr
\cr
}
\description{
These functions implement a new package import system,
that attempts to combine the benefits of aliasing a package with the benefits of attaching a package. \cr
\cr
\code{import_as}: \cr
The \code{import_as()} function
imports the namespace of an R package,
and optionally also its dependencies, enhances, and extensions,
under the same alias.
The specified alias will be placed in the current environment
(like the global environment, or the environment within a function). \cr
\cr
\code{import_inops}: \cr
The \code{import_inops()} function
exposes the infix operators of the specified packages to the current environment
(like the global environment, or the environment within a function). \cr
To ensure the user can still verify which operator function came from which package,
a "package" attribute is added to each exposed operator. \cr
Naturally, the namespaces of the operators remain intact. \cr
\cr
\code{import_data}: \cr
The \code{import_data()} function gets a specified data set from a package. \cr
Unlike \code{utils::data()}, the \code{import_data()} function returns the data set directly,
and allows assigning the data set like so: \cr
\code{mydata <- import_data(...)}. \cr
\cr
\code{import_lsf}: \cr
The \code{import_lsf(package, ...)} function gets a list of exported functions/operators from a package. \cr
\cr
}
\details{
The \code{import_as()} function
does not allow importing base/core R under an alias,
so don't try. \cr
\cr
The \code{import_inops()} function does not support overloading operators,
so don't try. \cr
\cr
For a more detailed description of the import system introduced by the
\code{tinyoperators} R package,
please refer to the Read Me file on the GitHub main page: \cr
\url{https://github.com/tony-aw/tinyoperators} \cr
}
\examples{
\dontrun{
import_as( # this creates the 'dr.' object
dr., "dplyr", depends=c("tibble", "tidyselect"), extends = "powerjoin"
) 
dr.$mutate
import_inops("data.table")
d <- import_data("chicago", "gamair")
head(d)
}


}
\seealso{
\link[=pkgs_get_deps]{pkgs}, \link[=source_inops]{source_module}
}
