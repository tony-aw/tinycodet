library(tinycodet)
library(ggplot2)
# stri_locate_ith vs first/last
n <- 1e5
x <- rep(paste0(1:50, collapse = ""), n)
p <- "\\d"
i <- -1
foo <- bench::mark(
stri_locate_ith_regex(x, p, -1),
stringi::stri_locate_last(x, regex = p),
min_iterations = 100
)
foo
autoplot(foo)
?tinycodet::str_search
?rep.int
rep.int(1.0, 2)
rep.int(1.0, 2) |> class()
rep.int(1.0, 2) |> is.integer()
pmax
library(tinycodet)
foo <- crandep::get_dep_all_packages()
unique(foo$type)
foo <- foo[foo$type == "linking to",]
unique(foo$to)
?tinycodet::stri_locate_ith()
?collapse::setattrib()
collapse::unattrib
x <- 1:1e6
names(x) <- sample(letters, 1e6, TRUE)
x <- 1:1e6
names(x) <- sample(letters, 1e6, TRUE)
y <- 1e6:1
names(y) <- sample(letters, 1e6, TRUE)
tempfun <- function(x, y) {
attributes(x) <- NULL
attributes(y) <- NULL
return(x == y)
}
tempfun <- function(x, y) {
attributes(x) <- NULL
attributes(y) <- NULL
return(x == y)
}
foo <- bench::mark(
x == y,
tempfun(x, y),
min_iterations = 200,
check = FALSE
)
foo
Rcpp::cppFunction(
"
LogicalVector rcpp_ntt_equal_dbl(
NumericVector x, NumericVector y, int tol
) {
int n = x.length();
LogicalVector out(n);
out = fabs(x - y) < tol;
return out;
}
"
)
Rcpp::cppFunction(
"
LogicalVector rcpp_ntt_equal_dbl(
NumericVector x, NumericVector y, int tol
) {
int n = x.length();
LogicalVector out(n);
out = fabs(x - y);
return out;
}
"
)
?`==`
setwd("D:/D Desktop/Publications/R package tinycodet/tinycodet")
dimtypes <- c("00", "01", "10")
declareleft <- c("NumericVector", "NumericVector", "double")
declareright <- c("NumericVector", "double", "NumericVector")
declarelength <- c("x.length()", "x.length()", "y.length()")
accessleft <- c("x[i]", "x[i]", "x")
accessright <- c("y[i]", "y", "y[i]")
templatecode  <- "
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_ntt_greatersmaller_dbl_DIM)]]
LogicalVector rcpp_ntt_greatersmaller_dbl_DIM(
DECLARELEFT x, DECLARERIGHT y, double tol, bool greater
) {
R_xlen_t n = DECLARELENGTH;
LogicalVector out(n);
if(greater) {
for(R_xlen_t i = 0; i < n; ++i) {
out[i] = ACCESSLEFT > ACCESSRIGHT;
}
} else {
for(R_xlen_t i = 0; i < n; ++i) {
out[i] = ACCESSLEFT < ACCESSRIGHT;
}
}
return out;
}
"
rcpp_scripts <- character(length(dimtypes))
names(rcpp_scripts) <- dimtypes
for(i in seq_along(dimtypes)) {
rcpp_scripts[[i]] <- stri_replace_all(
templatecode,
fixed = c("DIM", "DECLARELEFT", "DECLARERIGHT", "DECLARELENGTH", "ACCESSLEFT", "ACCESSRIGHT"),
replacement = c(dimtypes[i], declareleft[i], declareright[i], declarelength[i], accessleft[i], accessright[i]),
case_insensitive = FALSE,
vectorize_all = FALSE
)
}
library(stringi)
dimtypes <- c("00", "01", "10")
declareleft <- c("NumericVector", "NumericVector", "double")
declareright <- c("NumericVector", "double", "NumericVector")
declarelength <- c("x.length()", "x.length()", "y.length()")
accessleft <- c("x[i]", "x[i]", "x")
accessright <- c("y[i]", "y", "y[i]")
templatecode  <- "
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_ntt_greatersmaller_dbl_DIM)]]
LogicalVector rcpp_ntt_greatersmaller_dbl_DIM(
DECLARELEFT x, DECLARERIGHT y, double tol, bool greater
) {
R_xlen_t n = DECLARELENGTH;
LogicalVector out(n);
if(greater) {
for(R_xlen_t i = 0; i < n; ++i) {
out[i] = ACCESSLEFT > ACCESSRIGHT;
}
} else {
for(R_xlen_t i = 0; i < n; ++i) {
out[i] = ACCESSLEFT < ACCESSRIGHT;
}
}
return out;
}
"
rcpp_scripts <- character(length(dimtypes))
names(rcpp_scripts) <- dimtypes
for(i in seq_along(dimtypes)) {
rcpp_scripts[[i]] <- stri_replace_all(
templatecode,
fixed = c("DIM", "DECLARELEFT", "DECLARERIGHT", "DECLARELENGTH", "ACCESSLEFT", "ACCESSRIGHT"),
replacement = c(dimtypes[i], declareleft[i], declareright[i], declarelength[i], accessleft[i], accessright[i]),
case_insensitive = FALSE,
vectorize_all = FALSE
)
}
headers <- "
#include <Rcpp.h>
using namespace Rcpp;
"
rcpp_code <- paste(c(headers, rcpp_scripts), collapse = "\n\n\n")
cat(rcpp_code)
fileConn <- file("src/dynamic_rcpp_ntt_greatersmaller_dbl.cpp")
writeLines(rcpp_code, fileConn)
close(fileConn)
dimtypes <- c("00", "01", "10")
declareleft <- c("IntegerVector", "IntegerVector", "int")
declareright <- c("IntegerVector", "int", "IntegerVector")
declarelength <- c("x.length()", "x.length()", "y.length()")
accessleft <- c("x[i]", "x[i]", "x")
accessright <- c("y[i]", "y", "y[i]")
dimtypes <- c("00", "01", "10")
declareleft <- c("IntegerVector", "IntegerVector", "int")
declareright <- c("IntegerVector", "int", "IntegerVector")
declarelength <- c("x.length()", "x.length()", "y.length()")
accessleft <- c("x[i]", "x[i]", "x")
accessright <- c("y[i]", "y", "y[i]")
templatecode <- "
//' @keywords internal
//' @noRd
// [[Rcpp::export(.rcpp_ntt_greatersmaller_int_DIM)]]
LogicalVector rcpp_ntt_greatersmaller_int_DIM(
DECLARELEFT x, DECLARERIGHT y, bool greater
) {
R_xlen_t n = DECLARELENGTH;
LogicalVector out(n);
if(greater)) {
for(R_xlen_t i = 0; i < n; ++i) {
out[i] = ACCESSLEFT > ACCESSRIGHT;
}
} else {
for(R_xlen_t i = 0; i < n; ++i) {
out[i] = ACCESSLEFT < ACCESSRIGHT;
}
}
return out;
}
"
rcpp_scripts <- character(length(dimtypes))
names(rcpp_scripts) <- dimtypes
for(i in seq_along(dimtypes)) {
rcpp_scripts[[i]] <- stri_replace_all(
templatecode,
fixed = c("DIM", "DECLARELEFT", "DECLARERIGHT", "DECLARELENGTH", "ACCESSLEFT", "ACCESSRIGHT"),
replacement = c(dimtypes[i], declareleft[i], declareright[i], declarelength[i], accessleft[i], accessright[i]),
case_insensitive = FALSE,
vectorize_all = FALSE
)
}
headers <- "
#include <Rcpp.h>
using namespace Rcpp;
"
rcpp_code <- paste(c(headers, rcpp_scripts), collapse = "\n\n\n")
cat(rcpp_code)
fileConn <- file("src/dynamic_rcpp_ntt_greatersmaller_int.cpp")
writeLines(rcpp_code, fileConn)
close(fileConn)
# with_pro ====
x <- data.frame(a = 1:10, b = 11:20)
myform <- form(~ a^2 + b^2)
expect_equal(
with(x, a^2 + b^2),
with_pro(x, myform)
)
library(tinycodet)
library(tinytest)
# with_pro ====
x <- data.frame(a = 1:10, b = 11:20)
myform <- form(~ a^2 + b^2)
expect_equal(
with(x, a^2 + b^2),
with_pro(x, myform)
)
y <- 2
myform <- form(~ a^y, env = environment())
expect_equal(
with(x, a^y),
with_pro(x, myform)
)
tempfun <- function(x, form) {
with_pro(x, myform)
}
# with_pro ====
x <- data.frame(a = 1:10, b = 11:20)
myform <- form(~  a^2 + b^2)
expect_equal(
with(x,  a^2 + b^2),
with_pro(x, myform)
)
y <- 2
myform <- form(~ a^y, env = environment())
expect_equal(
with(x, a^y),
with_pro(x, myform)
)
tempfun <- function(x, form) {
with_pro(x, myform)
}
x <- data.frame(a = 1:10, b = 11:20)
myform <- form(~  a^2 + b^2)
expect_equal(
with(x,  a^2 + b^2),
tempfun(x, myform)
)
y <- 2
myform <- form(~ a^y, env = environment())
expect_equal(
with(x, a^y),
tempfun(x, myform)
)
# with_pro - errors ====
x <- data.frame(a = 1:10, b = 11:20)
myform <- form(~  a^2 + b^2)
expect_error(
with_pro(x, ~ c^2),
pattern = "unknown variable(s) given",
fixed = TRUE
)
expect_error(
with_pro(1:10, myform),
pattern = "`data` must be a recursive object",
fixed = TRUE
)
expect_error(
with_pro(x, " a^2 + b^2"),
pattern = "`form` must be a formula",
fixed = TRUE
)
expect_error(
with_pro(x, a ~ b),
pattern = "improper formula given"
)
# aes_pro - errors ====
my_x <- "colx"
my_y <- "coly"
expect_error(
aes_pro(my_x, my_y),
pattern = "formula inputs must be given"
)
expect_error(
aes_pro(x ~ y, y ~ x),
pattern = "improper formula given"
)
# aes_pro - checks ====
if(requireNamespace("ggplot2")) {
my_x <- ~ colX # regular column name
my_y <- ~ `1st` # special column name
fill <- ~ colFill
expect_equal(
ggplot2::aes(x = colX, y = `1st`, fill = colFill),
aes_pro(my_x, my_y, fill = fill)
)
my_x <- ~ colX^2 # regular column name with function/expression
my_y <- ~ `1st`^2 # special column name with function/expression
fill <- ~ colFill^2
expect_equal(
ggplot2::aes(colX^2, `1st`^2, fill = colFill^2),
aes_pro(my_x, my_y, fill = fill)
)
tempfun <- function(x, y, fill) {
aes_pro(x, y, fill = fill)
}
my_x <- ~ colX # regular column name
my_y <- ~ `1st` # special column name
fill <- ~ colFill
expect_equal(
ggplot2::aes(x = colX, y = `1st`, fill = colFill),
tempfun(my_x, my_y, fill)
)
my_x <- ~ colX^2 # regular column name with function/expression
my_y <- ~ `1st`^2 # special column name with function/expression
fill <- ~ colFill^2
expect_equal(
ggplot2::aes(colX^2, `1st`^2, fill = colFill^2),
tempfun(my_x, my_y, fill)
)
}
# with_pro ====
x <- data.frame(a = 1:10, b = 11:20)
myform <- form(~  a^2 + b^2)
expect_equal(
with(x,  a^2 + b^2),
with_pro(x, myform)
)
y <- 2
myform <- form(~ a^y, env = environment())
expect_equal(
with(x, a^y),
with_pro(x, myform)
)
tempfun <- function(x, form) {
with_pro(x, myform)
}
x <- data.frame(a = 1:10, b = 11:20)
myform <- form(~  a^2 + b^2)
expect_equal(
with(x,  a^2 + b^2),
tempfun(x, myform)
)
y <- 2
myform <- form(~ a^y, env = environment())
expect_equal(
with(x, a^y),
tempfun(x, myform)
)
# with_pro - errors ====
x <- data.frame(a = 1:10, b = 11:20)
myform <- form(~  a^2 + b^2)
expect_error(
with_pro(x, ~ c^2),
pattern = "unknown variable(s) given",
fixed = TRUE
)
expect_error(
with_pro(1:10, myform),
pattern = "`data` must be a recursive object",
fixed = TRUE
)
expect_error(
with_pro(x, " a^2 + b^2"),
pattern = "`form` must be a formula",
fixed = TRUE
)
expect_error(
with_pro(x, a ~ b),
pattern = "improper formula given"
)
# aes_pro - errors ====
my_x <- "colx"
my_y <- "coly"
expect_error(
aes_pro(my_x, my_y),
pattern = "formula inputs must be given"
)
expect_error(
aes_pro(x ~ y, y ~ x),
pattern = "improper formula given"
)
# aes_pro - checks ====
if(requireNamespace("ggplot2")) {
my_x <- ~ colX # regular column name
my_y <- ~ `1st` # special column name
fill <- ~ colFill
expect_equal(
ggplot2::aes(x = colX, y = `1st`, fill = colFill),
aes_pro(my_x, my_y, fill = fill)
)
my_x <- ~ colX^2 # regular column name with function/expression
my_y <- ~ `1st`^2 # special column name with function/expression
fill <- ~ colFill^2
expect_equal(
ggplot2::aes(colX^2, `1st`^2, fill = colFill^2),
aes_pro(my_x, my_y, fill = fill)
)
tempfun <- function(x, y, fill) {
aes_pro(x, y, fill = fill)
}
my_x <- ~ colX # regular column name
my_y <- ~ `1st` # special column name
fill <- ~ colFill
expect_equal(
ggplot2::aes(x = colX, y = `1st`, fill = colFill),
tempfun(my_x, my_y, fill)
)
my_x <- ~ colX^2 # regular column name with function/expression
my_y <- ~ `1st`^2 # special column name with function/expression
fill <- ~ colFill^2
expect_equal(
ggplot2::aes(colX^2, `1st`^2, fill = colFill^2),
tempfun(my_x, my_y, fill)
)
}
# with_pro ====
x <- data.frame(a = 1:10, b = 11:20)
myform <- form(~  a^2 + b^2)
expect_equal(
with(x,  a^2 + b^2),
with_pro(x, myform)
)
y <- 2
myform <- form(~ a^y, env = environment())
expect_equal(
with(x, a^y),
with_pro(x, myform)
)
tempfun <- function(x, form) {
with_pro(x, myform)
}
x <- data.frame(a = 1:10, b = 11:20)
myform <- form(~  a^2 + b^2)
expect_equal(
with(x,  a^2 + b^2),
tempfun(x, myform)
)
y <- 2
myform <- form(~ a^y, env = environment())
expect_equal(
with(x, a^y),
tempfun(x, myform)
)
# with_pro - errors ====
x <- data.frame(a = 1:10, b = 11:20)
myform <- form(~  a^2 + b^2)
expect_error(
with_pro(x, ~ c^2),
pattern = "unknown variable(s) given",
fixed = TRUE
)
expect_error(
with_pro(1:10, myform),
pattern = "`data` must be a recursive object",
fixed = TRUE
)
expect_error(
with_pro(x, " a^2 + b^2"),
pattern = "`form` must be a formula",
fixed = TRUE
)
expect_error(
with_pro(x, a ~ b),
pattern = "improper formula given"
)
