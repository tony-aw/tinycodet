return(out)
}
strcut_loc("hello", c(2, 3))
strcut_loc("hello", c(NA, NA))
strcut_loc(NA, c(NA, NA))
strcut_loc(as_chr(NA), c(NA, NA))
strcut_loc(as.character(NA), c(NA, NA))
#' Cut Strings
#'
#' @description
#'
#' The \code{strcut_loc()} function
#' cuts every string in a character vector around a location range \code{loc},
#' such that every string is cut into the following parts:
#'
#'  * the sub-string \bold{before} \code{loc};
#'  * the sub-string at \code{loc} itself;
#'  * the sub-string \bold{after} \code{loc}.
#'
#' The location range \code{loc} would usually be matrix with 2 columns,
#' giving the start and end points of some pattern match. \cr
#' \cr
#' The \code{strcut_brk()} function
#' (a wrapper around \link[stringi]{stri_split_boundaries})
#' cuts every string into individual text breaks
#' (like character, word, line, or sentence boundaries). \cr
#' \cr
#' The main difference between the \code{strcut_} - functions
#' and \link[stringi]{stri_split} /  \link[base]{strsplit},
#' is that the latter generally removes the delimiter patterns in a string when cutting,
#' while the \code{strcut_}-functions do not attempt to remove parts of the string by default,
#' they only attempt to cut the strings into separate pieces.
#' Moreover, the \code{strcut_} - functions always return a matrix, not a list.
#'
#'
#' @param str a string or character vector.
#' @param loc Either one of the following:
#'  * the result from the \link{stri_locate_ith} function.
#'  * a matrix of 2 integer columns, with \code{nrow(loc)==length(str)},
#'  giving the location range of the middle part.
#'  * a vector of length 2, giving the location range of the middle part.
#' @param fill_loc logical, indicating what should be done if
#' for some row \code{i},
#' \code{loc[i, ]} is \code{c(NA, NA)}. \cr
#'  * If \code{TRUE}, \code{c(NA, NA)} in \code{loc[i, ]}
#'  is translated to \code{c(1, nc[i])},
#' where \code{nc[i]} is the number of characters of \code{str[i]}
#'  * If \code{FALSE}, \code{strcut_loc()} will return \code{c(NA, NA, NA)}
#'  for when \code{loc[i,]} is \code{c(NA, NA)}.
#' @param type single string;
#' either the break iterator type,
#' one of \code{character}, \code{line_break}, \code{sentence}, \code{word},
#' or a custom set of ICU break iteration rules. Defaults to \code{"character"}. \cr
#' `r .mybadge_string("boundaries", "blue")` \cr
#'
#' @param ... additional settings for \link[stringi]{stri_opts_brkiter}
#'
#'
#'
#' @returns
#' For the \code{strcut_loc()} function: \cr
#' A character matrix with \code{length(str)} rows and 3 columns:
#'
#'  * the first column contains the sub-strings \bold{before} \code{loc};
#'  * the second column contains the sub_strings at \code{loc};
#'  * the third and last column contains the sub-strings \bold{after} \code{loc}. \cr
#'  \cr
#'
#' For the \code{strcut_brk()} function: \cr
#' A character matrix with \code{length(str)} rows and
#' a number of columns equal to the maximum number of pieces \code{str} was cut in. \cr
#' Empty places are filled with \code{NA}.
#'
#'
#'
#' @seealso [tinycodet_strings()]
#'
#'
#' @examples
#'
#' x <- rep(paste0(1:10, collapse=""), 10)
#' print(x)
#' loc <- stri_locate_ith(x, 1:10, fixed = as.character(1:10))
#' strcut_loc(x, loc)
#' strcut_loc(x, c(5,5))
#' strcut_loc(x, c(NA, NA), fill_loc = TRUE)
#' strcut_loc(x, c(NA, NA), fill_loc = FALSE)
#'
#' test <- "The\u00a0above-mentioned    features are very useful. " %s+%
#' "Spam, spam, eggs, bacon, and spam. 123 456 789"
#' strcut_brk(test, "line")
#' strcut_brk(test, "word")
#' strcut_brk(test, "sentence")
#' strcut_brk(test)
#' @rdname strcut
#' @export
strcut_loc <- function(str, loc) {
# Error handling:
if(!is.character(str)){
stop("`str` must be a character vector")
}
loc <- matrix(loc, ncol=2)
cc <- !is.na(str) & stats::complete.cases(loc)
nstr <- length(str)
nloc <- nrow(loc)
if(nrow(loc)==1) {
loc <- loc[rep(1, nstr), , drop=FALSE]
}
nloc <- nrow(loc)
if(nloc != nstr) {
stop("`nrow(loc)` must equal to `length(str)` or 1")
}
if(all(!cc)) {
repNA <- rep(NA, nstr)
out <- cbind(prepart = repNA, mainpart = str, postpart = repNA)
return(out)
}
# FUNCTION:
x <- str[cc]
loc <- loc[cc, , drop=FALSE] # new
nx <- length(x)
nc <- stringi::stri_length(x)
loc <- .check_loc(loc, cc, abortcall = sys.call())
prepart <- mainpart <- postpart <- character(nstr) # not nx
prepart[cc] <- .substr_prepart(x, loc, nx)
postpart[cc] <- .substr_postpart(x, loc, nx, nc)
mainpart[cc] <- stringi::stri_sub(
x, from = loc[, 1], to = pmin(loc[, 2], nc)
)
out <- cbind(prepart, mainpart, postpart)
out[!cc, ] <- c(NA, str[!cc], NA)
return(out)
}
#' @rdname strcut
#' @export
strcut_brk <- function(str, type = "character", ...) {
if(length(type) > 1) {
stop("`type` must be a single string")
}
out <- stringi::stri_split_boundaries(
str=str, type = type, n=-1L, tokens_only = FALSE, simplify = NA, ...
)
return(out)
}
#' @keywords internal
#' @noRd
.check_loc <- function(loc, cc, abortcall) {
if(any(loc[cc] < 1)) {
stop(simpleError("`loc` can only have strictly positive numbers", call = abortcall))
}
if(any(loc[,2] < loc[,1])) {
stop(simpleError("`loc[, 2] < loc[, 1]`", call = abortcall))
}
return(loc)
}
#' @keywords internal
#' @noRd
.substr_prepart <- function(x, loc, nx) {
out <- character(nx)
ind <- loc[, 1] == 1
out[ind] <- ""
ind2 <- which(!ind)
if(length(ind2) > 0) {
out[ind2] <- stringi::stri_sub(
x[ind2], from = 1, to = loc[ind2 ,1] - 1
)
}
return(out)
}
#' @keywords internal
#' @noRd
.substr_postpart <- function(x, loc, nx, nc) {
out <- character(nx)
ind <- loc[,2] >= nc
out[ind] <- ""
ind2 <- which(!ind)
if(length(ind2) > 0) {
out[ind2] <- stringi::stri_sub(
x[ind2], from = loc[ind2, 2] + 1, to = nc[ind2]
)
}
return(out)
}
strcut_loc(as.character(NA), c(NA, NA))
strcut_loc(as_chr(NA), c(NA, NA))
strcut_loc("hello", c(NA, NA))
strcut_loc("hello", c(2, 3))
strcut_loc("hello", c(1, 5))
strcut_loc("hello", c(1, 4))
strcut_loc("hello", c(0, 5))
strcut_loc("hello", c(2, 5))
strcut_loc("hello", c(1, 4))
?spelling::spell_check_package
?tinycodet::tinycodet
?import::from()
library(tinycodet)
# Solution with tinycodet's import system ====
import_as( # this creates the 'dpr.' object
"dpr.", "dplyr, extensions = "powerjoin"
)
import_as( # this creates the 'dpr.' object
"dpr.", "dplyr, extensions = "powerjoin"
import_as( # this creates the 'dpr.' object
"dpr.", "dplyr", extensions = "powerjoin"
)
import_as(
~ dpr., "dplyr, extensions = "powerjoin"
import_as(
~ dpr., "dplyr", extensions = "powerjoin"
)
d <- import_data("dplyr", "starwars")
# see it in action:
d |> dpr.$filter(species == "Droid") %>%
dpr.$select(name, dpr.$ends_with("color"))
import_as(
~ dpr., "dplyr", extensions = "powerjoin"
)
# exposing infix operators from "magrrittr" to current environment:
import_inops("magrittr")
# directly assigning dplyr's "starwars" dataset to object "d":
d <- import_data("dplyr", "starwars")
# see it in action:
d %>% tdt.$filter(species == "Droid") %>%
tdt.$select(name, tdt.$ends_with("color"))
# see it in action:
d %>% dpr.$filter(species == "Droid") %>%
dpr.$select(name, dpr.$ends_with("color"))
male_penguins <- dpr.$tribble(
~name,    ~species,     ~island, ~flipper_length_mm, ~body_mass_g,
"Giordan",    "Gentoo",    "Biscoe",               222L,        5250L,
"Lynden",    "Adelie", "Torgersen",               190L,        3900L,
"Reiner",    "Adelie",     "Dream",               185L,        3650L
)
female_penguins <- dpr.$tribble(
~name,    ~species,  ~island, ~flipper_length_mm, ~body_mass_g,
"Alonda",    "Gentoo", "Biscoe",               211,        4500L,
"Ola",    "Adelie",  "Dream",               190,        3600L,
"Mishayla",    "Gentoo", "Biscoe",               215,        4750L,
)
dpr.$check_specs()
dpr.$power_inner_join(
male_penguins[c("species", "island")],
female_penguins[c("species", "island")]
)
all(c("magrittr", "dplyr", "powerjoin") %installed in% .libPaths())
import_as( # this creates the 'dpr.' object
"dpr.", "dplyr", extensions = "powerjoin"
)
# same as:
import_as(
~ dpr., "dplyr", extensions = "powerjoin"
)
data("starwars", package = "dplyr")
# see it in action:
d |> dpr.$filter(species == "Droid") |>
dpr.$select(name, dpr.$ends_with("color"))
starwars |> dpr.$filter(species == "Droid") |>
dpr.$select(name, dpr.$ends_with("color"))
data("starwars", package = "dplyr")
# see it in action:
starwars |> dpr.$filter(species == "Droid") |>
dpr.$select(name, dpr.$ends_with("color"))
d <- import_data("datasets", "cars")
rl. <- loadNamespace("rlang")
View(rl.)
?rlang::check_installed
?find.package
find.package("data.table")
sessionInfo()
find.package("data.table")
find.package(c("data.table", "rlang"))
find.package("foo")
find.package(c("data.table", "foo"))
try(find.package("foo"))
tryCatch(find.package("foo"), error = function(e)FALSE)
tryCatch(find.package(c("data.table", "foo")), error = function(e)FALSE)
tryCatch(find.package(c("data.table", "foo")), error = function(e)FALSE, warning = function(w)FALSE)
tempfun <- function(pkg, lib.loc){
out <- tryCatch(
find.package(pkgs, lib.loc = lib.loc),
error = function(e) FALSE,
warning = function(w) FALSE
)
}
tempfun("foo", .libPaths())
tempfun <- function(pkg, lib.loc){
tryCatch(
find.package(pkgs, lib.loc = lib.loc),
error = function(e) FALSE,
warning = function(w) FALSE
)
}
tempfun("foo", .libPaths())
tempfun("data.table", .libPaths())
find.package("data.table", .libPaths())
tempfun <- function(pkg, lib.loc){
out <- tryCatch(
{find.package(pkgs, lib.loc = lib.loc)},
error = function(cond) FALSE,
warning = function(cond) FALSE
)
return(out)
}
find.package("data.table", .libPaths())
tempfun("data.table", .libPaths())
tempfun <- function(pkg, lib.loc){
out <- tryCatch(
{find.package(pkg, lib.loc = lib.loc)},
error = function(cond) FALSE,
warning = function(cond) FALSE
)
return(out)
}
tempfun("data.table", .libPaths())
tempfun("foo", .libPaths())
tempfun <- function(pkg, lib.loc){
out <- tryCatch(
{find.package(pkg, lib.loc = lib.loc)},
error = function(cond) FALSE,
warning = function(cond) FALSE
)
if(is.character(out) && !isFALSE(out)) { out <- TRUE }
return(out)
}
tempfun("foo", .libPaths())
tempfun("data.table", .libPaths())
pkgs <- c("data.table", "foo")
sapply(pkgs, tempfun)
tempfun("data.table", .libPaths())
tempfun("foo", .libPaths())
lapply(pkgs, tempfun)
pkgs
out <- sapply(pkgs, tempfun, lib.loc = lib.loc)
tempfun <- function(pkg, lib.loc){
out <- tryCatch(
{find.package(pkg, lib.loc = lib.loc)},
error = function(cond) FALSE,
warning = function(cond) FALSE
)
if(is.character(out) && !isFALSE(out)) { out <- TRUE }
return(out)
}
out <- sapply(pkgs, tempfun, lib.loc = lib.loc)
tempfun(pkgs[1], .libPaths())
lib.loc = .libPaths()
out <- sapply(pkgs, \(x)tempfun(x, lib.loc = lib.loc))
out
?stringi::stri_replace_all
?stringi::stri_replace_rstr
?stringi::stri_replace_na
?stringi::stri_replace_all_regex
dict <- c("hello" = "goodbye")
unlist(dict)
as.list(dict)
library(tinycodet)
x <- c(sample(letters), sample(letters))
print(x)
x <- c(paste0(sample(letters)), paste0(sample(letters)))
print(x)
x <- c(paste(sample(letters), collapse = ""), paste0(sample(letters)))
print(x)
x <- c(paste(sample(letters), collapse = ""), paste(sample(letters), collapse = ""))
print(x)
mat <- strcut_brk(x)
rank <- stringi::stri_rank(as.vector(mat)) |>  matrix(ncol=ncol(mat))
sorted <- mat %row~% rank
print(sorted)
stri_join_mat(sorted, margin=1)
stri_join_mat(sorted, margin=2)
x <- c("Hello everyone", "Goodbye everyone")
print(x)
mat <- strcut_brk(x, "word")
rank <- stringi::stri_rank(as.vector(mat)) |> matrix(ncol=ncol(mat))
sorted <- mat %row~% rank
print(sorted)
stri_c_mat(sorted, margin=1) # <- alias for stri_join_mat
stri_c_mat(sorted, margin=2)
x <- c("1st 2nd 3rd", "Goodbye everyone")
print(x)
mat <- strcut_brk(x, "word")
rank <- stringi::stri_rank(as.vector(mat)) |> matrix(ncol=ncol(mat))
sorted <- mat %row~% rank
print(sorted)
stri_c_mat(sorted, margin=1) # <- alias for stri_join_mat
stri_c_mat(sorted, margin=2)
x <- c("1st 2nd 3rd", "Goodbye everyone")
print(x)
mat <- strcut_brk(x, "word")
rank <- stringi::stri_rank(as.vector(mat)) |> matrix(ncol=ncol(mat))
sorted <- mat %row~% rank
print(sorted)
stri_c_mat(sorted, margin=1) # <- alias for stri_join_mat
stri_c_mat(sorted, margin=2)
stri_c_mat(sorted[2], margin=1) # <- alias for stri_join_mat
?stringi::stri_join
stringi::stri_join(c(NA, "hello"))
stringi::stri_join(c("", "hello"))
x <- c("Hello, who are you? Oh, really?! Cool!", "I don't care. But I really don't.")
print(x)
mat <- strcut_brk(x, "sentence")
rank <- stringi::stri_rank(as.vector(mat)) |> matrix(ncol=ncol(mat))
sorted <- mat %row~% rank
print(sorted)
x <- c("1st 2nd 3rd", "Goodbye everyone")
print(x)
mat <- strcut_brk(x, "word")
rank <- stringi::stri_rank(as.vector(mat)) |> matrix(ncol=ncol(mat))
sorted <- mat %row~% rank
print(sorted)
stri_c_mat(sorted, margin=1) # <- alias for stri_join_mat
stri_c_mat(sorted, margin=2)
sorted
stri_c_mat(sorted, margin=2)
stri_c_mat(sorted[1], margin=1) # <- alias for stri_join_mat
stri_c_mat(sorted[1,], margin=1) # <- alias for stri_join_mat
stri_c_mat(sorted[2,], margin=1) # <- alias for stri_join_mat
stri_c_mat(sorted, margin=1) # <- alias for stri_join_mat
stringi::stri_join(c("", "hello"))
stringi::stri_join(c("", "hello", NA))
?stringi::stri_join_list()
#' @family join_mat
#' @rdname stri_join_mat
#' @export
stri_join_mat <- function(mat, margin = 1, sep = "", collapse = NULL) {
stri_join_mat <- function(mat, margin = 1, sep = "", collapse = NULL) {
if(margin==1) {
out <- mat |> as.data.frame()
return(
stringi::stri_join_list(as.list(out), sep = sep, collapse = collapse)
)
}
if(margin==2) {
out <- t(mat) |> as.data.frame()
return(
stringi::stri_join_list(as.list(out), sep = sep, collapse = collapse)
)
} else {
stop("`margin` must be either 1 or 2")
}
}
x <- c("1st 2nd 3rd", "Goodbye everyone")
print(x)
mat <- strcut_brk(x, "word")
rank <- stringi::stri_rank(as.vector(mat)) |> matrix(ncol=ncol(mat))
sorted <- mat %row~% rank
print(sorted)
stri_c_mat(sorted, margin=1) # <- alias for stri_join_mat
stri_c_mat(sorted, margin=2)
?stringi::stri_split_boundaries
x <- matrix(letters[1:25], ncol=5, byrow = TRUE)
print(x)
stri_join_mat(x, margin=1)
x <- matrix(letters[1:25], ncol=5, byrow = FALSE)
print(x)
stri_join_mat(x, margin=2)
#############################################################################
# re-ordering characters in strings ====
x <- c(paste(sample(letters), collapse = ""), paste(sample(letters), collapse = ""))
print(x)
mat <- strcut_brk(x)
rank <- stringi::stri_rank(as.vector(mat)) |>  matrix(ncol=ncol(mat))
sorted <- mat %row~% rank
print(sorted)
stri_join_mat(sorted, margin=1)
stri_join_mat(sorted, margin=2)
#############################################################################
# re-ordering words ====
x <- c("1st 2nd 3rd", "Goodbye everyone")
print(x)
mat <- strcut_brk(x, "word")
rank <- stringi::stri_rank(as.vector(mat)) |> matrix(ncol=ncol(mat))
sorted <- mat %row~% rank
print(sorted)
sorted[is.NA(sorted)] <- ""
sorted[is.na(sorted)] <- ""
stri_c_mat(sorted, margin=1) # <- alias for stri_join_mat
stri_c_mat(sorted, margin=2)
x <- c("Hello, who are you? Oh, really?! Cool!", "I don't care. But I really don't.")
print(x)
mat <- strcut_brk(x, "sentence")
rank <- stringi::stri_rank(as.vector(mat)) |> matrix(ncol=ncol(mat))
sorted <- mat %row~% rank
print(sorted)
sorted[is.na(sorted)] <- ""
stri_paste_mat(sorted, margin=1) # <- another alias for stri_join_mat
stri_paste_mat(sorted, margin=2)
intersect(NULL, NULL)
?tools::dependsOnPkgs
stri <- loadedNamespaces("stringi")
stri <- loadNamespace("stringi")
attributes(stri)
as.environment("stringi")
as.environment("package:stringi")
sessionInfo()
search()
intersect(NULL, NULL)
# special _import_as() tests
library(tinycodet)
library(tinytest)
setwd("D:/D Desktop/Publications/R package tinycodet/tinycodet")
# loadNamespace different versions ====
lib <- file.path(getwd(), 'special_checks_lib')
# install.packages(
#   c("Rcpp"),
#   repos = c(CRAN = "https://packagemanager.posit.co/cran/2017-10-10"),
#   lib = lib
# )
import_as(~ dpr_old, "dplyr", lib.loc = lib, re_exports = FALSE)
import_as(~ dpr_new, "dplyr", lib.loc = .libPaths(), re_exports = FALSE)
rlang::warn
rlang::cnd_warning
rlang::new_cnd
