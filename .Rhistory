import_as( # this creates the 'dpr.' object
"dpr.", "dplyr, extensions = "powerjoin"
)
import_as( # this creates the 'dpr.' object
"dpr.", "dplyr, extensions = "powerjoin"
import_as( # this creates the 'dpr.' object
"dpr.", "dplyr", extensions = "powerjoin"
)
import_as(
~ dpr., "dplyr, extensions = "powerjoin"
import_as(
~ dpr., "dplyr", extensions = "powerjoin"
)
d <- import_data("dplyr", "starwars")
# see it in action:
d |> dpr.$filter(species == "Droid") %>%
dpr.$select(name, dpr.$ends_with("color"))
import_as(
~ dpr., "dplyr", extensions = "powerjoin"
)
# exposing infix operators from "magrrittr" to current environment:
import_inops("magrittr")
# directly assigning dplyr's "starwars" dataset to object "d":
d <- import_data("dplyr", "starwars")
# see it in action:
d %>% tdt.$filter(species == "Droid") %>%
tdt.$select(name, tdt.$ends_with("color"))
# see it in action:
d %>% dpr.$filter(species == "Droid") %>%
dpr.$select(name, dpr.$ends_with("color"))
male_penguins <- dpr.$tribble(
~name,    ~species,     ~island, ~flipper_length_mm, ~body_mass_g,
"Giordan",    "Gentoo",    "Biscoe",               222L,        5250L,
"Lynden",    "Adelie", "Torgersen",               190L,        3900L,
"Reiner",    "Adelie",     "Dream",               185L,        3650L
)
female_penguins <- dpr.$tribble(
~name,    ~species,  ~island, ~flipper_length_mm, ~body_mass_g,
"Alonda",    "Gentoo", "Biscoe",               211,        4500L,
"Ola",    "Adelie",  "Dream",               190,        3600L,
"Mishayla",    "Gentoo", "Biscoe",               215,        4750L,
)
dpr.$check_specs()
dpr.$power_inner_join(
male_penguins[c("species", "island")],
female_penguins[c("species", "island")]
)
all(c("magrittr", "dplyr", "powerjoin") %installed in% .libPaths())
import_as( # this creates the 'dpr.' object
"dpr.", "dplyr", extensions = "powerjoin"
)
# same as:
import_as(
~ dpr., "dplyr", extensions = "powerjoin"
)
data("starwars", package = "dplyr")
# see it in action:
d |> dpr.$filter(species == "Droid") |>
dpr.$select(name, dpr.$ends_with("color"))
starwars |> dpr.$filter(species == "Droid") |>
dpr.$select(name, dpr.$ends_with("color"))
data("starwars", package = "dplyr")
# see it in action:
starwars |> dpr.$filter(species == "Droid") |>
dpr.$select(name, dpr.$ends_with("color"))
d <- import_data("datasets", "cars")
rl. <- loadNamespace("rlang")
View(rl.)
?rlang::check_installed
?find.package
find.package("data.table")
sessionInfo()
find.package("data.table")
find.package(c("data.table", "rlang"))
find.package("foo")
find.package(c("data.table", "foo"))
try(find.package("foo"))
tryCatch(find.package("foo"), error = function(e)FALSE)
tryCatch(find.package(c("data.table", "foo")), error = function(e)FALSE)
tryCatch(find.package(c("data.table", "foo")), error = function(e)FALSE, warning = function(w)FALSE)
tempfun <- function(pkg, lib.loc){
out <- tryCatch(
find.package(pkgs, lib.loc = lib.loc),
error = function(e) FALSE,
warning = function(w) FALSE
)
}
tempfun("foo", .libPaths())
tempfun <- function(pkg, lib.loc){
tryCatch(
find.package(pkgs, lib.loc = lib.loc),
error = function(e) FALSE,
warning = function(w) FALSE
)
}
tempfun("foo", .libPaths())
tempfun("data.table", .libPaths())
find.package("data.table", .libPaths())
tempfun <- function(pkg, lib.loc){
out <- tryCatch(
{find.package(pkgs, lib.loc = lib.loc)},
error = function(cond) FALSE,
warning = function(cond) FALSE
)
return(out)
}
find.package("data.table", .libPaths())
tempfun("data.table", .libPaths())
tempfun <- function(pkg, lib.loc){
out <- tryCatch(
{find.package(pkg, lib.loc = lib.loc)},
error = function(cond) FALSE,
warning = function(cond) FALSE
)
return(out)
}
tempfun("data.table", .libPaths())
tempfun("foo", .libPaths())
tempfun <- function(pkg, lib.loc){
out <- tryCatch(
{find.package(pkg, lib.loc = lib.loc)},
error = function(cond) FALSE,
warning = function(cond) FALSE
)
if(is.character(out) && !isFALSE(out)) { out <- TRUE }
return(out)
}
tempfun("foo", .libPaths())
tempfun("data.table", .libPaths())
pkgs <- c("data.table", "foo")
sapply(pkgs, tempfun)
tempfun("data.table", .libPaths())
tempfun("foo", .libPaths())
lapply(pkgs, tempfun)
pkgs
out <- sapply(pkgs, tempfun, lib.loc = lib.loc)
tempfun <- function(pkg, lib.loc){
out <- tryCatch(
{find.package(pkg, lib.loc = lib.loc)},
error = function(cond) FALSE,
warning = function(cond) FALSE
)
if(is.character(out) && !isFALSE(out)) { out <- TRUE }
return(out)
}
out <- sapply(pkgs, tempfun, lib.loc = lib.loc)
tempfun(pkgs[1], .libPaths())
lib.loc = .libPaths()
out <- sapply(pkgs, \(x)tempfun(x, lib.loc = lib.loc))
out
?stringi::stri_replace_all
?stringi::stri_replace_rstr
?stringi::stri_replace_na
?stringi::stri_replace_all_regex
dict <- c("hello" = "goodbye")
unlist(dict)
as.list(dict)
library(tinycodet)
x <- c(sample(letters), sample(letters))
print(x)
x <- c(paste0(sample(letters)), paste0(sample(letters)))
print(x)
x <- c(paste(sample(letters), collapse = ""), paste0(sample(letters)))
print(x)
x <- c(paste(sample(letters), collapse = ""), paste(sample(letters), collapse = ""))
print(x)
mat <- strcut_brk(x)
rank <- stringi::stri_rank(as.vector(mat)) |>  matrix(ncol=ncol(mat))
sorted <- mat %row~% rank
print(sorted)
stri_join_mat(sorted, margin=1)
stri_join_mat(sorted, margin=2)
x <- c("Hello everyone", "Goodbye everyone")
print(x)
mat <- strcut_brk(x, "word")
rank <- stringi::stri_rank(as.vector(mat)) |> matrix(ncol=ncol(mat))
sorted <- mat %row~% rank
print(sorted)
stri_c_mat(sorted, margin=1) # <- alias for stri_join_mat
stri_c_mat(sorted, margin=2)
x <- c("1st 2nd 3rd", "Goodbye everyone")
print(x)
mat <- strcut_brk(x, "word")
rank <- stringi::stri_rank(as.vector(mat)) |> matrix(ncol=ncol(mat))
sorted <- mat %row~% rank
print(sorted)
stri_c_mat(sorted, margin=1) # <- alias for stri_join_mat
stri_c_mat(sorted, margin=2)
x <- c("1st 2nd 3rd", "Goodbye everyone")
print(x)
mat <- strcut_brk(x, "word")
rank <- stringi::stri_rank(as.vector(mat)) |> matrix(ncol=ncol(mat))
sorted <- mat %row~% rank
print(sorted)
stri_c_mat(sorted, margin=1) # <- alias for stri_join_mat
stri_c_mat(sorted, margin=2)
stri_c_mat(sorted[2], margin=1) # <- alias for stri_join_mat
?stringi::stri_join
stringi::stri_join(c(NA, "hello"))
stringi::stri_join(c("", "hello"))
x <- c("Hello, who are you? Oh, really?! Cool!", "I don't care. But I really don't.")
print(x)
mat <- strcut_brk(x, "sentence")
rank <- stringi::stri_rank(as.vector(mat)) |> matrix(ncol=ncol(mat))
sorted <- mat %row~% rank
print(sorted)
x <- c("1st 2nd 3rd", "Goodbye everyone")
print(x)
mat <- strcut_brk(x, "word")
rank <- stringi::stri_rank(as.vector(mat)) |> matrix(ncol=ncol(mat))
sorted <- mat %row~% rank
print(sorted)
stri_c_mat(sorted, margin=1) # <- alias for stri_join_mat
stri_c_mat(sorted, margin=2)
sorted
stri_c_mat(sorted, margin=2)
stri_c_mat(sorted[1], margin=1) # <- alias for stri_join_mat
stri_c_mat(sorted[1,], margin=1) # <- alias for stri_join_mat
stri_c_mat(sorted[2,], margin=1) # <- alias for stri_join_mat
stri_c_mat(sorted, margin=1) # <- alias for stri_join_mat
stringi::stri_join(c("", "hello"))
stringi::stri_join(c("", "hello", NA))
?stringi::stri_join_list()
#' @family join_mat
#' @rdname stri_join_mat
#' @export
stri_join_mat <- function(mat, margin = 1, sep = "", collapse = NULL) {
stri_join_mat <- function(mat, margin = 1, sep = "", collapse = NULL) {
if(margin==1) {
out <- mat |> as.data.frame()
return(
stringi::stri_join_list(as.list(out), sep = sep, collapse = collapse)
)
}
if(margin==2) {
out <- t(mat) |> as.data.frame()
return(
stringi::stri_join_list(as.list(out), sep = sep, collapse = collapse)
)
} else {
stop("`margin` must be either 1 or 2")
}
}
x <- c("1st 2nd 3rd", "Goodbye everyone")
print(x)
mat <- strcut_brk(x, "word")
rank <- stringi::stri_rank(as.vector(mat)) |> matrix(ncol=ncol(mat))
sorted <- mat %row~% rank
print(sorted)
stri_c_mat(sorted, margin=1) # <- alias for stri_join_mat
stri_c_mat(sorted, margin=2)
?stringi::stri_split_boundaries
x <- matrix(letters[1:25], ncol=5, byrow = TRUE)
print(x)
stri_join_mat(x, margin=1)
x <- matrix(letters[1:25], ncol=5, byrow = FALSE)
print(x)
stri_join_mat(x, margin=2)
#############################################################################
# re-ordering characters in strings ====
x <- c(paste(sample(letters), collapse = ""), paste(sample(letters), collapse = ""))
print(x)
mat <- strcut_brk(x)
rank <- stringi::stri_rank(as.vector(mat)) |>  matrix(ncol=ncol(mat))
sorted <- mat %row~% rank
print(sorted)
stri_join_mat(sorted, margin=1)
stri_join_mat(sorted, margin=2)
#############################################################################
# re-ordering words ====
x <- c("1st 2nd 3rd", "Goodbye everyone")
print(x)
mat <- strcut_brk(x, "word")
rank <- stringi::stri_rank(as.vector(mat)) |> matrix(ncol=ncol(mat))
sorted <- mat %row~% rank
print(sorted)
sorted[is.NA(sorted)] <- ""
sorted[is.na(sorted)] <- ""
stri_c_mat(sorted, margin=1) # <- alias for stri_join_mat
stri_c_mat(sorted, margin=2)
x <- c("Hello, who are you? Oh, really?! Cool!", "I don't care. But I really don't.")
print(x)
mat <- strcut_brk(x, "sentence")
rank <- stringi::stri_rank(as.vector(mat)) |> matrix(ncol=ncol(mat))
sorted <- mat %row~% rank
print(sorted)
sorted[is.na(sorted)] <- ""
stri_paste_mat(sorted, margin=1) # <- another alias for stri_join_mat
stri_paste_mat(sorted, margin=2)
intersect(NULL, NULL)
?tools::dependsOnPkgs
stri <- loadedNamespaces("stringi")
stri <- loadNamespace("stringi")
attributes(stri)
as.environment("stringi")
as.environment("package:stringi")
sessionInfo()
search()
intersect(NULL, NULL)
# special _import_as() tests
library(tinycodet)
library(tinytest)
setwd("D:/D Desktop/Publications/R package tinycodet/tinycodet")
# loadNamespace different versions ====
lib <- file.path(getwd(), 'special_checks_lib')
# install.packages(
#   c("Rcpp"),
#   repos = c(CRAN = "https://packagemanager.posit.co/cran/2017-10-10"),
#   lib = lib
# )
import_as(~ dpr_old, "dplyr", lib.loc = lib, re_exports = FALSE)
import_as(~ dpr_new, "dplyr", lib.loc = .libPaths(), re_exports = FALSE)
rlang::warn
rlang::cnd_warning
rlang::new_cnd
?pkgdown::build_site()
tinycodet::import_as(~ stri., "stringi")
View(stri.)
library(tinycodet)
#' String-Search Functions To Complement the String-Related Infix Operators
#'
#' @description
#' These functions operate on string searches (regex, fixed, coll, charclass),
#' and support 2 types of workflows:
#'
#'  1) Either, operate on ALL found patterns.
#'  2) Or, locate \eqn{i^{th}} occurrence(s) of a pattern,
#'  operate on the located occurrence(s), and then return it.
#'
#' These functions use the \link{s_pattern} API rather than the 'stringi' API,
#' as they are meant to compliment the string-related infix operators from 'tinycodet'. \cr
#' These functions call 'stringi' functions. \cr
#' \cr
#' The following functions are present: \cr
#'
#'  - \code{strloc_ith}: see \link{stri_locate_ith};
#'  forms the basis of the second workflow.
#'  - \code{strloc_all}: see \link{stri_locate_all}.
#'  - \code{strs_x}: calls \link[stringi]{stri_extract_all}.
#'  - \code{strs_vrp}: calls \link[stringi]{stri_replace_all}\code{(..., vectorize_all = TRUE)}.
#'  - \code{strs_dictrp}: calls \link[stringi]{stri_replace_all}\code{(..., vectorize_all = FALSE)}.
#'
#'
#' @param x a string or character vector.
#' @param p either a list with 'stringi' arguments (see \link{s_pattern}),
#' or else a character vector of the same length as \code{x} or a length of 1 with regular expressions. \cr
#' `r .mybadge_string("regex", "darkred")` \cr
#' `r .mybadge_string("fixed", "darkgreen")` \cr
#' `r .mybadge_string("coll", "pink")` \cr
#' `r .mybadge_string("charclass", "lightyellow")` \cr
#' @param rp a character vector giving the replacement values. \cr
#' Only relevant if argument `p` is a character vector. \cr
#' If argument `p` is a list, provide `rp` as part of that list.
#' @param ... additional arguments to be passed to the 'stringi' functions. \cr
#' Only relevant if argument `p` is a character vector. \cr
#' If argument `p` is a list, provide the additional arguments as part of that list.
#'
#'
#'
#' @returns
#' See the corresponding 'stringi'-functions
#'
#'
#' @seealso [tinycodet_strings()]
#'
#'
#' @examples
#'
#' # Workflow 1 Example ====
#'
#' x <- rep('The quick brown fox jumped over the lazy dog.', 3)
#' print(x)
#' p <- c('quick', 'brown', 'fox')
#' rp <- c('slow',  'black', 'bear')
#' strs_vrp(x, p, rp)
#' strs_dictrp(x, p, rp)
#'
#' print(x)
#' p <- s_fixed(
#'   c('QUICK', 'BROWN', 'FOX'),
#'   replacement = c('slow',  'black', 'bear'),
#'   case_insensitive = TRUE
#' )
#' strs_vrp(x, p)
#' strs_dictrp(x, p)
#'
#' #############################################################################
#'
#'
#' # Workflow 2 Example ====
#'
#' x <- c(paste0(letters[1:13], collapse=""), paste0(letters[14:26], collapse=""))
#' print(x)
#'
#' # report ith (second and second-last) vowel locations:
#' p <- s_regex( # vowels
#'   rep("A|E|I|O|U", 2),
#'   case_insensitive=TRUE
#' )
#' loc <- strloc_ith(x, c(2, -2), p)
#' print(loc)
#'
#' # extract ith vowels:
#' extr <- stringi::stri_sub(x, from=loc)
#' print(extr)
#'
#' # replace ith vowels with numbers:
#' repl <- chartr("aeiou", "12345", extr)
#' x <- stringi::stri_sub_replace(x, loc, replacement=repl)
#' print(x)
#'
#' @name stringsearch
#' @rdname stringsearch
#' @export
strloc_ith <- function(x, i, p, ...) {
if(is.list(p)){
args <- list(str = x, i = i)
return(do.call(stri_locate_ith, c(args, p)))
} else if(is.character(p)) {
return(stri_locate_ith(
x, i = i, regex = p, ...
))
} else {
stop("`p` must be a character vector or list")
}
}
#' @rdname stringsearch
#' @export
strloc_all <- function(x, p, ...) {
if(is.list(p)){
return(do.call(stringi::stri_locate_all, c(list(str = x), p)))
} else if(is.character(p)) {
return(stringi::stri_locate_all(
x, regex = p, ...
))
} else {
stop("`p` must be a character vector or list")
}
}
#' @rdname stringsearch
#' @export
strs_x <- function(x, p, ...) {
if(is.list(p)){
return(do.call(stringi::stri_extract_all, c(list(str = x), p)))
} else if(is.character(p)) {
return(stringi::stri_extract_all(
x, regex = p, ...
))
} else {
stop("`p` must be a character vector or list")
}
}
#' @rdname stringsearch
#' @export
strs_vrp <- function(x, p, rp, ...) {
if(is.list(p)){
args <- list(str = x, vectorize_all = TRUE)
return(do.call(stringi::stri_replace_all, c(args, p)))
} else if(is.character(p)) {
return(stringi::stri_replace_all(
x, replacement = rp, regex = p, vectorize_all = TRUE, ...
))
} else {
stop("`p` must be a character vector or list")
}
}
#' @rdname stringsearch
#' @export
strs_dictrp <- function(x, p, rp, ...) {
if(is.list(p)){
args <- list(str = x, vectorize_all = FALSE)
return(do.call(stringi::stri_replace_all, c(args, p)))
} else if(is.character(p)) {
return(stringi::stri_replace_all(
x, replacement = rp, regex = p, vectorize_all = FALSE, ...
))
} else {
stop("`p` must be a character vector or list")
}
}
x <- rep('The quick brown fox jumped over the lazy dog.', 3)
print(x)
p <- c('quick', 'brown', 'fox')
rp <- c('slow',  'black', 'bear')
strs_vrp(x, p, rp)
strs_dictrp(x, p, rp)
print(x)
p <- s_fixed(
c('QUICK', 'BROWN', 'FOX'),
replacement = c('slow',  'black', 'bear'),
case_insensitive = TRUE
)
strs_vrp(x, p)
strs_dictrp(x, p)
#############################################################################
# Workflow 2 Example ====
x <- c(paste0(letters[1:13], collapse=""), paste0(letters[14:26], collapse=""))
print(x)
# report ith (second and second-last) vowel locations:
p <- s_regex( # vowels
rep("A|E|I|O|U", 2),
case_insensitive=TRUE
)
loc <- strloc_ith(x, c(2, -2), p)
print(loc)
# extract ith vowels:
extr <- stringi::stri_sub(x, from=loc)
print(extr)
# replace ith vowels with numbers:
repl <- chartr("aeiou", "12345", extr)
x <- stringi::stri_sub_replace(x, loc, replacement=repl)
print(x)
