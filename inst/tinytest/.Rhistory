#'
#' @param ... additional settings for \link[stringi]{stri_opts_brkiter}
#'
#'
#'
#' @returns
#' For the \code{strcut_loc()} function: \cr
#' A character matrix with \code{length(str)} rows and 3 columns:
#'
#'  * the first column contains the sub-strings \bold{before} \code{loc};
#'  * the second column contains the sub_strings at \code{loc};
#'  * the third and last column contains the sub-strings \bold{after} \code{loc}. \cr
#'  \cr
#'
#' For the \code{strcut_brk()} function: \cr
#' A character matrix with \code{length(str)} rows and
#' a number of columns equal to the maximum number of pieces \code{str} was cut in. \cr
#' Empty places are filled with \code{NA}.
#'
#'
#'
#' @seealso [tinycodet_strings()]
#'
#'
#' @examples
#'
#' x <- rep(paste0(1:10, collapse=""), 10)
#' print(x)
#' loc <- stri_locate_ith(x, 1:10, fixed = as.character(1:10))
#' strcut_loc(x, loc)
#' strcut_loc(x, c(5,5))
#' strcut_loc(x, c(NA, NA), fill_loc = TRUE)
#' strcut_loc(x, c(NA, NA), fill_loc = FALSE)
#'
#' test <- "The\u00a0above-mentioned    features are very useful. " %s+%
#' "Spam, spam, eggs, bacon, and spam. 123 456 789"
#' strcut_brk(test, "line")
#' strcut_brk(test, "word")
#' strcut_brk(test, "sentence")
#' strcut_brk(test)
#' @rdname strcut
#' @export
strcut_loc <- function(str, loc) {
# Error handling:
if(!is.character(str)){
stop("`str` must be a character vector")
}
loc <- matrix(loc, ncol=2)
cc <- !is.na(str) & stats::complete.cases(loc)
nstr <- length(str)
nloc <- nrow(loc)
if(nrow(loc)==1) {
loc <- loc[rep(1, nstr), , drop=FALSE]
}
nloc <- nrow(loc)
if(nloc != nstr) {
stop("`nrow(loc)` must equal to `length(str)` or 1")
}
if(all(!cc)) {
repNA <- rep(NA, nstr)
out <- cbind(prepart = repNA, mainpart = str, postpart = repNA)
return(out)
}
# FUNCTION:
x <- str[cc]
loc <- loc[cc, , drop=FALSE] # new
nx <- length(x)
nc <- stringi::stri_length(x)
loc <- .check_loc(loc, cc, abortcall = sys.call())
prepart <- mainpart <- postpart <- character(nstr) # not nx
prepart[cc] <- .substr_prepart(x, loc, nx)
postpart[cc] <- .substr_postpart(x, loc, nx, nc)
mainpart[cc] <- stringi::stri_sub(
x, from = loc[, 1], to = pmin(loc[, 2], nc)
)
out <- cbind(prepart, mainpart, postpart)
out[!cc, ] <- c(NA, str[!cc], NA)
return(out)
}
#' @rdname strcut
#' @export
strcut_brk <- function(str, type = "character", ...) {
if(length(type) > 1) {
stop("`type` must be a single string")
}
out <- stringi::stri_split_boundaries(
str=str, type = type, n=-1L, tokens_only = FALSE, simplify = NA, ...
)
return(out)
}
#' @keywords internal
#' @noRd
.check_loc <- function(loc, cc, abortcall) {
if(any(loc[cc] < 1)) {
stop(simpleError("`loc` can only have strictly positive numbers", call = abortcall))
}
if(any(loc[,2] < loc[,1])) {
stop(simpleError("`loc[, 2] < loc[, 1]`", call = abortcall))
}
return(loc)
}
#' @keywords internal
#' @noRd
.substr_prepart <- function(x, loc, nx) {
out <- character(nx)
ind <- loc[, 1] == 1
out[ind] <- ""
ind2 <- which(!ind)
if(length(ind2) > 0) {
out[ind2] <- stringi::stri_sub(
x[ind2], from = 1, to = loc[ind2 ,1] - 1
)
}
return(out)
}
#' @keywords internal
#' @noRd
.substr_postpart <- function(x, loc, nx, nc) {
out <- character(nx)
ind <- loc[,2] >= nc
out[ind] <- ""
ind2 <- which(!ind)
if(length(ind2) > 0) {
out[ind2] <- stringi::stri_sub(
x[ind2], from = loc[ind2, 2] + 1, to = nc[ind2]
)
}
return(out)
}
strcut_loc(as.character(NA), c(NA, NA))
strcut_loc(as_chr(NA), c(NA, NA))
strcut_loc("hello", c(NA, NA))
strcut_loc("hello", c(2, 3))
strcut_loc("hello", c(1, 5))
strcut_loc("hello", c(1, 4))
strcut_loc("hello", c(0, 5))
strcut_loc("hello", c(2, 5))
strcut_loc("hello", c(1, 4))
?spelling::spell_check_package
?tinycodet::tinycodet
?import::from()
library(tinycodet)
# Solution with tinycodet's import system ====
import_as( # this creates the 'dpr.' object
"dpr.", "dplyr, extensions = "powerjoin"
)
import_as( # this creates the 'dpr.' object
"dpr.", "dplyr, extensions = "powerjoin"
import_as( # this creates the 'dpr.' object
"dpr.", "dplyr", extensions = "powerjoin"
)
import_as(
~ dpr., "dplyr, extensions = "powerjoin"
import_as(
~ dpr., "dplyr", extensions = "powerjoin"
)
d <- import_data("dplyr", "starwars")
# see it in action:
d |> dpr.$filter(species == "Droid") %>%
dpr.$select(name, dpr.$ends_with("color"))
import_as(
~ dpr., "dplyr", extensions = "powerjoin"
)
# exposing infix operators from "magrrittr" to current environment:
import_inops("magrittr")
# directly assigning dplyr's "starwars" dataset to object "d":
d <- import_data("dplyr", "starwars")
# see it in action:
d %>% tdt.$filter(species == "Droid") %>%
tdt.$select(name, tdt.$ends_with("color"))
# see it in action:
d %>% dpr.$filter(species == "Droid") %>%
dpr.$select(name, dpr.$ends_with("color"))
male_penguins <- dpr.$tribble(
~name,    ~species,     ~island, ~flipper_length_mm, ~body_mass_g,
"Giordan",    "Gentoo",    "Biscoe",               222L,        5250L,
"Lynden",    "Adelie", "Torgersen",               190L,        3900L,
"Reiner",    "Adelie",     "Dream",               185L,        3650L
)
female_penguins <- dpr.$tribble(
~name,    ~species,  ~island, ~flipper_length_mm, ~body_mass_g,
"Alonda",    "Gentoo", "Biscoe",               211,        4500L,
"Ola",    "Adelie",  "Dream",               190,        3600L,
"Mishayla",    "Gentoo", "Biscoe",               215,        4750L,
)
dpr.$check_specs()
dpr.$power_inner_join(
male_penguins[c("species", "island")],
female_penguins[c("species", "island")]
)
all(c("magrittr", "dplyr", "powerjoin") %installed in% .libPaths())
import_as( # this creates the 'dpr.' object
"dpr.", "dplyr", extensions = "powerjoin"
)
# same as:
import_as(
~ dpr., "dplyr", extensions = "powerjoin"
)
data("starwars", package = "dplyr")
# see it in action:
d |> dpr.$filter(species == "Droid") |>
dpr.$select(name, dpr.$ends_with("color"))
starwars |> dpr.$filter(species == "Droid") |>
dpr.$select(name, dpr.$ends_with("color"))
data("starwars", package = "dplyr")
# see it in action:
starwars |> dpr.$filter(species == "Droid") |>
dpr.$select(name, dpr.$ends_with("color"))
d <- import_data("datasets", "cars")
rl. <- loadNamespace("rlang")
View(rl.)
?rlang::check_installed
?find.package
find.package("data.table")
sessionInfo()
find.package("data.table")
find.package(c("data.table", "rlang"))
find.package("foo")
find.package(c("data.table", "foo"))
try(find.package("foo"))
tryCatch(find.package("foo"), error = function(e)FALSE)
tryCatch(find.package(c("data.table", "foo")), error = function(e)FALSE)
tryCatch(find.package(c("data.table", "foo")), error = function(e)FALSE, warning = function(w)FALSE)
tempfun <- function(pkg, lib.loc){
out <- tryCatch(
find.package(pkgs, lib.loc = lib.loc),
error = function(e) FALSE,
warning = function(w) FALSE
)
}
tempfun("foo", .libPaths())
tempfun <- function(pkg, lib.loc){
tryCatch(
find.package(pkgs, lib.loc = lib.loc),
error = function(e) FALSE,
warning = function(w) FALSE
)
}
tempfun("foo", .libPaths())
tempfun("data.table", .libPaths())
find.package("data.table", .libPaths())
tempfun <- function(pkg, lib.loc){
out <- tryCatch(
{find.package(pkgs, lib.loc = lib.loc)},
error = function(cond) FALSE,
warning = function(cond) FALSE
)
return(out)
}
find.package("data.table", .libPaths())
tempfun("data.table", .libPaths())
tempfun <- function(pkg, lib.loc){
out <- tryCatch(
{find.package(pkg, lib.loc = lib.loc)},
error = function(cond) FALSE,
warning = function(cond) FALSE
)
return(out)
}
tempfun("data.table", .libPaths())
tempfun("foo", .libPaths())
tempfun <- function(pkg, lib.loc){
out <- tryCatch(
{find.package(pkg, lib.loc = lib.loc)},
error = function(cond) FALSE,
warning = function(cond) FALSE
)
if(is.character(out) && !isFALSE(out)) { out <- TRUE }
return(out)
}
tempfun("foo", .libPaths())
tempfun("data.table", .libPaths())
pkgs <- c("data.table", "foo")
sapply(pkgs, tempfun)
tempfun("data.table", .libPaths())
tempfun("foo", .libPaths())
lapply(pkgs, tempfun)
pkgs
out <- sapply(pkgs, tempfun, lib.loc = lib.loc)
tempfun <- function(pkg, lib.loc){
out <- tryCatch(
{find.package(pkg, lib.loc = lib.loc)},
error = function(cond) FALSE,
warning = function(cond) FALSE
)
if(is.character(out) && !isFALSE(out)) { out <- TRUE }
return(out)
}
out <- sapply(pkgs, tempfun, lib.loc = lib.loc)
tempfun(pkgs[1], .libPaths())
lib.loc = .libPaths()
out <- sapply(pkgs, \(x)tempfun(x, lib.loc = lib.loc))
out
?stringi::stri_replace_all
?stringi::stri_replace_rstr
?stringi::stri_replace_na
?stringi::stri_replace_all_regex
dict <- c("hello" = "goodbye")
unlist(dict)
as.list(dict)
library(tinycodet)
x <- c(sample(letters), sample(letters))
print(x)
x <- c(paste0(sample(letters)), paste0(sample(letters)))
print(x)
x <- c(paste(sample(letters), collapse = ""), paste0(sample(letters)))
print(x)
x <- c(paste(sample(letters), collapse = ""), paste(sample(letters), collapse = ""))
print(x)
mat <- strcut_brk(x)
rank <- stringi::stri_rank(as.vector(mat)) |>  matrix(ncol=ncol(mat))
sorted <- mat %row~% rank
print(sorted)
stri_join_mat(sorted, margin=1)
stri_join_mat(sorted, margin=2)
x <- c("Hello everyone", "Goodbye everyone")
print(x)
mat <- strcut_brk(x, "word")
rank <- stringi::stri_rank(as.vector(mat)) |> matrix(ncol=ncol(mat))
sorted <- mat %row~% rank
print(sorted)
stri_c_mat(sorted, margin=1) # <- alias for stri_join_mat
stri_c_mat(sorted, margin=2)
x <- c("1st 2nd 3rd", "Goodbye everyone")
print(x)
mat <- strcut_brk(x, "word")
rank <- stringi::stri_rank(as.vector(mat)) |> matrix(ncol=ncol(mat))
sorted <- mat %row~% rank
print(sorted)
stri_c_mat(sorted, margin=1) # <- alias for stri_join_mat
stri_c_mat(sorted, margin=2)
x <- c("1st 2nd 3rd", "Goodbye everyone")
print(x)
mat <- strcut_brk(x, "word")
rank <- stringi::stri_rank(as.vector(mat)) |> matrix(ncol=ncol(mat))
sorted <- mat %row~% rank
print(sorted)
stri_c_mat(sorted, margin=1) # <- alias for stri_join_mat
stri_c_mat(sorted, margin=2)
stri_c_mat(sorted[2], margin=1) # <- alias for stri_join_mat
?stringi::stri_join
stringi::stri_join(c(NA, "hello"))
stringi::stri_join(c("", "hello"))
x <- c("Hello, who are you? Oh, really?! Cool!", "I don't care. But I really don't.")
print(x)
mat <- strcut_brk(x, "sentence")
rank <- stringi::stri_rank(as.vector(mat)) |> matrix(ncol=ncol(mat))
sorted <- mat %row~% rank
print(sorted)
x <- c("1st 2nd 3rd", "Goodbye everyone")
print(x)
mat <- strcut_brk(x, "word")
rank <- stringi::stri_rank(as.vector(mat)) |> matrix(ncol=ncol(mat))
sorted <- mat %row~% rank
print(sorted)
stri_c_mat(sorted, margin=1) # <- alias for stri_join_mat
stri_c_mat(sorted, margin=2)
sorted
stri_c_mat(sorted, margin=2)
stri_c_mat(sorted[1], margin=1) # <- alias for stri_join_mat
stri_c_mat(sorted[1,], margin=1) # <- alias for stri_join_mat
stri_c_mat(sorted[2,], margin=1) # <- alias for stri_join_mat
stri_c_mat(sorted, margin=1) # <- alias for stri_join_mat
stringi::stri_join(c("", "hello"))
stringi::stri_join(c("", "hello", NA))
?stringi::stri_join_list()
#' @family join_mat
#' @rdname stri_join_mat
#' @export
stri_join_mat <- function(mat, margin = 1, sep = "", collapse = NULL) {
stri_join_mat <- function(mat, margin = 1, sep = "", collapse = NULL) {
if(margin==1) {
out <- mat |> as.data.frame()
return(
stringi::stri_join_list(as.list(out), sep = sep, collapse = collapse)
)
}
if(margin==2) {
out <- t(mat) |> as.data.frame()
return(
stringi::stri_join_list(as.list(out), sep = sep, collapse = collapse)
)
} else {
stop("`margin` must be either 1 or 2")
}
}
x <- c("1st 2nd 3rd", "Goodbye everyone")
print(x)
mat <- strcut_brk(x, "word")
rank <- stringi::stri_rank(as.vector(mat)) |> matrix(ncol=ncol(mat))
sorted <- mat %row~% rank
print(sorted)
stri_c_mat(sorted, margin=1) # <- alias for stri_join_mat
stri_c_mat(sorted, margin=2)
?stringi::stri_split_boundaries
x <- matrix(letters[1:25], ncol=5, byrow = TRUE)
print(x)
stri_join_mat(x, margin=1)
x <- matrix(letters[1:25], ncol=5, byrow = FALSE)
print(x)
stri_join_mat(x, margin=2)
#############################################################################
# re-ordering characters in strings ====
x <- c(paste(sample(letters), collapse = ""), paste(sample(letters), collapse = ""))
print(x)
mat <- strcut_brk(x)
rank <- stringi::stri_rank(as.vector(mat)) |>  matrix(ncol=ncol(mat))
sorted <- mat %row~% rank
print(sorted)
stri_join_mat(sorted, margin=1)
stri_join_mat(sorted, margin=2)
#############################################################################
# re-ordering words ====
x <- c("1st 2nd 3rd", "Goodbye everyone")
print(x)
mat <- strcut_brk(x, "word")
rank <- stringi::stri_rank(as.vector(mat)) |> matrix(ncol=ncol(mat))
sorted <- mat %row~% rank
print(sorted)
sorted[is.NA(sorted)] <- ""
sorted[is.na(sorted)] <- ""
stri_c_mat(sorted, margin=1) # <- alias for stri_join_mat
stri_c_mat(sorted, margin=2)
x <- c("Hello, who are you? Oh, really?! Cool!", "I don't care. But I really don't.")
print(x)
mat <- strcut_brk(x, "sentence")
rank <- stringi::stri_rank(as.vector(mat)) |> matrix(ncol=ncol(mat))
sorted <- mat %row~% rank
print(sorted)
sorted[is.na(sorted)] <- ""
stri_paste_mat(sorted, margin=1) # <- another alias for stri_join_mat
stri_paste_mat(sorted, margin=2)
intersect(NULL, NULL)
?tools::dependsOnPkgs
stri <- loadedNamespaces("stringi")
stri <- loadNamespace("stringi")
attributes(stri)
as.environment("stringi")
as.environment("package:stringi")
sessionInfo()
search()
intersect(NULL, NULL)
# special _import_as() tests
library(tinycodet)
library(tinytest)
setwd("D:/D Desktop/Publications/R package tinycodet/tinycodet")
# loadNamespace different versions ====
lib <- file.path(getwd(), 'special_checks_lib')
# install.packages(
#   c("Rcpp"),
#   repos = c(CRAN = "https://packagemanager.posit.co/cran/2017-10-10"),
#   lib = lib
# )
import_as(~ dpr_old, "dplyr", lib.loc = lib, re_exports = FALSE)
import_as(~ dpr_new, "dplyr", lib.loc = .libPaths(), re_exports = FALSE)
rlang::warn
rlang::cnd_warning
rlang::new_cnd
library(tinytest)
library(tinycodet)
# set working directory to source file location ====
SourceFileLocation <- function() {
# BATCH way:
path <- funr::get_script_path()
if(!is.null(path)) return(path)
# R-Studio way:
if(Sys.getenv("RSTUDIO") == "1") {
if(rstudioapi::isAvailable(version_needed = NULL,child_ok = FALSE)) {
return(dirname(rstudioapi::getSourceEditorContext()$path))
}
if(is.null(knitr::current_input(dir = TRUE)) == FALSE) {
return(knitr::current_input(dir = TRUE))
}
return(getwd())
}
}
wd <- SourceFileLocation()
setwd(wd)
setwd("..")
# count number of "expect_" occurrences ====
testfiles <- list.files(file.path(getwd(), "/"), pattern = "*.R", recursive = TRUE)
n.testfiles <- length(testfiles)
temp.fun <- function(x) {
foo <- readLines(file.path(x))
sum(stringi::stri_count(foo, regex="expect_"))
}
testcount_regular <- sapply(
testfiles,
FUN = temp.fun
) |> sum()
# count number of loop iterated tests ====
n.iterations <- 0
n.loops <- 0
testfiles <- list.files(file.path(getwd(), "regular"), pattern = "*.R", recursive = FALSE)
for(i in testfiles) {
if(!grepl("-special", i)) {
my_env <- new.env()
source(file.path(getwd(),"regular", i), local = my_env) |> suppressMessages()
if("enumerate" %in% names(my_env) & "loops" %in% names(my_env)){
print(my_env$enumerate)
n.iterations <- n.iterations + my_env$enumerate
n.loops <- n.loops + my_env$loops
}
}
}
testcount_loops <- n.iterations - n.loops
# determine total number of tests ====
testcount_total <- testcount_regular + testcount_loops
print(testcount_total)
# test / function ratio ====
nfuns <- length(getNamespaceExports(loadNamespace("tinycodet")))
testcount_total / nfuns # about a dozen tests per function on average
