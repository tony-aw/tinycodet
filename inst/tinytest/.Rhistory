check = FALSE,
min_iterations = 250
)
foo
ggplot2::autoplot(foo)
# NOTE: squarebrackets needs to be properly installed,
# otherwise speed comparisons will WILDLY off
foo <- bench::mark(
abind::abind(x, y, x, along = 3),
abind.recursive(list(x, y, x), 3), # about as fast as abind::abind
check = FALSE,
min_iterations = 250
)
foo
library(squarebrackets)
# abind vs abind.recursive ====
.abind.recursive <- squarebrackets:::.abind.recursive
x <- array(as.list(1:10), dim = c(5,2))
y <- array(as.list(letters[1:20]), dim = c(5,4))
colnames(x) <- c("a", "b")
colnames(y) <- c("a", "b", "c", "d")
.abind.recursive(list(x,y))
abind::abind(list(x,y))
x <- array(1:1e5, dim = c(100,10, 100))
y <- array(-1e5:-1, dim =c(100,10, 100))
# NOTE: squarebrackets needs to be properly installed,
# otherwise speed comparisons will WILDLY off
foo <- bench::mark(
abind::abind(x, y, x, along = 3),
.abind.recursive(list(x, y, x), 3), # about as fast as abind::abind (slightly faster even)
min_iterations = 250
)
foo
ggplot2::autoplot(foo)
x <- array(1:1e6, dim = c(100, 100, 100))
y <- array(-1e6:-1, dim =c(100, 100, 100))
# NOTE: squarebrackets needs to be properly installed,
# otherwise speed comparisons will WILDLY off
foo <- bench::mark(
abind::abind(x, y, x, along = 3),
.abind.recursive(list(x, y, x), 3), # about as fast as abind::abind (slightly faster even)
min_iterations = 250
)
foo
ggplot2::autoplot(foo)
x <- array(1:1e5, dim = c(100, 10, 100))
y <- array(-1e5:-1, dim =c(100, 10, 100))
# NOTE: squarebrackets needs to be properly installed,
# otherwise speed comparisons will WILDLY off
foo <- bench::mark(
abind::abind(x, y, x, along = 3),
.abind.recursive(list(x, y, x), 3), # about as fast as abind::abind (slightly faster even)
min_iterations = 250
)
foo
ggplot2::autoplot(foo)
# NOTE: squarebrackets needs to be properly installed,
# otherwise speed comparisons will WILDLY off
foo <- bench::mark(
abind::abind(x, y, x, along = 3),
.abind.recursive(list(x, y, x), 3), # about as fast as abind::abind (slightly faster even)
min_iterations = 250
)
foo
ggplot2::autoplot(foo)
?getOption
?magrittr::extract
magrittr::inset
?data.table::setDT
data.table::setDF
library(tibble)
`[[.tibble`
methods("[[")
methods(class = "tbl_df")
?tbl_df
`[[.list`
`[[`
`[[.data.frame`
`[[<-.data.frame`
methods("[[<-")
`[[<-.data.frame`
`[[<-.tbl_df`
methods()
?methods()
?getS3method
getS3method("[[<-", "tbl_df")
?data.table
getS3method("[[<-", "tbl_df")
library(tibble)
getS3method("[[<-", "tbl_df")
tibble:::tbl_subassign
tibble:::vectbl_restore
tibble:::vectbl_as_col_subscript
tibble:::vectbl_assign
tibble:::vectbl_assign
vctrs::vec_assign
?vctrs::vec_assign
?vctrs::`vec_slice<-`
vctrs::`vec_slice<-`
?delayedAssign
x <- 1:10
vctrs::vec_assign(x, 1:2, -1:-2)
x
library(vctrs)
x
vec_slice(x, 1:2) <- -1:-2
x
library(collections)
?collections::dict
d <- dict(list(apple = 5, orange = 10))
d
d$set <- NULL
d$set
d <- dict(list(apple = 5, orange = 10))
lockEnvironment(d, bindings = TRUE)
d
d$set <- NULL
d$set("banana", 3)
rm(d)
d <- dict(list(apple = 5, orange = 10))
lockBinding("set", d)
d$set <- NULL
d$set("banana", 3)
d
d <- dict(list(apple = 5, orange = 10))
d$set <- NULL
> d$set
d <- dict(list(apple = 5, orange = 10))
d$set <- NULL
d$set
d <- dict(list(apple = 5, orange = 10))
lockBinding("set", d)
d$set <- NULL
d$set("banana", 3)
d$set
125/3
40/8*3
40*8
125/0.4
library(tinycodet)
loadNamespace("bench")
loadNamespace("ggplot2")
n <- 1e5
x <- rep(paste0(1:50, collapse = ""), n)
p <- "\\d"
i <- sample(c(-50:-1, 1:50), replace=TRUE, size = n)
locate_stringi <- function(...) {
stringi::stri_locate_all(...)
stringi::stri_count(...)
}
bm.stri_locate_ith <- bench::mark(
"stri_locate_ith" = { stri_locate_ith_regex(x, p, i) },
"stringi::(stri_locate_all + stri_count)" = { locate_stringi(str=x, regex = p) },
min_iterations = 500,
check = FALSE
)
ggplot2::autoplot(bm.stri_locate_ith)
bm.stri_locate_ith
Rcpp::cppFunction(
"
IntegerVector rcpp_convert_i(IntegerVector n_matches, IntegerVector i) {
int n = i.length();
IntegerVector out(n);
int res = 0;
for(int j = 0; j < n; ++j) {
if(IntegerVector::is_na(i[j])) {
stop(\"i is not allowed to be 0 or NA\");
}
else if(i[j] < 0) {
res = n_matches[j] - abs(i[j] + 1);
if(res < 1) {
out[j] = 1;
} else {
out[j] = res;
}
}
else if(i[j] > 0) {
if(i[j] < n_matches[j]) {
out[j] = i[j];
} else {
out[j] = n_matches[j];
}
}
else {
stop(\"i is not allowed to be 0 or NA\");
}
}
return out;
}
"
)
Rcpp::cppFunction(
"
IntegerVector rcpp_convert_neg_i(IntegerVector n_matches, IntegerVector i) {
int n = i.length();
IntegerVector out(n);
int res = 0;
for(int j = 0; j < n; ++j) {
res = n_matches[j] - abs(i[j] + 1);
if(res < 1) {
out[j] = 1;
} else {
out[j] = res;
}
}
return out;
}
"
)
Rcpp::cppFunction(
"
IntegerVector rcpp_convert_pos_i(IntegerVector n_matches, IntegerVector i) {
int n = i.length();
IntegerVector out(n);
for(int j = 0; j < n; ++j) {
if(i[j] < n_matches[j]) {
out[j] = i[j];
} else {
out[j] = n_matches[j];
}
}
return out;
}
"
)
rcpp_old <- function(n.matches, i) {
i <- as.integer(i)
neg <- which(i < 0)
pos <- which(i > 0)
bad_i <- length(i) != (length(neg) + length(pos))
if(bad_i){
stop("`i` is not allowed to be zero or NA")
}
i[neg] <- rcpp_convert_neg_i(n.matches[neg], i[neg])
i[pos] <- rcpp_convert_pos_i(n.matches[pos], i[pos])
return(i)
}
rcpp_convert_i(n.matches, rep(0, length(n.matches)))
i <- sample(c(-50:-1, 1:50), 5e5, TRUE)
n.matches <- sample(0:50, 5e5, TRUE)
rcpp_convert_i(n.matches, rep(0, length(n.matches)))
rcpp_convert_i(n.matches, rep(NA, length(n.matches)))
rcpp_convert_i(n.matches, rep(NaN, length(n.matches)))
rcpp_convert_i(n.matches, rep(Inf, length(n.matches)))
rcpp_convert_i(n.matches, rep(-Inf, length(n.matches)))
foo <- bench::mark(
rcpp_old = rcpp_old(n.matches, i),
rcpp_new = rcpp_convert_i(n.matches, i),
min_iterations = 500
)
foo
ggplot2::autoplot(foo)
i <- sample(c(-50:-1, 1:50))
i <- sample(c(-50:-1, 1:50))
n.matches <- sample(0:50, length(i), TRUE)
foo <- bench::mark(
rcpp_old = for(j in 1:10000) rcpp_old(n.matches, i),
rcpp_new = for(j in 1:10000) rcpp_convert_i(n.matches, i),
min_iterations = 500
)
foo
ggplot2::autoplot(foo)
?transform_if
x <- c(-1e5:1e5, NA, NA)
x <- c(-1e6:1e6, NA, NA)
object <- matrix(x, ncol = 2)
x <- c(-1e6:1e6, NA, NaN, 0)
object <- matrix(x, ncol = 2)
attr(object, "helloworld") <- "helloworld"
print(object)
y <- 0
z <- 1000
x <- c(-1e6:1e6, NA, NaN, 0)
object <- matrix(x, ncol = 2)
attr(object, "helloworld") <- "helloworld"
y <- 0
z <- 1000
bm.transform_if <- bench::mark(
transform_if = object |> transform_if(object > y, log, \(x) x^2, -z),
ifelse = ifelse(is.na(object), z, ifelse(object > y, log(object), object^2)),
min_iterations = 250
)
x <- c(-10:10, NA, NaN, 0)
object <- matrix(x, ncol = 2)
attr(object, "helloworld") <- "helloworld"
y <- 0
z <- 1000
object |> transform_if(object > y, log, \(x) x^2, -z)
ifelse(is.na(object), z, ifelse(object > y, log(object), object^2))
bm.transform_if <- bench::mark(
transform_if = object |> transform_if(object > y, log, \(x) x^2, -z),
ifelse = ifelse(is.na(object), -z, ifelse(object > y, log(object), object^2)),
min_iterations = 250
)
object |> transform_if(object > y, log, \(x) x^2, -z)
ifelse(is.na(object), -z, ifelse(object > y, log(object), object^2))
bm.transform_if <- bench::mark(
transform_if = object |> transform_if(object > y, log, \(x) x^2, -z),
ifelse = ifelse(is.na(object), -z, ifelse(object > y, log(object), object^2)),
min_iterations = 250,
check = FALSE
)
x <- c(-1e5:1e5, NA, NaN, 0)
object <- matrix(x, ncol = 2)
attr(object, "helloworld") <- "helloworld"
y <- 0
z <- 1000
bm.transform_if <- bench::mark(
transform_if = object |> transform_if(object > y, log, \(x) x^2, -z),
ifelse = ifelse(is.na(object), -z, ifelse(object > y, log(object), object^2)),
min_iterations = 250,
check = FALSE
)
summary(bm.transform_if)
ggplot2::autoplot(bm.transform_if)
# set-up ====
setwd("D:/D Desktop/Publications/R package tinycodet")
sessionInfo()
pkgs <- c("devtools", "roxygen2", "usethis", "rcmdcheck", "spelling", "tinytex",
"tinytest", "pkgdown", "goodpractice", "rhub")
for(i in pkgs) if(!requireNamespace(i))install.packages(i)
library(tinytest)
library(tinycodet)
import_inops("magrittr")
import_as(~mr., "magrittr")
`:=` <- data.table::`:=`
alias_attr <- mr.$.__attributes__.
str(alias_attr)
attr.import(mr., "pkgs")
attr.import(mr., "conflicts")
attr.import(mr., "args")
attr.import(mr., "ordered_object_names")
help.import(i = `%>%`)
help.import(i = mr.$multiply_by)
help.import(i = "%>%", alias=mr.)
help.import(i = "add", alias=mr.)
help.import(topic = "%>%", package = "magrittr")
x <- matrix(sample(1:20), ncol = 4)
x %row~% x == do.call(rbind, apply(x, 1, sort, simplify = FALSE))
x %col~% x == do.call(cbind, apply(x, 2, sort, simplify = FALSE))
safer_partialmatch()
expect_warning(
iris$Sepal.Len
)
# open documentation ====
library(tinycodet)
# overview pages:
?tinycodet
?tinycodet::tinycodet
# Render ReadMe, vignettes and pkgdown site ====
pkgs <- c("dplyr", "powerjoin", "magrittr", "zeallot", "tidytable", "data.table",
"gamair", "rbenchmark", "xfun", "pkgdown", "servr")
for(i in pkgs) if(!requireNamespace(i))install.packages(i)
if(!requireNamespace("xfun"))install.packages("xfun")
xfun::Rscript_call(
rmarkdown::render,
list(input = "./tinycodet/README.Rmd", output_format = "github_document")
)
path_vignettes <- normalizePath("./tinycodet/vignettes/articles/")
files <- list.files(path = path_vignettes, pattern = ".Rmd")
temp.fun <- function(x) {
xfun::Rscript_call(
rmarkdown::render,
list(input = file.path(path_vignettes, x), output_format = "html_vignette")
)
}
lapply(files, temp.fun)
# check references:
data_reference_index_missing <- function(pkg = ".", depth = 1L) {
tinycodet::import_inops("magrittr")
tinycodet::import_inops("rlang")
pkg <- pkgdown:::as_pkgdown(pkg)
meta <- pkg$meta[["reference"]] %||% default_reference_index(pkg)
if (length(meta) == 0) {
return(list())
}
# Cross-reference complete list of topics vs. topics found in index page
all_topics <- meta %>%
purrr::map(~ pkgdown:::select_topics(.$contents, pkg$topics)) %>%
purrr::reduce(union)
in_index <- seq_along(pkg$topics$name) %in% all_topics
missing <- !in_index & !pkg$topics$internal
pkg$topics$name[missing]
}
data_reference_index_missing("./tinycodet")
pkgdown::template_reference("./tinycodet")
# create site:
pkgdown::build_site("./tinycodet", run_dont_run = TRUE)
devtools::build_manual(
"./tinycodet", "./tinycodet"
) # if this fails...:
# Render ReadMe, vignettes and pkgdown site ====
pkgs <- c("dplyr", "powerjoin", "magrittr", "zeallot", "tidytable", "data.table",
"gamair", "rbenchmark", "xfun", "pkgdown", "servr")
for(i in pkgs) if(!requireNamespace(i))install.packages(i)
if(!requireNamespace("xfun"))install.packages("xfun")
xfun::Rscript_call(
rmarkdown::render,
list(input = "./tinycodet/README.Rmd", output_format = "github_document")
)
# create site:
pkgdown::build_site("./tinycodet", run_dont_run = TRUE)
# Render ReadMe, vignettes and pkgdown site ====
pkgs <- c("dplyr", "powerjoin", "magrittr", "zeallot", "tidytable", "data.table",
"gamair", "rbenchmark", "xfun", "pkgdown", "servr")
for(i in pkgs) if(!requireNamespace(i))install.packages(i)
if(!requireNamespace("xfun"))install.packages("xfun")
xfun::Rscript_call(
rmarkdown::render,
list(input = "./tinycodet/README.Rmd", output_format = "github_document")
)
path_vignettes <- normalizePath("./tinycodet/vignettes/articles/")
files <- list.files(path = path_vignettes, pattern = ".Rmd")
temp.fun <- function(x) {
xfun::Rscript_call(
rmarkdown::render,
list(input = file.path(path_vignettes, x), output_format = "html_vignette")
)
}
lapply(files, temp.fun)
# create site:
pkgdown::build_site("./tinycodet", run_dont_run = TRUE)
library(tinytest)
library(tinycodet)
# set working directory to source file location ====
SourceFileLocation <- function() {
# BATCH way:
path <- funr::get_script_path()
if(!is.null(path)) return(path)
# R-Studio way:
if(Sys.getenv("RSTUDIO") == "1") {
if(rstudioapi::isAvailable(version_needed = NULL,child_ok = FALSE)) {
return(dirname(rstudioapi::getSourceEditorContext()$path))
}
if(is.null(knitr::current_input(dir = TRUE)) == FALSE) {
return(knitr::current_input(dir = TRUE))
}
return(getwd())
}
}
wd <- SourceFileLocation()
setwd(wd)
setwd("..")
# count number of "expect_" occurrences ====
testfiles <- list.files(file.path(getwd(), "/"), pattern = "*.R", recursive = TRUE)
n.testfiles <- length(testfiles)
temp.fun <- function(x) {
foo <- readLines(file.path(x))
sum(stringi::stri_count(foo, regex="expect_"))
}
testcount_regular <- sapply(
testfiles,
FUN = temp.fun
) |> sum()
# count number of loop iterated tests ====
n.iterations <- 0
n.loops <- 0
testfiles <- list.files(file.path(getwd(), "regular"), pattern = "*.R", recursive = FALSE)
for(i in testfiles) {
if(!grepl("-special", i)) {
my_env <- new.env()
source(file.path(getwd(),"regular", i), local = my_env) |> suppressMessages()
if("enumerate" %in% names(my_env) && "loops" %in% names(my_env)){
print(my_env$enumerate)
n.iterations <- n.iterations + my_env$enumerate
n.loops <- n.loops + my_env$loops
}
}
}
testfiles <- list.files(file.path(getwd(), "strings"), pattern = "*.R", recursive = FALSE)
for(i in testfiles) {
if(!grepl("-special", i)) {
my_env <- new.env()
source(file.path(getwd(),"strings", i), local = my_env) |> suppressMessages()
if("enumerate" %in% names(my_env) && "loops" %in% names(my_env)){
print(my_env$enumerate)
n.iterations <- n.iterations + my_env$enumerate
n.loops <- n.loops + my_env$loops
}
}
}
testfiles <- list.files(file.path(getwd(), "safer"), pattern = "*.R", recursive = FALSE)
for(i in testfiles) {
if(!grepl("-special", i)) {
my_env <- new.env()
source(file.path(getwd(),"safer", i), local = my_env) |> suppressMessages()
if("enumerate" %in% names(my_env) && "loops" %in% names(my_env)){
print(my_env$enumerate)
n.iterations <- n.iterations + my_env$enumerate
n.loops <- n.loops + my_env$loops
}
}
}
testfiles <- list.files(file.path(getwd(), "import"), pattern = "*.R", recursive = FALSE)
for(i in testfiles) {
if(!grepl("-special", i)) {
my_env <- new.env()
source(file.path(getwd(),"import", i), local = my_env) |> suppressMessages()
if("enumerate" %in% names(my_env) && "loops" %in% names(my_env)){
print(my_env$enumerate)
n.iterations <- n.iterations + my_env$enumerate
n.loops <- n.loops + my_env$loops
}
}
}
testcount_loops <- n.iterations - n.loops
# determine total number of tests ====
testcount_total <- testcount_regular + testcount_loops
print(testcount_total)
# test / function ratio ====
nfuns <- length(getNamespaceExports(loadNamespace("tinycodet")))
testcount_total / nfuns # about 78 tests per function on average
