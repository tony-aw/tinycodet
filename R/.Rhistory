?apply
by
by.data.frame
v <- 1:10
f <- factor(rep(letters[1:5], each = 2))
f
v
tapply(v, f, \(x)x[,1])
tapply(v, f, \(x)x[1])
tapply(v, f, \(x)x[2])
f <- f[sample(seq_len(f))]
f <- factor(rep(letters[1:5], each = 2))
f <- f[seq_along(f)]
f
f <- f[sample(seq_along(f))]
f
tapply(v, f, \(x)x[2])
0.16*40
17/40
42000*0.25
42000*0.25*0.5
10500 – 220 – 2000
10500 - 220 - 2000
5250 - 220 - 2000
42000*0.15
6300/2
3150-220-200
6300/3
6300-2100
10500/3
10500-3500
3500-220-2000
42000/2
7000-220-2000
5250 * 5 - (2000 + 210)
7000*5 - 2210
5250 - (2210/5)
7000 (2210/5)
7000 - (2210/5)
uurweek <- 36
uurmaand <- 36/5 * 21,75
uurmaand <- 36/5 * 21.75
maandloon <- 4000
maandloon / uurmaand
4000 * 12
jaarloon <- maandloon * 12
jaarloon * 0.25
6000 - (2210/5)
jaarloon/2
8000 - (2210/5)
6000 - 2250
6000 - 2250/5
?packageVersion
loadedNamespaces()
?loadedNamespaces()
purrr::safely
??as_mappper
purrr:::as_mapper
purrr:::as_mapper.default()
purrr:::as_mapper.default
?rlang::as_function
rlang::as_function
?rlang::as_closure
rlang::as_closure(mean)
mean
purrr:::force
??force
purrr::safely(mean)
purrr::safely(mean)
purrr::safely(loadNamespace)
args(loadNamespace)
args(purrr::safely(loadNamespace))
maandloon <- 4000
werkdagen.per.maand <- 21.75
uurloon <- maandloon/werkdagen.per.maand/8
dagloon <- maandloon/werkdagen.per.maand/8
36/5
uurloon <- dagloon/7.2
dagloon <- maandloon/werkdagen.per.maand
uurloon <- dagloon/7.2
jaarloon <- maandloon * 12
2250/5
2250/2
8000-1125
6000 - (2250/2)
find.package
.Library
?.Library
loadedNamespaces()
unloadNamespace("utils")
unloadNamespace("stats")
unloadNamespace("grDevices")
unloadNamespace("graphics")
unloadNamespace("grDevices")
setwd("D:/D Desktop/Publications/R package tinycodet/tinycodet/R")
#' @keywords internal
#' @noRd
.internal_force_libPaths <- function(lib_vec) {
# from https://milesmcbain.com/posts/hacking-r-library-paths/
lib_vec <- normalizePath(lib_vec, mustWork = TRUE)
shim_fun <- .libPaths
shim_env <- new.env(parent = environment(shim_fun))
shim_env$.Library <- character()
shim_env$.Library.site <- character()
environment(shim_fun) <- shim_env
shim_fun(lib_vec)
}
.internal_force_libPaths(getwd())
.libPaths()
loadNamespace("abind")
ab <- loadNamespace("abind")
?object.size
??object.size
?tools::dependsOnPkgs
?library
loadNamespace
?grep
utils::compareVersion
?utils::compareVersion
pkgs <- c("dplyr", "tibble")
versions_loaded <- lapply(pkgs, getNamespaceVersion) |> unlist()
lib.loc = .libPaths()
versions_lib <- lapply(pkgs, \(x)as.character(utils::packageVersion(x, lib.loc = lib.loc))) |>
unlist()
pkgs <- c("data.table", "collapse")
versions_loaded <- lapply(pkgs, getNamespaceVersion) |> unlist()
versions_lib <- lapply(pkgs, \(x)as.character(utils::packageVersion(x, lib.loc = lib.loc))) |>
unlist()
pkgs <- c("stringi", "abind")
versions_loaded <- lapply(pkgs, getNamespaceVersion) |> unlist()
versions_lib <- lapply(pkgs, \(x)as.character(utils::packageVersion(x, lib.loc = lib.loc))) |>
unlist()
versions_compare <- utils::compareVersion(versions_loaded, versions_lib)
versions_compare <- mapply(utils::compareVersion, versions_loaded, versions_lib)
?mapply
?stringi::stri_locate()
?stringi::stri_locate_all
library(tinycodet)
?stringi::stri_extract_all
?tinycodet::tinycodet_strings
library(tinycodet)
library(tinytest)
x <- c(TRUE, FALSE, TRUE, FALSE)
y <- c(FALSE, TRUE, TRUE, FALSE)
outcome <- data.frame(
x=x, y=y,
"x %xor% y"=x %xor% y, "x %n&% y" = x %n&% y, "x %?=% y" = x %?=% y,
check.names = FALSE
)
expected <- data.frame(
x,y,
"x %xor% y"=c(T,T,F,F),
"x %n&% y" =c(F,F,F,T),
"x %?=% y" =c(F,F,F,F),
check.names = FALSE
)
x <- c(TRUE, FALSE)
expect_equal(outcome, expected)
# basic ====
x <- c(TRUE, FALSE, TRUE, FALSE)
y <- c(FALSE, TRUE, TRUE, FALSE)
outcome <- data.frame(
x=x, y=y,
"x %xor% y"=x %xor% y, "x %n&% y" = x %n&% y, "x %?=% y" = x %?=% y,
check.names = FALSE
)
expected <- data.frame(
x,y,
"x %xor% y"=c(T,T,F,F),
"x %n&% y" =c(F,F,F,T),
"x %?=% y" =c(F,F,F,F),
check.names = FALSE
)
expect_equal(outcome, expected)
x <- c(TRUE, FALSE)
y <- c(FALSE, TRUE, TRUE, FALSE)
outcome <- data.frame(
x=x, y=y,
"x %xor% y"=x %xor% y, "x %n&% y" = x %n&% y, "x %?=% y" = x %?=% y,
check.names = FALSE
)
expected <- data.frame(
x,y,
"x %xor% y"=c(T,T,F,F),
"x %n&% y" =c(F,F,F,T),
"x %?=% y" =c(F,F,F,F),
check.names = FALSE
)
expect_equal(outcome, expected)
x <- c(TRUE, FALSE)
y <- c(FALSE, TRUE, TRUE, FALSE)
outcome <- data.frame(
x=x, y=y,
"x %xor% y"=x %xor% y, "x %n&% y" = x %n&% y, "x %?=% y" = x %?=% y,
check.names = FALSE
)
outcome
out <- logical(max(c(length(x), length(y))))
ind <- is.na(x)|is.na(y)
out[ind] <- NA
ind <- !ind
x <- x[ind]
ifelse
#' Additional Logic Operators
#'
#' @description
#' Additional logic operators: \cr
#' \cr
#' The \code{x %xor% y} operator is the "exclusive-or" operator, the same as \link{xor}\code{(x, y)}. \cr
#' \cr
#' The \code{x %n&%} operator is the "not-and" operator, the same as \code{(!x) & (!y)}. \cr
#' \cr
#' The \code{x %out% y} operator is the same as \code{!x %in% y}. \cr
#' \cr
#' The \code{x %?=% y} operator checks if \code{x} and \code{y}
#' are **both** unreal or unknown (i.e. NA, NaN, Inf, -Inf). \cr
#' \cr
#' The \code{n %=numtype% numtype} operator checks
#' for every value of numeric vector \code{n}
#' if it can be considered a number belonging to type \code{numtype}. \cr
#' \cr
#' The \code{s %=strtype% strtype} operator checks
#' for every value of character vector \code{s}
#' if it can seen as a certain \code{strtype}. \cr
#' \cr
#'
#' @param x,y see \link[base]{Logic}.
#' @param n a numeric vector.
#' @param s a character vector.
#' @param numtype a single string giving the numeric type to be checked. \cr
#' See Details section for supported types.
#' @param strtype a single string giving the string type to be checked. \cr
#' See Details section for supported types.
#'
#'
#' @details
#'
#' For argument \code{numtype}, the following options are supported: \cr
#'  *  \code{"~0"}: zero, or else a number whose absolute value is smaller than the
#'  Machine tolerance (\code{sqrt(.Machine$double.eps)}).
#'  *  \code{"B"}: binary numbers (exactly 0 or exactly 1);
#'  *  \code{"prop"}: proportions - numbers between 0 and 1 (exactly 0 or 1 is also allowed);
#'  *  \code{"I"}: Integers;
#'  *  \code{"odd"}: odd integers;
#'  *  \code{"even"}: even integers;
#'  *  \code{"R"}: Real numbers;
#'  *  \code{"unreal"}: infinity, NA, or NaN; \cr \cr
#'
#'
#'
#' For argument \code{strtype}, the following options are supported: \cr
#'  *  \code{"empty"}: checks if the string only consists of empty spaces.
#'  *  \code{"unreal"}: checks if the string is NA, or if it has literal string "NA", "NaN" or "Inf",
#'  regardless if it has leading or trailing spaces.
#'  *  \code{"numeric"}: checks if the string can be converted to a number,
#'  disregarding leading and trailing spaces.
#'  I.e. the string "5.0" can be converted to the the actual number \code{5.0}.
#'  *  \code{"special"}: checks if the string consists of only special characters. \cr \cr
#'
#'
#' @returns
#' A logical vector.
#'
#'
#' @examples
#' x <- c(TRUE, FALSE, TRUE, FALSE, NA, NaN, Inf, -Inf, TRUE, FALSE)
#' y <- c(FALSE, TRUE, TRUE, FALSE, rep(NA, 6))
#' outcome <- data.frame(
#'   x=x, y=y,
#'   "x %xor% y"=x %xor% y, "x %n&% y" = x %n&% y, "x %?=% y" = x %?=% y,
#'   check.names = FALSE
#' )
#' print(outcome)
#'
#' 1:3 %out% 1:10
#' 1:10 %out% 1:3
#'
#'
#' n <- c(0:5, 0:-5, 0.1, -0.1, 0, 1, Inf, -Inf, NA, NaN)
#' 1e-20 %=numtype% "~0"
#' n[n %=numtype% "B"]
#' n[n %=numtype% "prop"]
#' n[n %=numtype% "I"]
#' n[n %=numtype% "odd"]
#' n[n %=numtype% "even"]
#' n[n %=numtype% "R"]
#' n[n %=numtype% "unreal"]
#'
#' s <- c(" AbcZ123 ", " abc ", " 1.3 ", " !#$%^&*() ", "  ", "  NA  ", "  NaN  ", " Inf ")
#' s[s %=strtype% "empty"]
#' s[s %=strtype% "unreal"]
#' s[s %=strtype% "numeric"]
#' s[s %=strtype% "special"]
#'
#'
#'
#' @name logic_ops
NULL
#' @rdname logic_ops
#' @export
`%xor%` <- function(x, y) {
return(xor(x,y))
}
#' @rdname logic_ops
#' @export
`%n&%` <- function(x, y) {
return(ifelse(is.na(x) | is.na(y), NA, (!x) & (!y)))
}
#' @rdname logic_ops
#' @export
`%out%` <- function(x, y) {
return(!x %in% y)
}
#' @rdname logic_ops
#' @export
`%?=%` <- function(x, y) {
check.x <- is.na(x) | is.nan(x) | is.infinite(x)
check.y <- is.na(y) | is.nan(y) | is.infinite(y)
return(check.x & check.y)
}
#' @rdname logic_ops
#' @export
`%=numtype%` <- function(n, numtype) {
if(length(numtype) > 1){stop("`numtype` must be a single string")}
if(! numtype %in% c("unreal", "~0", "B", "prop", "I", "odd", "even", "R")){
stop("numtype not recognised")
}
if(!is.numeric(n)) { stop("`n` must be numeric") }
check.unreal <- is.infinite(n) | is.nan(n) | is.na(n)
return(switch(
numtype,
"unreal" = check.unreal,
"~0" = ifelse(check.unreal, FALSE, abs(n) < sqrt(.Machine$double.eps)),
"B" = ifelse(check.unreal, FALSE, n %in% c(0, 1)),
"prop" = ifelse(check.unreal, FALSE, n >= 0 & n <= 1),
"I" = ifelse(check.unreal, FALSE, n==round(n)),
"odd" = ifelse(check.unreal, FALSE, n==round(n) & !(n/2 == round(n/2))),
"even" = ifelse(check.unreal, FALSE, n==round(n) & (n/2 == round(n/2))),
"R" = !check.unreal
))
}
#' @rdname logic_ops
#' @export
`%=strtype%` <- function(s, strtype) {
if(length(strtype)>1){stop("`strtype` must be a single string")}
if(! strtype %in% c("unreal", "empty", "numeric", "special")){
stop("strtype not recognised")
}
if(!is.character(s)) { stop("`s` must be character") }
check.unreal <- is.na(s)
s.clean <- trimws(s, which="both")
return(switch(
strtype,
"empty" = ifelse(
check.unreal, FALSE, s.clean==""
),
"unreal" = ifelse(
check.unreal, TRUE, s.clean=="NA"|s.clean=="NaN"|s.clean=="Inf"|s.clean=="-Inf"
),
"numeric" = ifelse(
check.unreal, FALSE, suppressWarnings(!is.na(as.numeric(s.clean)))
),
"special" = ifelse(
check.unreal, FALSE,
(nchar(s.clean)==nchar(gsub("[[:alnum:]]", "", s.clean))) & (nchar(s.clean)>0)
)
))
}
# basic ====
x <- c(TRUE, FALSE, TRUE, FALSE)
y <- c(FALSE, TRUE, TRUE, FALSE)
outcome <- data.frame(
x=x, y=y,
"x %xor% y"=x %xor% y, "x %n&% y" = x %n&% y, "x %?=% y" = x %?=% y,
check.names = FALSE
)
expected <- data.frame(
x,y,
"x %xor% y"=c(T,T,F,F),
"x %n&% y" =c(F,F,F,T),
"x %?=% y" =c(F,F,F,F),
check.names = FALSE
)
expect_equal(outcome, expected)
x <- c(TRUE, FALSE)
y <- c(FALSE, TRUE, TRUE, FALSE)
outcome <- data.frame(
x=x, y=y,
"x %xor% y"=x %xor% y, "x %n&% y" = x %n&% y, "x %?=% y" = x %?=% y,
check.names = FALSE
)
expected <- data.frame(
x,y,
"x %xor% y"=c(T,T,F,F),
"x %n&% y" =c(F,F,F,T),
"x %?=% y" =c(F,F,F,F),
check.names = FALSE
)
expect_equal(outcome, expected)
tinycodet::`%?=%`()
?tinycodet::`%?=%`()
library(tinycodet)
# input character vector:
x <- c(paste0(letters[1:13], collapse=""), paste0(letters[14:26], collapse=""))
print(x)
# report ith (second and second-last) vowel locations:
p <- rep("A|E|I|O|U", 2) # vowels
loc <- stri_locate_ith(x, c(2, -2), regex=p, case_insensitive=TRUE)
print(loc)
# extract ith vowels:
extr <- stringi::stri_sub(x, from=loc)
print(extr)
?chartr
repl <- chartr("aeiou", "12345", extr)
x <- stringi::stri_sub_replace(x, loc, replacement=repl)
print(x)
stringi::stri_sub("hello", from = 1, to = 10)
stringi::stri_sub("hello", from = 1, to = -1)
loadedNamespaces()
sessionInfo()
x <- 1:1e5
test <- x > (max(x)/2)
foo <- bench::mark(
ifelse(test, 1, -1),
transform_if(x, test, 1, -1),
kit::iif(test, 1, -1),
min_iterations = 1000
)
library(tinycodet)
library(ggplot2)
x <- 1:1e5
test <- x > (max(x)/2)
foo <- bench::mark(
ifelse(test, 1, -1),
transform_if(x, test, 1, -1),
kit::iif(test, 1, -1),
min_iterations = 1000
)
print(foo)
autoplot(foo)
autoplot(foo)
x <- 1:1e6
test <- x > (max(x)/2)
foo <- bench::mark(
ifelse(test, 1, -1),
transform_if(x, test, 1, -1),
kit::iif(test, 1, -1),
min_iterations = 1000
)
print(foo)
autoplot(foo)
x <- rnorm(1000)
x <- rnorm(1e6)
y <- rnorm(1e6)
?bench::mark
x <- rnorm(1e6)
y <- rnorm(1e6)
bench::mark(
x > y
x >= y,
bench::mark(
x > y,
x >= y,
check = FALSE,
min_iterations = 1000
)
foo <- bench::mark(
x > y,
x >= y,
check = FALSE,
min_iterations = 1000
)
print(foo)
autoplot(foo)
?kit::iif
?data.table::ifelse
