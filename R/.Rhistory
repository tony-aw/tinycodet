return(do.call(stringi::stri_extract_all, c(list(str = x), p)))
} else if(is.character(p)) {
return(stringi::stri_extract_all(
x, regex = p, ...
))
} else {
stop("`p` must be a character vector or list")
}
}
}
#' @rdname str_truth
#' @export
`strfind<-` <- function(x, p, ..., value) {
if(is.list(p)){
args <- list(str = x, vectorize_all = TRUE, replacement = value)
return(do.call(stringi::stri_replace_all, c(args, p)))
} else if(is.character(p)) {
return(stringi::stri_replace_all(
x, replacement = value, regex = p, vectorize_all = TRUE, ...
))
} else {
stop("`p` must be a character vector or list")
}
}
x <- rep('The quick brown fox jumped over the lazy dog.', 3)
print(x)
p <- c('quick', 'brown', 'fox')
rp <- c('slow',  'black', 'bear')
x %s{}% p
strfind(x, p)
strfind(x, p) <- rp
print(x)
# strfind - locate all ====
tempfun <- stringi::stri_locate_all
library(tinycodet)
# strfind - locate all ====
tempfun <- stringi::stri_locate_all
# regex
x <- c(paste0(letters[1:13], collapse=""), paste0(letters[14:26], collapse=""))
out1 <- strfind(x, s_regex(c("A|E|I|O|U","a|e|i|o|u"), case_insensitive=TRUE), "all")
out2 <- strfind(x, s_regex(c("A|E|I|O|U","a|e|i|o|u"), case_insensitive=FALSE), "all")
expect_equal(out1, tempfun(x, regex = c("A|E|I|O|U","a|e|i|o|u"), case_insensitive=TRUE))
expect_equal(out2, tempfun(x, regex = c("A|E|I|O|U","a|e|i|o|u"), case_insensitive=FALSE))
library(tinytest)
# strfind - locate all ====
tempfun <- stringi::stri_locate_all
# regex
x <- c(paste0(letters[1:13], collapse=""), paste0(letters[14:26], collapse=""))
out1 <- strfind(x, s_regex(c("A|E|I|O|U","a|e|i|o|u"), case_insensitive=TRUE), "all")
out2 <- strfind(x, s_regex(c("A|E|I|O|U","a|e|i|o|u"), case_insensitive=FALSE), "all")
expect_equal(out1, tempfun(x, regex = c("A|E|I|O|U","a|e|i|o|u"), case_insensitive=TRUE))
expect_equal(out2, tempfun(x, regex = c("A|E|I|O|U","a|e|i|o|u"), case_insensitive=FALSE))
# fixed
x <- c(
paste0(letters[1:13], collapse=""),
paste0(letters[14:26], collapse=""),
paste0(LETTERS[1:13], collapse=""),
paste0(LETTERS[14:26], collapse="")
)
print(x)
out1 <- strfind(x, s_regex(c("ab"), case_insensitive=TRUE), "all")
out2 <- strfind(x, s_regex(c("ab"), case_insensitive=FALSE), "all")
expect_equal(out1, tempfun(x, fixed = c("ab"), case_insensitive=TRUE))
expect_equal(out2, tempfun(x, fixed = c("ab"), case_insensitive=FALSE))
# coll
x <- c('hladn\u00FD', 'hladny')
out <- strfind(x, s_coll('HLADNY', strength=1, locale='sk_SK'), "all")
expect_equal(out, tempfun(x, coll = 'HLADNY', strength=1, locale='sk_SK'))
# charclass, merge = TRUE
x <- c('stRRRingi','R STRINGI', '123')
p <- c('\\p{Ll}', '\\p{Lu}', '\\p{Zs}')
out <- strfind(x, s_chrcls(p), "all")
expect_equal(out, tempfun(x, charclass = p))
# charclass, merge = FALSE
x <- c('stRRRingi','R STRINGI', '123')
p <- c('\\p{Ll}', '\\p{Lu}', '\\p{Zs}')
out <- strfind(x, s_chrcls(p), "all", merge = FALSE)
expect_equal(out, tempfun(x, charclass = p, merge = FALSE))
# strfind - positions ====
# regex
x <- rep(paste0(0:9, collapse=""), 10)
print(x)
p <- s_regex("\\d", case_insensitive = TRUE)
out1 <- strfind(x, p, 1:10)
out2 <- strfind(x, p, -1:-10)
outcome <- cbind(0:9, out1, out2)
expected <- cbind(0:9, 1:10, 1:10, 10:1, 10:1)
colnames(expected) <- c("", "start", "end", "start", "end")
expect_equal(expected, outcome)
# strfind - extract all ====
tempfun <- stringi::stri_extract_all
# regex
x <- c(paste0(letters[1:13], collapse=""), paste0(letters[14:26], collapse=""))
out1 <- strfind(x, s_regex(c("A|E|I|O|U","a|e|i|o|u"), case_insensitive=TRUE))
#' 'stringi' Pattern Search Operators, and the strfind Method
#'
#' @description
#'
#' The \code{x %s{}% p} operator
#' checks for every string in character vector \code{x} if
#' the pattern defined in \code{p} is present. \cr
#' \cr
#' The \code{x %s!{}% p} operator
#' checks for every string in character vector \code{x} if
#' the pattern defined in \code{p} is NOT present. \cr
#' \cr
#' For string (in)equality operators, see \link[stringi]{%s==%} from the 'stringi' package. \cr
#' \cr
#' The \code{strfind()} method,
#' although technically not an operator,
#' is meant to complement the string-related infix operators,
#' and therefore uses the same \link{s_pattern} API as (for example)
#' the \code{%s{}% and %s!{}%} operators. \cr
#' It functions as follows:
#'  * \code{strfind()} attempts to find all pattern matches,
#' and returns the extractions of the findings in a list,
#' just like \link[stringi]{stri_extract_all}.
#'  * \code{strfind(..., i = "all")} attempts to find all pattern matches,
#' and reports the locations of the findings in a list,
#' just like \link[stringi]{stri_locate_all}.
#'  * \code{strfind(..., i = i)}, where \code{i} is a non-zero integer,
#' locates the \eqn{i^{th}} occurrence of a pattern,
#' and reports the locations in a matrix,
#' just like \link{stri_locate_ith}.
#'  * \code{strfind(...) <- value} attempts to find all pattern matches,
#' and replaces them with the character vector specified in \code{value}. \cr
#' This is similar to \link[stringi]{stri_replace_all},
#' except the replacement is done in-place
#' (though not by reference, technically speaking). \cr \cr
#'
#'
#'
#' @param x a string or character vector.
#' @param p either a list with 'stringi' arguments (see \link{s_pattern}),
#' or else a character vector of the same length as \code{x} or length 1
#' with regular expressions. \cr
#' `r .mybadge_string("regex", "darkred")` \cr
#' `r .mybadge_string("fixed", "darkgreen")` \cr
#' `r .mybadge_string("coll", "pink")` \cr
#' `r .mybadge_string("charclass", "lightyellow")` \cr
#' @param i either one of the following:
#'  * if \code{i} is not given or \code{NULL},
#'  \code{strfind()} extracts all found pattern occurrences.
#'  * if \code{i = "all"}, \code{strfind()} locates all found pattern occurrences.
#'  * if \code{i} is an integer,
#'  \code{strfind()} locates the \eqn{i^{th}} pattern occurrences. \cr
#'  See the `i` argument in \link{stri_locate_ith} for details.
#'  * for \code{strfind() <- value}, `i` must not be specified.
#' @param value a character vector giving the replacement values.
#' @param ... additional arguments to be passed to the 'stringi' functions. \cr \cr
#'
#'
#'
#' @returns
#' The \code{x %s{}% p} and \code{x %s!{}% p} operators
#' return logical vectors, where \code{TRUE} indicates a pattern was found,
#' and \code{FALSE} indicates a pattern was not found. \cr
#' \cr
#' \code{strfind()} returns a list with extractions of all found patterns. \cr
#' \cr
#' \code{strfind(..., i = "all")} returns a list with all found pattern locations. \cr
#' \cr
#' \code{strfind(..., i = i)},
#' with `i` being an integer,
#' returns a matrix with the \eqn{i^{th}} occurrences of the patterns. \cr
#' \cr
#' \code{strfind(x, p) <- value} returns nothing,
#' but performs in-place replacement of the found patterns in `x`. \cr
#'
#'
#' @seealso [tinycodet_strings()]
#'
#'
#' @examples
#'
#' # simple example ====
#'
#' x <- c(paste0(letters[1:13], collapse=""), paste0(letters[14:26], collapse=""))
#' print(x)
#' x %s{}% "a"
#' x %s!{}% "a"
#' which(x %s{}% "a")
#' which(x %s!{}% "a")
#' x[x %s{}% "a"]
#' x[x %s!{}% "a"]
#' x[x %s{}% "a"] <- 1
#' x[x %s!{}% "a"] <- 1
#' print(x)
#'
#' x <- c(paste0(letters[1:13], collapse=""), paste0(letters[14:26], collapse=""))
#' x %s{}% "1"
#' x %s!{}% "1"
#' which(x %s{}% "1")
#' which(x %s!{}% "1")
#' x[x %s{}% "1"]
#' x[x %s!{}% "1"]
#' x[x %s{}% "1"] <- "a"
#' x[x %s!{}% "1"] <- "a"
#' print(x)
#'
#'
#' #############################################################################
#'
#' # More complex example ====
#'
#' x <- rep('The quick brown fox jumped over the lazy dog.', 3)
#' print(x)
#' p <- c('quick', 'brown', 'fox')
#' rp <- c('slow',  'black', 'bear')
#' x %s{}% p
#' strfind(x, p)
#' strfind(x, p) <- rp
#' print(x)
#'
#' x <- c(paste0(letters[1:13], collapse=""), paste0(letters[14:26], collapse=""))
#' print(x)
#'
#' # report ith (second and second-last) vowel locations:
#' p <- s_regex( # vowels
#'   rep("A|E|I|O|U", 2),
#'   case_insensitive=TRUE
#' )
#' loc <- strfind(x, p, i = c(2, -2))
#' print(loc)
#'
#' # extract ith vowels:
#' extr <- stringi::stri_sub(x, from = loc)
#' print(extr)
#'
#' # replace ith vowels with numbers:
#' repl <- chartr("aeiou", "12345", extr)
#' stringi::stri_sub(x, loc) <- repl
#' print(x)
#'
#'
#' @name str_truth
NULL
#' @rdname str_truth
#' @export
`%s{}%` <- function(x, p) {
if(is.list(p)){
return(do.call(stringi::stri_detect, c(list(str = x), p)))
}
if(is.character(p)) {
return(stringi::stri_detect(x, regex=p))
} else {
stop("right hand side must be a character vector or list")
}
}
#' @rdname str_truth
#' @export
`%s!{}%` <- function(x, p) {
if(is.list(p)){
return(!do.call(stringi::stri_detect, c(list(str = x), p)))
}
if(is.character(p)) {
return(!stringi::stri_detect(x, regex=p))
} else {
stop("right hand side must be a character vector or list")
}
}
#' @rdname str_truth
#' @export
strfind <- function(x, p, i, ...) {
if(is.numeric(i)) {
if(is.list(p)){
args <- list(str = x, i = i)
return(do.call(stri_locate_ith, c(args, p, list(...))))
} else if(is.character(p)) {
return(stri_locate_ith(
str = x, i = i, regex = p, ...
))
} else {
stop("`p` must be a character vector or list")
}
}
else if(i == "all") {
if(is.list(p)){
return(do.call(stringi::stri_locate_all, c(list(str = x), p, list(...))))
} else if(is.character(p)) {
return(stringi::stri_locate_all(
str = x, regex = p, ...
))
} else {
stop("`p` must be a character vector or list")
}
}
else if(is.null(i)) {
if(is.list(p)){
return(do.call(stringi::stri_extract_all, c(list(str = x), p, list(...))))
} else if(is.character(p)) {
return(stringi::stri_extract_all(
str = x, regex = p, ...
))
} else {
stop("`p` must be a character vector or list")
}
}
else {
stop("improper `i` given")
}
}
#' @rdname str_truth
#' @export
`strfind<-` <- function(x, p, ..., value) {
if(is.list(p)){
args <- list(str = x,replacement = value)
return(do.call(stringi::stri_replace_all, c(args, p)))
} else if(is.character(p)) {
return(stringi::stri_replace_all(
str = x, replacement = value, regex = p, ...
))
} else {
stop("`p` must be a character vector or list")
}
}
# strfind - extract all ====
tempfun <- stringi::stri_extract_all
# regex
x <- c(paste0(letters[1:13], collapse=""), paste0(letters[14:26], collapse=""))
out1 <- strfind(x, s_regex(c("A|E|I|O|U","a|e|i|o|u"), case_insensitive=TRUE))
out2 <- strfind(x, s_regex(c("A|E|I|O|U","a|e|i|o|u"), case_insensitive=FALSE))
#' @rdname str_truth
#' @export
strfind <- function(x, p, i = NULL, ...) {
if(is.numeric(i)) {
if(is.list(p)){
args <- list(str = x, i = i)
return(do.call(stri_locate_ith, c(args, p, list(...))))
} else if(is.character(p)) {
return(stri_locate_ith(
str = x, i = i, regex = p, ...
))
} else {
stop("`p` must be a character vector or list")
}
}
else if(i == "all") {
if(is.list(p)){
return(do.call(stringi::stri_locate_all, c(list(str = x), p, list(...))))
} else if(is.character(p)) {
return(stringi::stri_locate_all(
str = x, regex = p, ...
))
} else {
stop("`p` must be a character vector or list")
}
}
else if(is.null(i)) {
if(is.list(p)){
return(do.call(stringi::stri_extract_all, c(list(str = x), p, list(...))))
} else if(is.character(p)) {
return(stringi::stri_extract_all(
str = x, regex = p, ...
))
} else {
stop("`p` must be a character vector or list")
}
}
else {
stop("improper `i` given")
}
}
# strfind - extract all ====
tempfun <- stringi::stri_extract_all
# regex
x <- c(paste0(letters[1:13], collapse=""), paste0(letters[14:26], collapse=""))
out1 <- strfind(x, s_regex(c("A|E|I|O|U","a|e|i|o|u"), case_insensitive=TRUE))
out2 <- strfind(x, s_regex(c("A|E|I|O|U","a|e|i|o|u"), case_insensitive=FALSE))
#' @rdname str_truth
#' @export
strfind <- function(x, p, i = NULL, ...) {
if(!is.null(i) && is.numeric(i)) {
if(is.list(p)){
args <- list(str = x, i = i)
return(do.call(stri_locate_ith, c(args, p, list(...))))
} else if(is.character(p)) {
return(stri_locate_ith(
str = x, i = i, regex = p, ...
))
} else {
stop("`p` must be a character vector or list")
}
}
else if(!is.null(i) && i == "all") {
if(is.list(p)){
return(do.call(stringi::stri_locate_all, c(list(str = x), p, list(...))))
} else if(is.character(p)) {
return(stringi::stri_locate_all(
str = x, regex = p, ...
))
} else {
stop("`p` must be a character vector or list")
}
}
else if(is.null(i)) {
if(is.list(p)){
return(do.call(stringi::stri_extract_all, c(list(str = x), p, list(...))))
} else if(is.character(p)) {
return(stringi::stri_extract_all(
str = x, regex = p, ...
))
} else {
stop("`p` must be a character vector or list")
}
}
else {
stop("improper `i` given")
}
}
# strfind - extract all ====
tempfun <- stringi::stri_extract_all
# regex
x <- c(paste0(letters[1:13], collapse=""), paste0(letters[14:26], collapse=""))
out1 <- strfind(x, s_regex(c("A|E|I|O|U","a|e|i|o|u"), case_insensitive=TRUE))
out2 <- strfind(x, s_regex(c("A|E|I|O|U","a|e|i|o|u"), case_insensitive=FALSE))
expect_equal(out1, tempfun(x, regex = c("A|E|I|O|U","a|e|i|o|u"), case_insensitive=TRUE))
expect_equal(out2, tempfun(x, regex = c("A|E|I|O|U","a|e|i|o|u"), case_insensitive=FALSE))
# strfind - extract all ====
tempfun <- stringi::stri_extract_all
# regex
x <- c(paste0(letters[1:13], collapse=""), paste0(letters[14:26], collapse=""))
out1 <- strfind(x, s_regex(c("A|E|I|O|U","a|e|i|o|u"), case_insensitive=TRUE))
out2 <- strfind(x, s_regex(c("A|E|I|O|U","a|e|i|o|u"), case_insensitive=FALSE))
expect_equal(out1, tempfun(x, regex = c("A|E|I|O|U","a|e|i|o|u"), case_insensitive=TRUE))
expect_equal(out2, tempfun(x, regex = c("A|E|I|O|U","a|e|i|o|u"), case_insensitive=FALSE))
# fixed
x <- c(
paste0(letters[1:13], collapse=""),
paste0(letters[14:26], collapse=""),
paste0(LETTERS[1:13], collapse=""),
paste0(LETTERS[14:26], collapse="")
)
print(x)
out1 <- strfind(x, s_regex(c("ab"), case_insensitive=TRUE))
out2 <- strfind(x, s_regex(c("ab"), case_insensitive=FALSE))
expect_equal(out1, tempfun(x, fixed = c("ab"), case_insensitive=TRUE))
expect_equal(out2, tempfun(x, fixed = c("ab"), case_insensitive=FALSE))
# coll
x <- c('hladn\u00FD', 'hladny')
out <- strfind(x, s_coll('HLADNY', strength=1, locale='sk_SK'))
expect_equal(out, tempfun(x, coll = 'HLADNY', strength=1, locale='sk_SK'))
# charclass, merge = TRUE
x <- c('stRRRingi','R STRINGI', '123')
p <- c('\\p{Ll}', '\\p{Lu}', '\\p{Zs}')
out <- strfind(x, s_chrcls(p))
expect_equal(out, tempfun(x, charclass = p))
# charclass, merge = FALSE
x <- c('stRRRingi','R STRINGI', '123')
p <- c('\\p{Ll}', '\\p{Lu}', '\\p{Zs}')
out <- strfind(x, s_chrcls(p), merge = FALSE)
expect_equal(out, tempfun(x, charclass = p, merge = FALSE))
# strfind - replace all ====
tempfun <- stringi::stri_replace_all
# regex
x <- c(paste0(letters[1:13], collapse=""), paste0(letters[14:26], collapse=""))
rp <- "foo"
strfind(x, s_regex(c("A|E|I|O|U","a|e|i|o|u"), case_insensitive=TRUE)) <- rp
# regex
x <- c(paste0(letters[1:13], collapse=""), paste0(letters[14:26], collapse=""))
rp <- "foo"
y <- strfind(x, s_regex(c("A|E|I|O|U","a|e|i|o|u"), case_insensitive=TRUE)) <- rp
# regex
x <- c(paste0(letters[1:13], collapse=""), paste0(letters[14:26], collapse=""))
rp <- "foo"
strfind(x, s_regex(c("A|E|I|O|U","a|e|i|o|u"), case_insensitive=TRUE)) <- rp
# strfind - replace all ====
tempfun <- stringi::stri_replace_all
# regex
rp <- "foo"
x <- c(paste0(letters[1:13], collapse=""), paste0(letters[14:26], collapse=""))
strfind(x, s_regex(c("A|E|I|O|U","a|e|i|o|u"), case_insensitive=TRUE)) <- rp
out1 <- x
x <- c(paste0(letters[1:13], collapse=""), paste0(letters[14:26], collapse=""))
out2 <- strfind(x, s_regex(c("A|E|I|O|U","a|e|i|o|u"), case_insensitive=TRUE)) <- rp
expect_equal(out1, tempfun(x, regex = c("A|E|I|O|U","a|e|i|o|u"), case_insensitive=TRUE))
expect_equal(out2, tempfun(x, regex = c("A|E|I|O|U","a|e|i|o|u"), case_insensitive=FALSE))
# regex
rp <- "foo"
x <- c(paste0(letters[1:13], collapse=""), paste0(letters[14:26], collapse=""))
strfind(x, s_regex(c("A|E|I|O|U","a|e|i|o|u"), case_insensitive=TRUE)) <- rp
out1 <- x
x <- c(paste0(letters[1:13], collapse=""), paste0(letters[14:26], collapse=""))
strfind(x, s_regex(c("A|E|I|O|U","a|e|i|o|u"), case_insensitive=TRUE)) <- rp
out2 <- x
expect_equal(out1, tempfun(x, regex = c("A|E|I|O|U","a|e|i|o|u"), case_insensitive=TRUE))
expect_equal(out1, tempfun(x, rp, regex = c("A|E|I|O|U","a|e|i|o|u"), case_insensitive=TRUE))
expect_equal(out2, tempfun(x, rp, regex = c("A|E|I|O|U","a|e|i|o|u"), case_insensitive=FALSE))
# regex
rp <- "foo"
x <- c(paste0(letters[1:13], collapse=""), paste0(letters[14:26], collapse=""))
strfind(x, s_regex(c("A|E|I|O|U","a|e|i|o|u"), case_insensitive=TRUE)) <- rp
out1 <- x
x <- c(paste0(letters[1:13], collapse=""), paste0(letters[14:26], collapse=""))
strfind(x, s_regex(c("A|E|I|O|U","a|e|i|o|u"), case_insensitive=TRUE)) <- rp
out2 <- x
tempfun(x, rp, regex = c("A|E|I|O|U","a|e|i|o|u"), case_insensitive=TRUE)
# regex
rp <- "foo"
x <- c(paste0(letters[1:13], collapse=""), paste0(letters[14:26], collapse=""))
strfind(x, s_regex(c("A|E|I|O|U","a|e|i|o|u"), case_insensitive=TRUE)) <- rp
out1 <- x
x <- c(paste0(letters[1:13], collapse=""), paste0(letters[14:26], collapse=""))
strfind(x, s_regex(c("A|E|I|O|U","a|e|i|o|u"), case_insensitive=TRUE)) <- rp
out2 <- x
x <- c(paste0(letters[1:13], collapse=""), paste0(letters[14:26], collapse=""))
expect_equal(out1, tempfun(x, rp, regex = c("A|E|I|O|U","a|e|i|o|u"), case_insensitive=TRUE))
expect_equal(out2, tempfun(x, rp, regex = c("A|E|I|O|U","a|e|i|o|u"), case_insensitive=FALSE))
x <- c(paste0(letters[1:13], collapse=""), paste0(letters[14:26], collapse=""))
expect_equal(out1, tempfun(x, rp, regex = c("A|E|I|O|U","a|e|i|o|u"), case_insensitive=TRUE))
x <- c(paste0(letters[1:13], collapse=""), paste0(letters[14:26], collapse=""))
expect_equal(out2, tempfun(x, rp, regex = c("A|E|I|O|U","a|e|i|o|u"), case_insensitive=FALSE))
