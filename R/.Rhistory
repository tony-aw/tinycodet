#' @param type single string;
#' either the break iterator type,
#' one of \code{character}, \code{line_break}, \code{sentence}, \code{word},
#' or a custom set of ICU break iteration rules. Defaults to \code{"character"}. \cr
#' `r .mybadge_string("boundaries", "blue")` \cr
#' @param i a number, or a numeric vector of the same length as \code{str}. \cr
#' Positive numbers are counting from the left. Negative numbers are counting from the right.
#' I.e.:
#' \itemize{
#'  \item \code{stri_locate_ith(str, i=1, ...)} \cr
#' gives the position (range) of the first occurrence of a pattern.
#'  \item \code{stri_locate_ith(str, i=-1, ...)} \cr
#' gives the position (range) of the last occurrence of a pattern.
#'  \item \code{stri_locate_ith(str, i=2, ...)}\cr
#' gives the position (range) of the second occurrence of a pattern.
#'  \item \code{stri_locate_ith(str, i=-2, ...)} \cr
#' gives the position (range) of the second-last occurrence of a pattern.
#' }
#' If \code{abs(i)} is larger than the number of instances,
#' the first (if \code{i < 0}) or last (if \code{i > 0}) instance will be given. \cr
#' For example: suppose a string has \code{3} instances of some pattern; \cr
#' then if \code{i >= 3} the third instance will be located, \cr
#' and if \code{i <= -3} the first instance will be located. \cr
#' @param ... more arguments to be supplied to
#' \link[stringi]{stri_locate} or \link[stringi]{stri_locate_all_boundaries}. \cr
#' Do not supply the arguments
#' \code{omit_no_match}, \code{get_length}, or \code{pattern},
#' as they are already specified internally.
#' Supplying these arguments anyway will result in an error.
#' @param opts_regex,opts_fixed,opts_collator
#' named list used to tune up the selected search engine's settings. \cr
#' see \link[stringi]{stri_opts_regex},
#' \link[stringi]{stri_opts_fixed},
#' and \link[stringi]{stri_opts_collator}. \cr
#' NULL for the defaults.
#' @param merge logical, indicating if charclass locations should be merged or not. \cr
#' \bold{Details:} \cr
#' For the \code{charclass} pattern type,
#' the \code{stri_locate_ith} function gives the start and end of
#' \bold{consecutive} characters by default,
#' just like \link[stringi]{stri_locate_all}. \cr
#' To give the start and end positions of single characters,
#' much like \link[stringi]{stri_locate_first} or \link[stringi]{stri_locate_last},
#' set \code{merge = FALSE}.
#'
#'
#' @section Warning:
#' The \code{capture_group} argument for regex is not (yet) supported.
#'
#'
#'
#'
#' @returns
#' The \code{stri_locate_ith()} function returns an integer matrix with two columns,
#' giving the start and end positions of the \eqn{i^{th}} matches,
#' two \code{NA}s if no matches are found,
#' and also two \code{NA}s if \code{str} is \code{NA}.\cr
#' \cr
#'
#' @seealso [tinycodet_strings()]
#'
#'
#' @examples
#'
#' #############################################################################
#'
#' # practical example with regex & fixed ====
#'
#' # input character vector:
#' x <- c(paste0(letters[1:13], collapse=""), paste0(letters[14:26], collapse=""))
#' print(x)
#'
#' # report ith (second and second-last) vowel locations:
#' p <- rep("A|E|I|O|U", 2) # vowels
#' loc <- stri_locate_ith(x, c(2, -2), regex=p, case_insensitive=TRUE)
#' print(loc)
#'
#' # extract ith vowels:
#' extr <- stringi::stri_sub(x, from=loc)
#' print(extr)
#'
#' # replace ith vowels with numbers:
#' repl <- chartr("aeiou", "12345", extr)
#' x <- stringi::stri_sub_replace(x, loc, replacement=repl)
#' print(x)
#'
#'
#' #############################################################################
#'
#' # practical example with boundaries ====
#'
#' # input character vector:
#' x <- c("good morning and good night",
#' "hello ladies and gentlemen")
#' print(x)
#'
#' # report ith word locations:
#' loc <- stri_locate_ith_boundaries(x, c(-3, 3), type = "word")
#' print(loc)
#'
#' # extract ith words:
#' extr <- stringi::stri_sub(x, from=loc)
#' print(extr)
#'
#' # transform and replace words:
#' tf <- chartr(extr, old = "a-zA-Z", new = "A-Za-z")
#' x <- stringi::stri_sub_replace(x, loc, replacement=tf)
#' print(x)
#'
#'
#' #############################################################################
#'
#' # find pattern ====
#'
#' extr <- stringi::stri_sub(x, from=loc)
#' repl <- chartr(extr, old = "a-zA-Z", new = "A-Za-z")
#' stringi::stri_sub_replace(x, loc, replacement=repl)
#'
#' # simple pattern ====
#'
#' x <- rep(paste0(1:10, collapse=""), 10)
#' print(x)
#' out <- stri_locate_ith(x, 1:10, regex = as.character(1:10))
#' cbind(1:10, out)
#'
#'
#' x <- c(paste0(letters[1:13], collapse=""), paste0(letters[14:26], collapse=""))
#' print(x)
#' p <- rep("a|e|i|o|u",2)
#' out <- stri_locate_ith(x, c(-1, 1), regex=p)
#' print(out)
#' substr(x, out[,1], out[,2])
#'
#'
#' #############################################################################
#'
#' # ignore case pattern ====
#'
#'
#' x <- c(paste0(letters[1:13], collapse=""), paste0(letters[14:26], collapse=""))
#' print(x)
#' p <- rep("A|E|I|O|U", 2)
#' out <- stri_locate_ith(x, c(1, -1), regex=p, case_insensitive=TRUE)
#' substr(x, out[,1], out[,2])
#'
#'
#' #############################################################################
#'
#' # multi-character pattern ====
#'
#' x <- c(paste0(letters[1:13], collapse=""), paste0(letters[14:26], collapse=""))
#' print(x)
#' # multi-character pattern:
#' p <- rep("AB", 2)
#' out <- stri_locate_ith(x, c(1, -1), regex=p, case_insensitive=TRUE)
#' print(out)
#' substr(x, out[,1], out[,2])
#'
#'
#'
#' #############################################################################
#'
#' # Replacement transformation using stringi ====
#'
#' x <- c("hello world", "goodbye world")
#' loc <- stri_locate_ith(x, c(1, -1), regex="a|e|i|o|u")
#' extr <- stringi::stri_sub(x, from=loc)
#' repl <- chartr(extr, old = "a-zA-Z", new = "A-Za-z")
#' stringi::stri_sub_replace(x, loc, replacement=repl)
#'
#'
#' #############################################################################
#'
#' # Boundaries ====
#'
#' test <- c(
#' paste0("The\u00a0above-mentioned    features are very useful. ",
#'       "Spam, spam, eggs, bacon, and spam. 123 456 789"),
#'       "good morning, good evening, and good night"
#'       )
#' loc <- stri_locate_ith_boundaries(test, i = c(1, -1), type = "word")
#' stringi::stri_sub(test, from=loc)
#'
#' @rdname stri_locate_ith
#' @export
stri_locate_ith <- function(
str, i, ... , regex, fixed, coll, charclass
) {
providedarg <- c(
regex = !missing(regex), fixed = !missing(fixed),
coll = !missing(coll), charclass = !missing(charclass)
)
if(sum(providedarg) != 1) {
stop(
"you have to specify either `regex`, `fixed`, `coll`, `charclass`"
)
}
if (providedarg["regex"])
{
return(stri_locate_ith_regex(str = str, pattern = regex, i = i, ...))
}
else if (providedarg["fixed"])
{
return(stri_locate_ith_fixed(str = str, pattern = fixed, i = i, ...))
}
else if (providedarg["coll"])
{
return(stri_locate_ith_coll(str = str, pattern = coll, i = i, ...))
}
else if (providedarg["charclass"])
{
return(stri_locate_ith_charclass(str = str, pattern = charclass, i = i, ...))
}
}
#' @rdname stri_locate_ith
#' @export
stri_locate_ith_regex <- function(str, pattern, i, ..., opts_regex = NULL) {
n <- length(str)
p1 <- stringi::stri_locate_all_regex(
str=str, pattern = pattern, capture_groups = FALSE,
omit_no_match = FALSE, get_length = FALSE,
..., opts_regex = opts_regex
)
return(.stri_locate_ith_internal(p1, i, n, sys.call()))
}
#' @rdname stri_locate_ith
#' @export
stri_locate_ith_fixed <- function(str, pattern, i, ..., opts_fixed = NULL) {
n <- length(str)
p1 <- stringi::stri_locate_all_fixed(
str, pattern, omit_no_match = FALSE, get_length = FALSE,
..., opts_fixed = opts_fixed
)
return(.stri_locate_ith_internal(p1, i, n, sys.call()))
}
#' @rdname stri_locate_ith
#' @export
stri_locate_ith_coll <- function(str, pattern, i, ..., opts_collator = NULL) {
n <- length(str)
p1 <- stringi::stri_locate_all_coll(
str = str, pattern = pattern, omit_no_match = FALSE, get_length = FALSE,
..., opts_collator = opts_collator
)
return(.stri_locate_ith_internal(p1, i, n, sys.call()))
}
#' @rdname stri_locate_ith
#' @export
stri_locate_ith_charclass <- function(str, pattern, i, merge = TRUE, ...) {
n <- length(str)
p1 <- stringi::stri_locate_all_charclass(
str = str, pattern = pattern, merge = merge,
omit_no_match = FALSE, get_length = FALSE,
...
)
return(.stri_locate_ith_internal(p1, i, n, sys.call()))
}
#' @rdname stri_locate_ith
#' @export
stri_locate_ith_boundaries <- function(
str, i, ... , type = "character"
) {
n <- length(str)
p1 <- stringi::stri_locate_all_boundaries(
str = str, type = type,
omit_no_match = FALSE, get_length = FALSE, ...
)
return(.stri_locate_ith_internal(p1, i, n, sys.call()))
}
#' @keywords internal
#' @noRd
.stri_locate_ith_internal <- function(p1, i, n, abortcall) {
if(length(i) == 1) i <- rep.int(i, n)
if(length(i) != n) {
stop(simpleError("`i` must be the same length as `str`, or be a length of 1", call = abortcall))
}
n.matches <- collapse::vlengths(p1) / 2
n.matches <- pmax(n.matches, 1) # if no matches found, n.matches must be 1 so that "match" NA is returned.
neg <- which(i < 0)
pos <- which(i > 0)
bad_i <- length(i) != (length(neg) + length(pos))
if(bad_i){
stop(simpleError("`i` is not allowed to be zero or NA", call = abortcall))
}
i[neg] <- pmax(n.matches[neg] - abs(i[neg] + 1), 1)
i[pos] <- pmin(i[pos], n.matches[pos])
rowind <- i + c(0, collapse::fcumsum.default(n.matches))[seq_len(n)]
mat <- do.call(rbind, p1)
mat <- mat[rowind, , drop = FALSE]
colnames(mat) <- c("start", "end")
return(mat)
}
stri_locate_ith_regex(x, 1, p, capture_group = TRUE)
#' @rdname stri_locate_ith
#' @export
stri_locate_ith_regex <- function(str, pattern, i, ..., opts_regex = NULL) {
n <- length(str)
p1 <- stringi::stri_locate_all_regex(
str=str, pattern = pattern, capture_groups = FALSE,
omit_no_match = FALSE, get_length = FALSE,
..., opts_regex = opts_regex
)
return(.stri_locate_ith_internal(p1, i, n, sys.call()))
}
stri_locate_ith_regex(x, 1, p, capture_group = TRUE)
x <- rep('The quick brown fox jumped over the lazy dog.', 3)
print(x)
p <- c('quick', 'brown', 'fox')
rp <- c('slow',  'black', 'bear')
x %s{}% p
library(tinycodet)
x <- rep('The quick brown fox jumped over the lazy dog.', 3)
print(x)
p <- c('quick', 'brown', 'fox')
rp <- c('slow',  'black', 'bear')
x %s{}% p
strfind(x, p)
strfind(x, p) <- rp
#' 'stringi' Pattern Detection Operators, and the stringfing Method
#'
#' @description
#'
#' The \code{x %s{}% p} operator
#' checks for every string in character vector \code{x} if
#' the pattern defined in \code{p} is present. \cr
#' \cr
#' The \code{x %s!{}% p} operator
#' checks for every string in character vector \code{x} if
#' the pattern defined in \code{p} is NOT present. \cr \cr
#' \cr
#' For string (in)equality operators, see \link[stringi]{%s==%} from the 'stringi' package. \cr
#' \cr
#' The \code{strfind()} method,
#' although technically not an operator,
#' is meant to complement the operators,
#' and uses the same \link{s_pattern} API as
#' the \code{%s{}% and %s!{}%} operators. \cr
#' \cr
#' \code{strfind()} by default attempts to find all pattern matches,
#' and reports all extracted findings in a list,
#' just like \link[stringi]{stri_extract_all}. \cr
#' \cr
#' \code{strfind(..., i = "all")} attempts to find all pattern matches,
#' and reports the locations of the findings in a list,
#' just like \link[stringi]{stri_locate_all}. \cr
#' \cr
#' \code{strfind(..., i = i)}, where \code{i} is a non-zero integer,
#' locates the \eqn{i^{th}} occurrence of a pattern,
#' and reports the locations in a matrix,
#' just like \link{stri_locate_ith}. \cr
#' \cr
#' \code{strfind(...) <- value} attempts to find all pattern matches,
#' and replaces them with the character vector specified in \code{value}. \cr
#' This is similar to \link[stringi]{stri_replace_all}\code{(..., vectorize_all = TRUE)},
#' except the replacement is done in-place
#' (though not by reference, technically speaking). \cr
#' \cr
#'
#'
#'
#' @param x a string or character vector.
#' @param p either a list with 'stringi' arguments (see \link{s_pattern}),
#' or else a character vector of the same length as \code{x} or length 1
#' with regular expressions. \cr
#' `r .mybadge_string("regex", "darkred")` \cr
#' `r .mybadge_string("fixed", "darkgreen")` \cr
#' `r .mybadge_string("coll", "pink")` \cr
#' `r .mybadge_string("charclass", "lightyellow")` \cr
#' @param i either one of the following:
#'  * if \code{i = NULL} (the default), \code{strfind()} extracts all found pattern occurrences.
#'  * if \code{i = "all"}, \code{strfind()} locates all found pattern occurrences.
#'  * if \code{i} is an integer,
#'  \code{strfind()} locates the \eqn{i^{th}} pattern occurrences. \cr
#'  See the `i` argument in \link{stri_locate_ith} for details.
#'  * for \code{strfind()<-}, `i` must not be specified.
#' @param ... additional arguments to be passed to the 'stringi' functions. \cr \cr
#'
#'
#'
#' @returns
#' The \code{x %s{}% p} and \code{x %s!{}% p} operators
#' return logical vectors, where \code{TRUE} indicates a pattern was found,
#' and \code{FALSE} indicates a pattern was not found. \cr
#'
#' @seealso [tinycodet_strings()]
#'
#'
#' @examples
#'
#' # simple pattern ====
#'
#' x <- c(paste0(letters[1:13], collapse=""), paste0(letters[14:26], collapse=""))
#' print(x)
#' x %s{}% "a"
#' x %s!{}% "a"
#' which(x %s{}% "a")
#' which(x %s!{}% "a")
#' x[x %s{}% "a"]
#' x[x %s!{}% "a"]
#' x[x %s{}% "a"] <- 1
#' x[x %s!{}% "a"] <- 1
#' print(x)
#'
#' x <- c(paste0(letters[1:13], collapse=""), paste0(letters[14:26], collapse=""))
#' x %s{}% "1"
#' x %s!{}% "1"
#' which(x %s{}% "1")
#' which(x %s!{}% "1")
#' x[x %s{}% "1"]
#' x[x %s!{}% "1"]
#' x[x %s{}% "1"] <- "a"
#' x[x %s!{}% "1"] <- "a"
#' print(x)
#'
#'
#' #############################################################################
#'
#' x <- rep('The quick brown fox jumped over the lazy dog.', 3)
#' print(x)
#' p <- c('quick', 'brown', 'fox')
#' rp <- c('slow',  'black', 'bear')
#' x %s{}% p
#' strfind(x, p)
#' strfind(x, p) <- rp
#' print(x)
#'
#'
#' @name str_truth
NULL
#' @rdname str_truth
#' @export
`%s{}%` <- function(x, p) {
if(is.list(p)){
return(do.call(stringi::stri_detect, c(list(str=x), p)))
}
if(is.character(p)) {
return(stringi::stri_detect(x, regex=p))
} else {
stop("right hand side must be a character vector or list")
}
}
#' @rdname str_truth
#' @export
`%s!{}%` <- function(x, p) {
if(is.list(p)){
return(!do.call(stringi::stri_detect, c(list(str=x), p)))
}
if(is.character(p)) {
return(!stringi::stri_detect(x, regex=p))
} else {
stop("right hand side must be a character vector or list")
}
}
#' @rdname str_truth
#' @export
strfind <- function(x, p, i = NULL, ...) {
if(!is.null(i) && is.numeric(i)) {
if(is.list(p)){
args <- list(str = x, i = i)
return(do.call(stri_locate_ith, c(args, p)))
} else if(is.character(p)) {
return(stri_locate_ith(
x, i = i, regex = p, ...
))
} else {
stop("`p` must be a character vector or list")
}
}
if(!is.null(i) && i == "all") {
if(is.list(p)){
return(do.call(stringi::stri_locate_all, c(list(str = x), p)))
} else if(is.character(p)) {
return(stringi::stri_locate_all(
x, regex = p, ...
))
} else {
stop("`p` must be a character vector or list")
}
}
if(is.null(i)) {
if(is.list(p)){
return(do.call(stringi::stri_extract_all, c(list(str = x), p)))
} else if(is.character(p)) {
return(stringi::stri_extract_all(
x, regex = p, ...
))
} else {
stop("`p` must be a character vector or list")
}
}
}
#' @rdname str_truth
#' @export
`strfind<-` <- function(x, p, ..., value) {
if(is.list(p)){
args <- list(str = x, vectorize_all = TRUE, replacement = value)
return(do.call(stringi::stri_replace_all, c(args, p)))
} else if(is.character(p)) {
return(stringi::stri_replace_all(
x, replacement = value, regex = p, vectorize_all = TRUE, ...
))
} else {
stop("`p` must be a character vector or list")
}
}
x <- rep('The quick brown fox jumped over the lazy dog.', 3)
print(x)
p <- c('quick', 'brown', 'fox')
rp <- c('slow',  'black', 'bear')
x %s{}% p
strfind(x, p)
strfind(x, p) <- rp
print(x)
